

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/avatar.png">
  <link rel="icon" href="/images/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="KuanMi">
  <meta name="keywords" content="">
  
    <meta name="description" content="实体包中的脚本 本节包含有关在实体中编写脚本时的最佳实践的信息，以及您可以在脚本中使用的一些功能。     标题 描述     使用方面组织代码 使用方面将实体组件的子集组合到单个 csharp 结构中。   Blob 资产 有关 blob 资产的信息，这些资产是针对流式处理优化的二进制数据片段。   在运行时加载场景 关于实体如何加载场景的信息。">
<meta property="og:type" content="article">
<meta property="og:title" content="ECS 脚本">
<meta property="og:url" content="https://www.kuanmi.top/2022/11/17/ECS-Scripting/index.html">
<meta property="og:site_name" content="KuanMi">
<meta property="og:description" content="实体包中的脚本 本节包含有关在实体中编写脚本时的最佳实践的信息，以及您可以在脚本中使用的一些功能。     标题 描述     使用方面组织代码 使用方面将实体组件的子集组合到单个 csharp 结构中。   Blob 资产 有关 blob 资产的信息，这些资产是针对流式处理优化的二进制数据片段。   在运行时加载场景 关于实体如何加载场景的信息。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/images/entities-splash-image.png">
<meta property="article:published_time" content="2022-11-16T23:44:36.000Z">
<meta property="article:modified_time" content="2025-03-18T01:12:02.897Z">
<meta property="article:author" content="KuanMi">
<meta property="article:tag" content="Entities">
<meta property="article:tag" content="ECS">
<meta property="article:tag" content="DOTS">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/images/entities-splash-image.png">
  
  
  
  <title>ECS 脚本 - KuanMi</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/prism/1.27.0/plugins/line-numbers/prism-line-numbers.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"www.kuanmi.top","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"gtag":null},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>KuanMi</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/images/entities-splash-image.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="ECS 脚本"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        KuanMi
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-11-17 07:44" pubdate>
          2022年11月17日 早上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          20k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          167 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">ECS 脚本</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="实体包中的脚本">实体包中的脚本</h1>
<p>本节包含有关在实体中编写脚本时的最佳实践的信息，以及您可以在脚本中使用的一些功能。</p>
<table>

<thead>
<tr class="header">
<th>标题</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>使用方面组织代码</td>
<td>使用方面将实体组件的子集组合到单个 csharp 结构中。</td>
</tr>
<tr class="even">
<td>Blob 资产</td>
<td>有关 blob
资产的信息，这些资产是针对流式处理优化的二进制数据片段。</td>
</tr>
<tr class="odd">
<td>在运行时加载场景</td>
<td>关于实体如何加载场景的信息。</td>
</tr>
<tr class="even">
<td>转换系统</td>
<td>有关转换如何在实体中工作的信息。</td>
</tr>
</tbody>
</table>
<h1 id="使用-baking-转换数据">使用 Baking 转换数据</h1>
<p>Baking
提供了一个系统，用于将编辑器中的游戏对象数据（创作数据）转换为写入实体场景的实体（运行时数据）。</p>
<p>烘焙分为多个阶段，但其核心是两个关键步骤：面包师和烘焙系统。</p>
<p>当您打开子场景并在其中编辑创作对象时，也会发生增量烘焙。 ECS
会检测您所做的更改，并确定由于此更改而需要重新运行的最少 Baker
数量。其结果在编辑模式和播放模式期间被修补到编辑器中的实体世界中。</p>
<h2 id="baker-类">Baker 类</h2>
<p>使用 Baker 类直接与 Unity 对象交互，例如创作组件。 Baker
也是隐式或显式捕获依赖项的地方，如果 Baker
重新运行，添加的所有组件都能够自动恢复。 Baker
只能将组件添加到它正在烘焙的主要实体和它自己创建的其他实体。例如：<br />
<figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public class MyMonoBehaviour : MonoBehaviour
&#123;
   public float value;
&#125;

public class MyBaker : Baker&lt;MyMonoBehaviour&gt;
&#123;
   public override void Bake(MyMonoBehaviour authoring)
   &#123;
       AddComponent(new MyComponent &#123;Value &#x3D; authoring.value&#125; );
   &#125;
&#125;
</code></pre></div></figure></p>
<h3 id="访问-baker-中的其他数据源">访问 Baker 中的其他数据源</h3>
<p>为了保持增量烘焙正常工作，您需要跟踪哪些数据用于转换 Baker
中的游戏对象。创作组件中的任何字段都会被自动跟踪，如果任何数据发生变化，Baker
就会重新运行。</p>
<p>不会自动跟踪来自其他创作组件的信息，您需要向其添加依赖项才能对其进行跟踪。为此，请使用
Baker 提供的函数来访问其他组件，而不是 GameObject 提供的函数：<br />
<figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public struct MyComponent : IComponentData
&#123;
   public float Value;
&#125;

public class MyMonoBehaviour : MonoBehaviour
&#123;
   public GameObject otherGO;
&#125;

public class MyBaker : Baker&lt;MyMonoBehaviour&gt;
&#123;
   public override void Bake(MyMonoBehaviour authoring)
   &#123;
       var transform &#x3D; GetComponent&lt;Transform&gt;(authoring.otherGO);
       AddComponent(new MyComponent &#123;Value &#x3D; transform.position.x&#125; );
   &#125;
&#125;</code></pre></div></figure><br />
同样，如果您访问资产中的数据，则需要为其创建依赖项，以便 Baker
在资产更改时重新运行。<br />
<figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public struct MyComponent : IComponentData
&#123;
   public int Value;
&#125;

public class MyMonoBehaviour : MonoBehaviour
&#123;
   public Mesh mesh;
&#125;

public class MyBaker : Baker&lt;MyMonoBehaviour&gt;
&#123;
   public override void Bake(MyMonoBehaviour authoring)
   &#123;
       &#x2F;&#x2F; We want to rebake if anything changes in the mesh itself
       DependsOn(authoring.mesh);
       AddComponent(new MyComponent &#123; Value &#x3D; authoring.mesh.vertexCount &#125; );
   &#125;
&#125;</code></pre></div></figure></p>
<h3 id="贝克斯的预制件">贝克斯的预制件</h3>
<p>要声明和转换预制件，请在面包师中调用 GetEntity：<br />
<figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public struct MyComponent : IComponentData
&#123;
   public Entity Prefab;
&#125;

public class MyMonoBehaviour : MonoBehaviour
&#123;
   public GameObject prefab;
&#125;

public class MyBaker : Baker&lt;MyMonoBehaviour&gt;
&#123;
   public override void Bake(MyMonoBehaviour authoring)
   &#123;
       AddComponent(new MyComponent &#123; Prefab &#x3D; GetEntity(authoring.prefab) &#125; );
   &#125;
&#125;</code></pre></div></figure><br />
GetEntity
返回用于创建实体预制件的实体，但此时尚未转换。这稍后会在单独的传递中发生。</p>
<h3 id="烘焙系统">烘焙系统</h3>
<p>烘焙系统是处理面包师产生的输出的常规系统，例如通过组合结果。这意味着
Baking
系统应该只处理实体数据，而不处理托管的创作类型，例如游戏对象和组件。这也意味着
Baking 系统可以使用 Burst 和 Jobs 来处理数据。</p>
<p>要创建烘焙系统，请使用
[WorldSystemFilter(WorldSystemFilterFlags.BakingSystem)]
属性对其进行标记。这允许烘焙发现它们并将它们添加到烘焙世界。烘焙系统在每次烘焙过程中都会更新。<br />
<figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">[WorldSystemFilter(WorldSystemFilterFlags.BakingSystem)]
partial class BakingOnlyEntityAuthoringBakingSystem : SystemBase
&#123;
   protected override void OnUpdate()
   &#123;
      &#x2F;&#x2F; … Your code here …
   &#125;
&#125;</code></pre></div></figure><br />
虽然面包师通常是必需的，但烘焙系统是可选的，只有高级用例才需要。</p>
<h2 id="用方面组织你的代码">用方面组织你的代码</h2>
<p>方面是一种类似于对象的包装器，可用于将实体组件的子集组合到单个 csharp
结构中。</p>
<p>本节说明如何在项目中使用方面。</p>
<table>
<thead>
<tr class="header">
<th>主题</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>方面概念</td>
<td>方面概述。</td>
</tr>
<tr class="even">
<td>创建方面</td>
<td>如何使用 IAspect 接口创建方面。</td>
</tr>
</tbody>
</table>
<h3 id="方面概念">方面概念</h3>
<p>方面是一种类似于对象的包装器，可用于将实体组件的子集组合到单个 csharp
结构中。方面对于组织组件代码和简化系统中的查询很有用。</p>
<p>例如，TransformAspect
将组件的各个位置、旋转和缩放组合在一起，使您能够从包含 TransformAspect
的查询访问这些组件。您还可以使用 IAspect 接口定义自己的方面。</p>
<p>方面可以包括以下项目：</p>
<ul>
<li>用于存储实体 ID 的单个实体字段</li>
<li>RefRW<T> 和 RefRO<T> 字段访问实现 IComponentData 的类型 T
的组件数据。</li>
<li>EnabledRefRW 和 EnabledRefRO 字段，用于访问实现 IEnableableComponent
的组件的启用状态。</li>
<li>DynamicBuffer<T> 字段</li>
<li>其他方面类型</li>
</ul>
<h4 id="更多信息">更多信息</h4>
<ul>
<li>创建一个方面</li>
<li>IAspect API 文档</li>
<li>转换方面 API 文档</li>
</ul>
<h3 id="创建一个方面">创建一个方面</h3>
<p>要创建方面，请使用 IAspect
接口。您必须将方面声明为只读部分结构，并且该结构必须将自身指定给
IAspect<T> 泛型参数：<br />
<figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using Unity.Entities;

readonly partial struct MyAspect : IAspect
&#123;
    &#x2F;&#x2F; Your Aspect code
&#125;</code></pre></div></figure></p>
<h4 id="字段">字段</h4>
<p>您可以使用 RefRW<T> 或 RefRO<T>
将组件声明为方面的一部分。要声明缓冲区，请使用
DynamicBuffer<T>。有关可用字段的更多信息，请参阅 IAspect 文档。</p>
<h4 id="只读和读写访问">只读和读写访问</h4>
<p>使用 RefRO 和 RefRW
字段提供对方面中组件的只读或读写访问。当你想在代码中引用一个方面时，使用
in 来覆盖所有引用变为只读，或者使用 ref
来尊重在方面中声明的只读或读写访问。</p>
<p>如果您使用 in
来引用对组件具有读写访问权限的方面，它可能会在写入尝试时抛出异常。</p>
<h4 id="在系统中创建方面实例">在系统中创建方面实例</h4>
<p>要在系统中创建方面实例，请调用 SystemAPI.GetAspectRW 或
SystemAPI.GetAspectRO：<br />
<figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; Throws if the entity is missing any of 
&#x2F;&#x2F; the required components of MyAspect.
MyAspect asp &#x3D; SystemAPI.GetAspectRW&lt;MyAspect&gt;(myEntity);</code></pre></div></figure><br />
如果您使用任何试图修改底层组件的方法或属性，则 SystemAPI.GetAspectRO
会引发错误。</p>
<p>要在系统外部创建方面实例，请使用 EntityManager.GetAspect 或
EntityManager.GetAspectRO。</p>
<h4 id="例子">例子</h4>
<p>在此示例中，CannonBallAspect
设置坦克主题游戏中炮弹组件的变换、位置和速度。<br />
<figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using Unity.Entities;
using Unity.Mathematics;
using Unity.Transforms;

&#x2F;&#x2F; Aspects must be declared as a readonly partial struct
readonly partial struct CannonBallAspect : IAspect&lt;CannonBallAspect&gt;
&#123;
    &#x2F;&#x2F; An Entity field in an Aspect gives access to the Entity itself.
    &#x2F;&#x2F; This is required for registering commands in an EntityCommandBuffer for example.
    public readonly Entity Self;

    &#x2F;&#x2F; Aspects can contain other aspects.
    readonly TransformAspect Transform;

    &#x2F;&#x2F; A RefRW field provides read write access to a component. If the aspect is taken as an &quot;in&quot;
    &#x2F;&#x2F; parameter, the field behaves as if it was a RefRO and throws exceptions on write attempts.
    readonly RefRW&lt;CannonBall&gt; CannonBall;

    &#x2F;&#x2F; Properties like this aren&#39;t mandatory. The Transform field can be public instead.
    &#x2F;&#x2F; But they improve readability by avoiding chains of &quot;aspect.aspect.aspect.component.value.value&quot;.
    public float3 Position
    &#123;
        get &#x3D;&gt; Transform.Position;
        set &#x3D;&gt; Transform.Position &#x3D; value;
    &#125;

    public float3 Speed
    &#123;
        get &#x3D;&gt; CannonBall.ValueRO.Speed;
        set &#x3D;&gt; CannonBall.ValueRW.Speed &#x3D; value;
    &#125;
&#125;</code></pre></div></figure><br />
要在其他代码中使用此方面，您可以以与组件相同的方式请求
CannonBallAspect：<br />
<figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using Unity.Entities;
using Unity.Burst;

&#x2F;&#x2F; It&#39;s best practice to Burst-compile your code
[BurstCompile]
partial struct CannonBallJob : IJobEntity
&#123;
    void Execute(ref CannonBallAspect cannonBall)
    &#123;
        &#x2F;&#x2F; Your game logic
    &#125;
&#125;</code></pre></div></figure></p>
<h2 id="实体中的转换">实体中的转换</h2>
<p>本节包含有关变换如何在实体中工作以及如何控制项目中任何实体的世界空间位置、旋转和缩放的信息。</p>
<table>
<thead>
<tr class="header">
<th>主题</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>转换概念</td>
<td>转换如何在实体中工作。</td>
</tr>
<tr class="even">
<td>使用转换</td>
<td>如何在您的项目中使用转换。</td>
</tr>
<tr class="odd">
<td>转换方面</td>
<td>如何使用 TransformAspect 来管理项目中的转换。</td>
</tr>
</tbody>
</table>
<h3 id="转变观念">转变观念</h3>
<p>您可以使用 Unity.Transforms
命名空间来控制项目中任何实体的世界空间位置、旋转和缩放。</p>
<p>您还可以使用内置方面
TransformAspect，将实体及其父实体移动到一起，并保持实体数据同步。有关详细信息，请参阅
TransformAspect 文档。</p>
<p>主要的 Transform 组件是：</p>
<ul>
<li>LocalToWorldTransform：修改这些值以更改实体的世界空间位置。表示世界空间中对象的每个实体都具有此组件。重要提示：如果实体还包含
LocalToParentTransform 和
ParentToWorldTransform，它们将优先并覆盖您输入的 LocalToWorldTransform
值。</li>
<li>LocalToParentTransform：表示从本地空间到父空间的转换。定义子实体如何相对于其父实体进行转换。</li>
<li>ParentToWorldTransform：父实体的 LocalToWorldTransform 的副本。</li>
</ul>
<p>如果所有三个 Transform 组件都存在于一个实体上，则 ECS 计算
LocalToWorldTransform 为：<br />
<figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">LocalToWorldTransform &#x3D; LocalToParentTransform * ParentToWorldTransform</code></pre></div></figure><br />
您可以使用 Convert To Entity
脚本为您创建和初始化所有组件。要使用此脚本，请在 EntitiesSamples
项目中打开 HelloCube 并选择大立方体。在 Inspector 中，选择 Convert To
Entity 组件，它将 GameObject 转换为实体。</p>
<h4 id="转换层次结构">转换层次结构</h4>
<p>Unity.Transforms
是分层的，这意味着您可以根据实体之间的关系来转换实体。</p>
<p>例如，车身可以是其车轮的父级。车轮是车身的孩子。当车身移动时，车轮也随之移动。您还可以相对于车身移动和旋转车轮。</p>
<p>一个实体可以有多个子实体，但只有一个父实体。孩子也可以是他们自己的孩子实体的父母。这些多层次的父子关系形成了一个转换层次结构。层次结构顶部的实体（没有父实体）是根。</p>
<p>要声明一个 Transform
层次结构，您必须从下到上执行此操作。这意味着您使用 Parent
来声明实体的父实体，而不是声明其子实体。如果你想声明一个实体的孩子，找到你想成为孩子的实体，并将他们的父母设置为目标实体。有关详细信息，请参阅使用层次结构文档。</p>
<h3 id="使用变换">使用变换</h3>
<p>要在项目中使用变换，请使用 Unity.Transforms
命名空间来控制项目中任何实体的世界空间位置、旋转和缩放。</p>
<p>要存储位置、旋转和比例值，请使用 UniformScaleTransform：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public struct UniformScaleTransform
&#123;
    public float3     Position
    public float      Scale
    public quaternion Rotation
&#125;</code></pre></div></figure>
<p>代表项目中对象的每个实体都有一个
LocalToWorldTransform，您可以使用它来转换实体相对于它在世界空间中的位置：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public struct LocalToWorldTransform : IComponentData
&#123;
    public UniformScaleTransform Value;
&#125;</code></pre></div></figure>
<h4 id="使用层次结构">使用层次结构</h4>
<p>您可以单独使用 LocalToWorldTransform。但是，如果要使用 Entities
的层次结构，则必须使用 Parent、LocalToParentTransform 和
ParentToWorldTransform 来转换它们。</p>
<p>要设置子实体的父级，请使用 Parent：<br />
<figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public struct Parent : IComponentData
&#123;
    public Entity Value;
&#125;</code></pre></div></figure><br />
为确保父母找到他们的孩子，并设置他们的子组件，请运行 ParentSystem。</p>
<p>要指定如何相对于其父项定位、旋转和缩放子项，请使用
LocalToParentTransform。例如，这是您可以在父汽车对象上旋转车轮的方式：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public struct LocalToParentTransform : IComponentData
&#123;
    public UniformScaleTransform Value;
&#125;</code></pre></div></figure>
<p>另一个重要的组件是 ParentToWorldTransform，它是父级
LocalToWorldTransform 的副本。您需要确保孩子有这个，并且
ParentToWorldTransformSystem 正在运行。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public struct ParentToWorldTransform : IComponentData
&#123;
    public UniformScaleTransform Value;
&#125;</code></pre></div></figure>
<h3 id="变换方面">变换方面</h3>
<p>方面系统具有内置的
TransformAspect，它包含对子实体的所有三个转换组件的引用：</p>
<ul>
<li>本地到世界转换</li>
<li>本地到父转换</li>
<li>ParentToWorldTransform</li>
</ul>
<p>对于任何根实体，TransformAspect 仅包含对 LocalToWorldTransform
的引用。</p>
<p>TransformAspect
是管理项目中转换的便捷方式，因为它包含使所有这些组件彼此保持同步的逻辑。例如，如果您想在不使用
TransformAspect 的情况下控制子组件的世界空间位置，则必须同时更新
LocalToWorldTransform 和 LocalToParentTransform，然后在该计算中使用
ParentToWorldTransform。</p>
<p>但是，TransformAspect
会为您管理这个。这是移动可能有父实体的便捷方式。</p>
<p>此示例说明如何使用 TransformAspect 来旋转坦克的炮塔：<br />
<figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using Unity.Burst;
using Unity.Entities;
using Unity.Mathematics;
using Unity.Transforms;

[BurstCompile]
partial struct TurretRotationSystem : ISystem
&#123;
    [BurstCompile]
    public void OnCreate(ref SystemState state)
    &#123;
    &#125;

    [BurstCompile]
    public void OnDestroy(ref SystemState state)
    &#123;
    &#125;

    [BurstCompile]
    public void OnUpdate(ref SystemState state)
    &#123;
        &#x2F;&#x2F; The amount of rotation around Y required to do 360 degrees in 2 seconds.
        var rotation &#x3D; quaternion.RotateY(state.Time.DeltaTime * math.PI);

        &#x2F;&#x2F; The classic csharp foreach is what we often refer to as &quot;Idiomatic foreach&quot; (IFE).
        &#x2F;&#x2F; Aspects provide a higher level interface than directly accessing component data.
        &#x2F;&#x2F; Using IFE with aspects is a powerful and expressive way of writing main thread code.
        foreach (var transform in SystemAPI.Query&lt;TransformAspect&gt;())
        &#123;
            transform.RotateWorld(rotation);
        &#125;
    &#125;
&#125;</code></pre></div></figure></p>
<h1 id="blob-资产">Blob 资产</h1>
<p>Blob 资产是针对流式处理优化的二进制数据片段。 Blob 是 Binary Large
Object 的缩写。通过将数据写入 blob
资产，您可以将其存储在一种可以高效加载并从存储在实体上的组件中引用的格式。与结构组件一样，blob
资产不得包含任何托管数据：您不能在 blob
资产中使用常规数组、字符串或任何其他托管对象。 Blob
资产应该只包含在运行时不会更改的只读数据：它们可以同时从多个线程访问，并且（与本机容器不同）没有针对并发写入的安全检查。</p>
<p>为了快速加载 blob 资产，它们的数据必须是可重定位的：当您将整个 blob
资产复制到另一个内存地址时，blob 资产中数据的含义不得改变。这意味着 blob
资产可能不包含对自身的绝对引用，这排除了内部指针的使用。您通常通过指针存储的任何信息都必须通过相对于
blob
资产本身的内存地址的偏移量来引用。这主要适用于存储字符串和数组。这种使用偏移量而不是绝对指针的间接寻址的细节以两种方式影响与
blob 资产的交互：</p>
<ol type="1">
<li>必须使用 BlobBuilder 创建 Blob
资产。这种类型负责为您计算相对偏移量。</li>
<li>必须始终使用 ref 关键字或使用 BlobAssetReference 通过引用访问和传递
Blob 资产。这是确保 blob
资产内的任何相对偏移仍解析为正确的绝对地址所必需的。问题又是重定位：Blob
资产可以在内存中作为一个整体重定位，但按值而不是按引用访问它们通常不能保证复制整个
blob 资产。</li>
</ol>
<div class="note note-info">
            <p>如果您尝试使用按值包含内部指针的 blob 资产，则会出现编译器错误。</p>
          </div>
<h2 id="创建-blob-资产">创建 blob 资产</h2>
<p>创建 blob 资产始终至少涉及四个步骤：</p>
<ol type="1">
<li>创建一个 BlobBuilder。这需要在内部分配一些内存。</li>
<li>使用 BlobBuilder.ConstructRoot 构造 blob 资产的根</li>
<li>用您的数据填充结构。</li>
<li>使用 BlobBuilder.CreateBlobAssetReference 创建
BlobAssetReference。这会将 blob 资产复制到最终位置。</li>
<li>处理在步骤 1 中分配的 blob 生成器。</li>
</ol>
<p>例如，这里我们将仅包含原始成员的结构存储为 blob 资产：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">
struct MarketData
&#123;
    public float PriceOranges;
    public float PriceApples;
&#125;

BlobAssetReference&lt;MarketData&gt; CreateMarketData()
&#123;
    &#x2F;&#x2F; Create a new builder that will use temporary memory to construct the blob asset
    var builder &#x3D; new BlobBuilder(Allocator.Temp);

    &#x2F;&#x2F; Construct the root object for the blob asset. Notice the use of &#96;ref&#96;.
    ref MarketData marketData &#x3D; ref builder.ConstructRoot&lt;MarketData&gt;();

    &#x2F;&#x2F; Now fill the constructed root with the data:
    &#x2F;&#x2F; Apples compare to Oranges in the universally accepted ratio of 2 : 1 .
    marketData.PriceApples &#x3D; 2f;
    marketData.PriceOranges &#x3D; 4f;

    &#x2F;&#x2F; Now copy the data from the builder into its final place, which will
    &#x2F;&#x2F; use the persistent allocator
    var result &#x3D; builder.CreateBlobAssetReference&lt;MarketData&gt;(Allocator.Persistent);

    &#x2F;&#x2F; Make sure to dispose the builder itself so all internal memory is disposed.
    builder.Dispose();
    return result;
&#125;</code></pre></div></figure>
<p>blob 构建器的作用是构造存储在 blob
资产中的数据，确保所有内部引用都存储为偏移量，最后将完成的 blob
资产复制到由返回的 BlobAssetReference<T> 引用的单个分配中。</p>
<h3 id="使用-blobarray">使用 BlobArray</h3>
<p>blob
资产中的数组需要特殊处理，因为它们是在内部使用相对偏移量实现的。这是使用
BlobArray 类型实现的。以下是分配 blob 数据数组并填充它的方法：<br />
<figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">
struct Hobby
&#123;
    public float Excitement;
    public int NumOrangesRequired;
&#125;

struct HobbyPool
&#123;
    public BlobArray&lt;Hobby&gt; Hobbies;
&#125;

BlobAssetReference&lt;HobbyPool&gt; CreateHobbyPool()
&#123;
    var builder &#x3D; new BlobBuilder(Allocator.Temp);
    ref HobbyPool hobbyPool &#x3D; ref builder.ConstructRoot&lt;HobbyPool&gt;();

    &#x2F;&#x2F; Allocate enough room for two hobbies in the pool. Use the returned BlobBuilderArray
    &#x2F;&#x2F; to fill in the data.
    const int numHobbies &#x3D; 2;
    BlobBuilderArray&lt;Hobby&gt; arrayBuilder &#x3D; builder.Allocate(
        ref hobbyPool.Hobbies,
        numHobbies
    );

    &#x2F;&#x2F; Initialize the hobbies.

    &#x2F;&#x2F; An exciting hobby that consumes a lot of oranges.
    arrayBuilder[0] &#x3D; new Hobby
    &#123;
        Excitement &#x3D; 1,
        NumOrangesRequired &#x3D; 7
    &#125;;

    &#x2F;&#x2F; A less exciting hobby that conserves oranges.
    arrayBuilder[1] &#x3D; new Hobby
    &#123;
        Excitement &#x3D; 0.2f,
        NumOrangesRequired &#x3D; 2
    &#125;;

    var result &#x3D; builder.CreateBlobAssetReference&lt;HobbyPool&gt;(Allocator.Persistent);
    builder.Dispose();
    return result;
&#125;
</code></pre></div></figure></p>
<h3 id="使用-blobstring">使用 BlobString</h3>
<p>字符串具有与数组相同的问题，并且具有使用 BlobString
的自定义支持。它们同样使用 BlobBuilder API 进行分配。<br />
<figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">
struct CharacterSetup
&#123;
    public float Loveliness;
    public BlobString Name;
&#125;

BlobAssetReference&lt;CharacterSetup&gt; CreateCharacterSetup(string name)
&#123;
    var builder &#x3D; new BlobBuilder(Allocator.Temp);
    ref CharacterSetup character &#x3D; ref builder.ConstructRoot&lt;CharacterSetup&gt;();

    character.Loveliness &#x3D; 9001; &#x2F;&#x2F; it&#39;s just a very lovely character

    &#x2F;&#x2F; Create a new BlobString and set it to the given name.
    builder.AllocateString(ref character.Name, name);

    var result &#x3D; builder.CreateBlobAssetReference&lt;CharacterSetup&gt;(Allocator.Persistent);
    builder.Dispose();
    return result;
&#125;</code></pre></div></figure></p>
<h3 id="使用-blobptr">使用 BlobPtr</h3>
<p>如果需要手动设置内部指针，可以使用 BlobPtr 类型。<br />
<figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">
struct FriendList
&#123;
    public BlobPtr&lt;BlobString&gt; BestFriend;
    public BlobArray&lt;BlobString&gt; Friends;
&#125;

BlobAssetReference&lt;FriendList&gt; CreateFriendList()
&#123;
    var builder &#x3D; new BlobBuilder(Allocator.Temp);
    ref FriendList friendList &#x3D; ref builder.ConstructRoot&lt;FriendList&gt;();

    const int numFriends &#x3D; 3;
    var arrayBuilder &#x3D; builder.Allocate(ref friendList.Friends, numFriends);
    builder.AllocateString(ref arrayBuilder[0], &quot;Alice&quot;);
    builder.AllocateString(ref arrayBuilder[1], &quot;Bob&quot;);
    builder.AllocateString(ref arrayBuilder[2], &quot;Joachim&quot;);

    &#x2F;&#x2F; Set the best friend pointer to point to the second array element.
    builder.SetPointer(ref friendList.BestFriend, ref arrayBuilder[2]);

    var result &#x3D; builder.CreateBlobAssetReference&lt;FriendList&gt;(Allocator.Persistent);
    builder.Dispose();
    return result;
&#125;
</code></pre></div></figure></p>
<h2 id="访问组件上的-blob-资产">访问组件上的 blob 资产</h2>
<p>获得 Blob 资产的 BlobAssetReference<T>
后，您可以将此引用存储在组件上并访问它。请注意，必须通过引用访问包含内部指针的
blob 资产的所有部分。<br />
<figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">
struct Hobbies : IComponentData
&#123;
    public BlobAssetReference&lt;HobbyPool&gt; Blob;
&#125;

float GetExcitingHobby(ref Hobbies component, int numOranges)
&#123;
    &#x2F;&#x2F; Get a reference to the pool of available hobbies. Note that it needs to be passed by
    &#x2F;&#x2F; reference, because otherwise the internal reference in the BlobArray would be invalid.
    ref HobbyPool pool &#x3D; ref component.Blob.Value;

    &#x2F;&#x2F; Find the most exciting hobby we can participate in with our current number of oranges.
    float mostExcitingHobby &#x3D; 0;
    for (int i &#x3D; 0; i &lt; pool.Hobbies.Length; i++)
    &#123;
        &#x2F;&#x2F; This is safe to use without a reference, because the Hobby struct does not
        &#x2F;&#x2F; contain internal references.
        var hobby &#x3D; pool.Hobbies[i];
        if (hobby.NumOrangesRequired &gt; numOranges)
            continue;
        if (hobby.Excitement &gt;&#x3D; mostExcitingHobby)
            mostExcitingHobby &#x3D; hobby.Excitement;
    &#125;

    return mostExcitingHobby;
&#125;
</code></pre></div></figure></p>
<h2 id="我什么时候需要处理-blob-资产引用">我什么时候需要处理 blob
资产引用？</h2>
<p>在运行时使用 BlobBuilder.CreateBlobAssetReference 分配的所有 blob
资产都需要手动处理。这对于作为从磁盘加载的实体场景的一部分加载的 blob
资产是不同的：所有这些 blob
资产都是引用计数的，一旦没有组件引用它们就会自动释放。不得手动处理它们。</p>
<h2 id="调试-blob-资产内容">调试 blob 资产内容</h2>
<p>Blob 资产使用相对偏移量实现内部引用。这意味着复制 BlobString
结构（或具有这些内部引用的任何其他类型）将复制包含的相对偏移量，而不是它指向的内容。这样做的结果是一个不可用的
BlobString，它将代表一个基本上随机的字符串。虽然这在您自己的代码中很容易避免，但调试实用程序通常会做到这一点。因此，BlobString
的内容无法在调试器中正确显示。</p>
<p>但是，支持显示 BlobAssetReference<T> 的值及其所有内容。如果要查找
BlobString 的内容，请导航到包含的 BlobAssetReference<T>
并从那里开始调试。</p>
<h1 id="在运行时加载场景">在运行时加载场景</h1>
<h2 id="串流">串流</h2>
<p>加载大场景需要时间，所以为了避免卡顿，DOTS中的所有场景加载默认都是异步的。这称为流式传输。</p>
<p>由于改造项目以使用流式处理可能很繁重，因此您最好尽早决定是否在项目中使用流式处理。</p>
<p>流式传输的主要优点是：</p>
<ul>
<li>当场景在后台流式传输时，应用程序可以保持响应。</li>
<li>通过在不中断游戏玩法的情况下动态加载和卸载场景，可以实现比内存更大的无缝世界。</li>
<li>在编辑器播放模式下，如果实体场景文件丢失或过时，场景将按需转换。因为实体场景的转换和加载是异步发生的并且在一个单独的进程中，所以编辑器保持响应。</li>
</ul>
<p>流式传输的主要缺点是：</p>
<ul>
<li>游戏不能假定加载的数据立即存在，尤其是在启动时。这使得游戏代码有点复杂。</li>
<li>场景由“场景系统组”中的系统加载，“场景系统组”本身是“初始化组”的一部分。在帧中更新较晚的系统将在同一帧中看到加载的数据，但更新早于该组的系统直到下一帧才会看到加载的数据。然后，您的代码必须在单个-
框架内解决这种不一致的数据视图。</li>
</ul>
<h2 id="the-subscene-monobehaviour">The Subscene Monobehaviour</h2>
<p>Subscene Monobehavior 是一个简单的 Unity
组件，它抽象了转换和流式处理问题。</p>
<p>打开子场景时，创作游戏对象场景会显示在父场景的层次结构中。<br />
关闭子场景时，转换后的场景的内容将流入。<br />
本页的其余部分描述了如何在不使用 Subscene MonoBehavior
的情况下直接控制流式传输。</p>
<h2 id="场景加载-101">场景加载 101</h2>
<p>用于处理场景的高级 API 由 SceneSystem 提供。</p>
<p>这是在运行时加载场景的最基本示例。这应该在系统的 OnUpdate
中完成。<br />
<figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">
&#x2F;&#x2F; Note: calling GetSceneGUID is slow, please keep reading for a proper example.
var guid &#x3D; SceneSystem.GetSceneGUID(ref World.Unmanaged.GetExistingSystemState&lt;SceneSystem&gt;(), &quot;Assets&#x2F;Scenes&#x2F;SampleScene.unity&quot;);
var sceneEntity &#x3D; SceneSystem.LoadSceneAsync(World.Unmanaged, guid);</code></pre></div></figure></p>
<div class="note note-warning">
            <p>此示例计划加载。在调用 LoadSceneAsync期间，唯一创建的是场景实体，然后使用它来控制加载过程的其余部分。值得注意的是，场景标题、部分实体及其内容此时尚未加载，只会在几帧后出现在世界中。</p>
          </div>
<ul>
<li>在 DOTS 的上下文中，场景 GUID 是 Hash128。</li>
<li>该路径指向 Unity
创作场景。如果对应的实体场景文件丢失或过期，则触发转换。</li>
</ul>
<h2 id="使用场景-guid">使用场景 GUID</h2>
<p>通过 GUID
识别场景比使用字符串路径更有效。因此，通常的方法是在转换期间存储场景
GUID，以用于在运行时加载<br />
<figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">
    &#x2F;&#x2F; Runtime component, SceneSystem uses Entities.Hash128 to identify scenes.
    public struct SceneLoader : IComponentData
    &#123;
        public Hash128 Guid;
    &#125;

#if UNITY_EDITOR
    &#x2F;&#x2F; Authoring component, a SceneAsset can only be used in the Editor
    public class SceneLoaderAuthoring : MonoBehaviour
    &#123;
        public UnityEditor.SceneAsset Scene;

        class Baker : Baker&lt;SceneLoaderAuthoring&gt;
        &#123;
            public override void Bake(SceneLoaderAuthoring authoring)
            &#123;
                var path &#x3D; AssetDatabase.GetAssetPath(authoring.Scene);
                var guid &#x3D; AssetDatabase.GUIDFromAssetPath(path);
                AddComponent(new SceneLoader &#123; Guid &#x3D; guid &#125;);
            &#125;
        &#125;
    &#125;
#endif</code></pre></div></figure><br />
在运行时处理 SceneLoader 组件的示例系统如下所示：<br />
<figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">
[RequireMatchingQueriesForUpdate]
public partial class SceneLoaderSystem : SystemBase
&#123;
    private EntityQuery m_NewRequests;

    protected override void OnCreate()
    &#123;
        m_NewRequests &#x3D; GetEntityQuery(typeof(SceneLoader));
    &#125;

    protected override void OnUpdate()
    &#123;
        var requests &#x3D; m_NewRequests.ToComponentDataArray&lt;SceneLoader&gt;(Allocator.Temp);

        for (int i &#x3D; 0; i &lt; requests.Length; i +&#x3D; 1)
        &#123;
            SceneSystem.LoadSceneAsync(World.Unmanaged, requests[i].Guid);
        &#125;

        requests.Dispose();
        EntityManager.DestroyEntity(m_NewRequests);
    &#125;
&#125;
</code></pre></div></figure></p>
<div class="note note-info">
            <p>在编辑器中，SceneSystem.GetGUID 函数在内部使用UnityEditor.AssetDatabase 类将场景路径映射到 GUID。</p><p>在独立播放器中，无法使用 UnityEditor.AssetDatabase，因此SceneSystem.GetGUID改为使用“StreamingAssets/catalog.bin”文件。这个“catalog.bin”文件只不过是一个“GUID路径”映射表，该目录文件是通过使用构建配置进行独立构建而生成的）。</p>
          </div>
<h2 id="场景和部分元实体">场景和部分元实体</h2>
<p>创作场景的转换会生成实体场景文件。每个实体场景文件的头部包含：</p>
<ul>
<li>部分列表（包含文件名、文件大小、边界体积等数据）。</li>
<li>资产包依赖项 (GUID) 的列表。</li>
<li>可选的用户定义的元数据。</li>
</ul>
<p>部分和捆绑包的列表决定了应该加载的文件列表，自定义元数据可用于特定于游戏的目的。例如，自定义元数据可以包含
PVS 信息以告知何时流式传输场景的决定，或者诸如“此场景仅在任务 XYZ
处于活动状态时才相关”的游戏条​​件。由每个游戏决定如何使用自定义元数据。但是使用自定义元数据既是可选的又是高级主题，因此稍后将对其进行记录和说明。</p>
<p>加载实体场景分两步完成。首先，“解决”阶段加载标题，并为每个场景和每个部分创建一个元实体。只有在这之后，才会加载这些部分的内容。</p>
<p>这些场景和部分元实体用于控制实际的流式传输。默认情况下，调用
SceneSystem.LoadSceneAsync 将解析并加载所有内容。</p>
<div class="note note-info">
            <ul><li>应通过调用 SceneSystem 上的方法加载和卸载整个场景。</li><li>通过在表示场景的实体上添加和删除 RequestLoaded组件来加载和卸载场景部分。这些请求由 SceneSectionStreamingSystem处理，它是 SceneSystemGroup 的一部分。</li></ul>
          </div>
<h2 id="串流状态">串流状态</h2>
<p>流式传输是异步的，因此无法保证在请求数据后加载数据需要多长时间。虽然
SceneSystem
允许查询场景和部分的加载状态，但在大多数情况下应该不需要这样做。</p>
<p>理想情况下，系统应该对其所需数据的存在或不存在做出反应，而不是对某些场景是否正在加载做出反应。如果系统需要运行的数据是特定场景的一部分，那么判断是否更新系统应该通过检查是否加载了特定数据来完成，而不是检查场景本身是否已经加载。这种方法避免了将系统绑定到特定场景：如果系统所需的数据被移动到不同的场景、从网络下载或程序生成，系统仍将以相同的方式工作，而无需更改其代码。</p>
<p>尽管如此，您仍可以检查场景或部分是否已加载。例如，这可能有助于实现一个加载屏幕，该屏幕应保持可见，直到所有计划的流媒体完成。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">
var sceneLoaded &#x3D; SceneSystem.IsSceneLoaded(World.Unmanaged, sceneEntity);
var sectionLoaded &#x3D; SceneSystem.IsSectionLoaded(World.Unmanaged, sceneSectionEntity);
</code></pre></div></figure>
<h2 id="场景部分">场景部分</h2>
<p>场景的各个部分可以独立加载和卸载。</p>
<p>场景中的每个实体都有一个 SceneSection 共享组件，其中包含场景的 GUID
(Hash128) 和部分编号（整数）。第 0 部分是默认部分。</p>
<p>在转换期间，可以通过更改 SceneSection
共享组件的值来设置实体的部分，如下所示：<br />
<figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public class SceneSection123Authoring : MonoBehaviour
&#123;
    class Baker : Baker&lt;SceneSection123Authoring&gt;
    &#123;
        &#x2F;&#x2F; TODO: This doesn&#39;t work with Baking, as it relied on ordering
        public override void Bake(SceneSection123Authoring authoring)
        &#123;
            &#x2F;&#x2F; This affects a single entity.
            &#x2F;&#x2F; For a recursive approach, see &#96;SceneSectionComponent&#96;.
            SetSharedComponent(GetEntity(), new SceneSection&#123;Section &#x3D; 123&#125;);
        &#125;
    &#125;
&#125;</code></pre></div></figure><br />
将上述组件添加到子场景引用的创作场景中的游戏对象将导致该子场景的检查器如下所示：</p>
<p><img
src="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/images/scene_section.png" srcset="/img/loading.gif" lazyload /></p>
<p>请注意，默认部分 0 始终存在（第一行），即使它是空的。名称的“Section:
0”部分被省略，但包含至少一个实体的所有其他部分将以其全名显示。</p>
<div class="note note-info">
            <p>所有部分都可以引用它们自己的实体和第 0部分中的实体。描述此参考系统的工作方式超出了此处的范围，但一个重要的结果是从场景中加载任何部分都需要来自同一场景的第0部分也是加载。相同的约束适用于卸载：只有当当前没有加载同一场景的其他部分时，才能卸载场景的第0 部分。</p>
          </div>
<p>一些现有的 DOTS
功能已经利用了部分加载。您可以通过编写自定义转换系统、使用
IConvertGameObjectToEntity（参见上面的示例）或使用创作组件
SceneSectionComponent（这将影响层次结构中的所有创作游戏对象）来显式控制您自己代码中的部分加载。</p>
<h2 id="独立加载场景部分">独立加载场景部分</h2>
<p>使用 DisableAutoLoad 参数调用 LoadSceneAsync
将通过创建场景和部分元实体来解析场景，但不会加载部分内容：<br />
<figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">
var loadParameters &#x3D; new SceneSystem.LoadParameters &#123;Flags &#x3D; SceneLoadFlags.DisableAutoLoad&#125;;
var sceneEntity &#x3D; SceneSystem.LoadSceneAsync(World.Unmanaged, sceneGuid, loadParameters);
</code></pre></div></figure><br />
一旦处理了加载请求，就会解析这些部分并创建它们的元实体。然后可以在场景元实体上查询
ResolvedSectionEntity
缓冲区。作为说明，以下代码将加载给定场景的每个其他部分。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">
&#x2F;&#x2F; To keep the sample code short, we assume that the sections have been resolved.
&#x2F;&#x2F; And the code that ensures the code runs only once isn&#39;t included either.
var sectionBuffer &#x3D; EntityManager.GetBuffer&lt;ResolvedSectionEntity&gt;(sceneEntity);
var sectionEntities &#x3D; sectionBuffer.ToNativeArray(Allocator.Temp);

for (int i &#x3D; 0; i &lt; sectionEntities.Length; i +&#x3D; 1)
&#123;
    if (i % 2 &#x3D;&#x3D; 0)
    &#123;
        &#x2F;&#x2F; Note that the condition includes section 0,
        &#x2F;&#x2F; nothing else will load if section 0 is missing.
        EntityManager.AddComponent&lt;RequestSceneLoaded&gt;(sectionEntities[i].SectionEntity);
    &#125;
&#125;

sectionEntities.Dispose();
</code></pre></div></figure>
<h2 id="卸载场景和部分">卸载场景和部分</h2>
<p>卸载整个场景及其所有部分是通过场景系统完成的。<br />
<figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">
SceneSystem.UnloadScene(World.Unmanaged, sceneEntity);</code></pre></div></figure><br />
也可以使用场景的 GUID 而不是其元实体来调用
UnloadScene，但这有两个缺点：</p>
<ul>
<li>该函数必须执行（可能代价高昂的）搜索表示与 GUID
匹配的场景的元实体。</li>
<li>如果加载同一场景的多个实例，按GUID卸载只会卸载一个实例。</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%85%B6%E4%BB%96/" class="category-chain-item">其他</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Entities/" class="print-no-link">#Entities</a>
      
        <a href="/tags/ECS/" class="print-no-link">#ECS</a>
      
        <a href="/tags/DOTS/" class="print-no-link">#DOTS</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>ECS 脚本</div>
      <div>https://www.kuanmi.top/2022/11/17/ECS-Scripting/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>KuanMi</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年11月17日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/12/06/ChatGPT/" title="ChatGPT">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">ChatGPT</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/11/17/ECS-components-intro/" title="ECS 组件">
                        <span class="hidden-mobile">ECS 组件</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script  src="https://lib.baomitu.com/prism/1.27.0/components/prism-core.min.js" ></script>

  <script  src="https://lib.baomitu.com/prism/1.27.0/plugins/autoloader/prism-autoloader.min.js" ></script>

  <script  src="https://lib.baomitu.com/prism/1.27.0/plugins/line-numbers/prism-line-numbers.min.js" ></script>

  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
