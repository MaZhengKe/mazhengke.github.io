<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MR环境下在URP中实现HDR Bloom</title>
    <link href="/2025/03/18/HDR-Bloom-URP/"/>
    <url>/2025/03/18/HDR-Bloom-URP/</url>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>在MR环境下，HDRBloom是一个很重要的效果，很多美术效果尤其是光效都需要HDRBloom来提升画面的质感。<br />但是在URP中，启用HDR默认是用的B10G11R11_UFloatPack32的格式，这个格式会牺牲透明通道，导致MR失效。<br />所以翻看Pico或者Meta的文档，他们都不允许开启HDR。</p><p>然后是Bloom。URP的bloom是按照RGBM编码在rgba四个通道中，计算时解码，也丢失了透明通道。</p><p>所以在MR环境下，要实现HDR Bloom，就需要自己对URP进行一些修改。</p><figure><img src="bloom.png" alt="bloom开关效果对比" /><figcaption aria-hidden="true">bloom开关效果对比</figcaption></figure><h1 id="hdr">HDR</h1><p>首先来处理HDR</p><h2 id="启用64位hdr精度">启用64位HDR精度</h2><p>首先是启用64位HDR精度，这个在URP中是有的（印象中2021的版本没有？），只是默认没有开启。</p><p>URP的配置文件中把很多选项隐藏了起来，要通过勾选<code>Show Additional Properties</code>来显示。</p><figure><img src="setting.png" alt="URP配置" /><figcaption aria-hidden="true">URP配置</figcaption></figure><p>然后就可以看到<code>HDR Precision</code>选项了，把它改成<code>64 Bits</code>就可以了。</p><figure><img src="HDRPrecisionpng.png" alt="HDR Precision" /><figcaption aria-hidden="true">HDR Precision</figcaption></figure><p>这里会导致显存带宽的增加，要注意。</p><h2 id="修改uberpost">修改UberPost</h2><p>URP的后处理比如色调映射、HDRMapping等都是在UberPost这一个Shader中实现的。<br />这里可以看到，它根本没有采样透明通道。</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">half3 color &#x3D; (0.0).xxx;&#123;    color &#x3D; SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, SCREEN_COORD_REMOVE_SCALEBIAS(uvDistorted)).xyz;&#125;</code></pre></div></figure><p>所以要修改这个Shader，把透明通道也采样进来。</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">half3 color &#x3D; (0.0).xxx;float alpha &#x3D; 1.0;&#123;    float4 vv &#x3D; SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, SCREEN_COORD_REMOVE_SCALEBIAS(uvDistorted));    color &#x3D; vv.xyz;    alpha &#x3D; vv.w;&#125;</code></pre></div></figure><p>到这里，MR环境下的HDR就可以正常工作了。</p><h1 id="bloom">Bloom</h1><p>然后是Bloom</p><h2 id="shader修改">Shader修改</h2><p>先来看看<code>Bloom.Shader</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">half4 EncodeHDR(half3 color)&#123;#if _USE_RGBM    half4 outColor &#x3D; EncodeRGBM(color);#else    half4 outColor &#x3D; half4(color, 1.0);#endif#if UNITY_COLORSPACE_GAMMA    return half4(sqrt(outColor.xyz), outColor.w); &#x2F;&#x2F; linear to γ#else    return outColor;#endif&#125;half3 DecodeHDR(half4 color)&#123;#if UNITY_COLORSPACE_GAMMA    color.xyz *&#x3D; color.xyz; &#x2F;&#x2F; γ to linear#endif#if _USE_RGBM    return DecodeRGBM(color);#else    return color.xyz;#endif&#125;</code></pre></div></figure><p>可以看到，Bloom是用RGBM编码的，这个编码会丢失透明通道。<br />所以把这种编码全部干掉，直接用RGBA编码，因为用了R16G16B16A16格式，所以不用担心精度问题。</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">half4 EncodeHDR(half4 color)&#123;    return color;&#125;half4 DecodeHDR(half4 color)&#123;    return color;&#125;</code></pre></div></figure><p>其他的大同小异，宗旨就是不要丢失透明通道。比如在上下采样时都要保留透明通道。<br />以上采样为例<br />从<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">half3 Upsample(float2 uv)&#123;    half3 highMip &#x3D; DecodeHDR(SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv));#if _BLOOM_HQ &amp;&amp; !defined(SHADER_API_GLES)    half3 lowMip &#x3D; DecodeHDR(SampleTexture2DBicubic(TEXTURE2D_X_ARGS(_SourceTexLowMip, sampler_LinearClamp), uv, _SourceTexLowMip_TexelSize.zwxy, (1.0).xx, unity_StereoEyeIndex));#else    half3 lowMip &#x3D; DecodeHDR(SAMPLE_TEXTURE2D_X(_SourceTexLowMip, sampler_LinearClamp, uv));#endif    return lerp(highMip, lowMip, Scatter);&#125;half4 FragUpsample(Varyings input) : SV_Target&#123;    UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);    half3 color &#x3D; Upsample(UnityStereoTransformScreenSpaceTex(input.texcoord));    return EncodeHDR(color);&#125;</code></pre></div></figure><br />改成<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">half4 Upsample(float2 uv)&#123;    half4 highMip &#x3D; DecodeHDR(SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv));    #if _BLOOM_HQ &amp;&amp; !defined(SHADER_API_GLES)        half4 lowMip &#x3D; DecodeHDR(SampleTexture2DBicubic(TEXTURE2D_X_ARGS(_SourceTexLowMip, sampler_LinearClamp), uv, _SourceTexLowMip_TexelSize.zwxy, (1.0).xx, unity_StereoEyeIndex));    #else    half4 lowMip &#x3D; DecodeHDR(SAMPLE_TEXTURE2D_X(_SourceTexLowMip, sampler_LinearClamp, uv));    #endif    return lerp(highMip, lowMip, Scatter);&#125;half4 FragUpsample(Varyings input) : SV_Target&#123;    UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);    half4 color &#x3D; Upsample(UnityStereoTransformScreenSpaceTex(input.texcoord));    return EncodeHDR(color);&#125;</code></pre></div></figure></p><p>这样就得到了保留透明通道的Bloom贴图。<br /><img src="bloomWithAlpha.png" alt="Bloom" /></p><h2 id="最终绘制">最终绘制</h2><p>最后在<code>UberPost</code>中把Bloom的结果和HDR的结果合并。</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">half4 bloom &#x3D; SAMPLE_TEXTURE2D_X(_Bloom_Texture, sampler_LinearClamp, SCREEN_COORD_REMOVE_SCALEBIAS(uvBloom));alpha &#x3D;  alpha +  bloom.w  * _Bloom_Alpha;</code></pre></div></figure><h2 id="透明度混合问题">透明度混合问题</h2><p>这里有个问题，一般的bloom是加到Color上，但这里要考虑透明通道，最终和MR相机的图层进行混合时，是用透明通道来混合的。<br />这导致含有透明度的bloom颜色再叠加透明度会变淡。所以这里再传一个参数进去，适当提高透明度。</p><p>但不能加太多，否则周围没有bloom颜色的地方（默认黑色），就会被多出来的透明度混合成黑色。<br />这里只能寄希望于Meta或者Pico给出MR透视的贴图，当作天空盒提前渲染到相机的buffer上才能解决这个问题。<br />但如果这样做，又会导致MR相机的贴图被二次采样，势必会降低渲染质量。（目前meta和pico都给出了对应的SDK来获取相机图像，但都有一些限制）</p><p>或者利用现有硬件的合成层功能，把这张bloom贴图提出来，单独给到头显，让头显来用颜色叠加模式来混合。<br />但目前pico或meta合成层仅仅支持常见的Quad、Cylinder、Equirect等几种模式，无法直接传入贴图应用到头显上。</p><h1 id="便于在编辑器调试的mr背景图">便于在编辑器调试的MR背景图</h1><p>在编辑器中，MR背景图是黑色的，这样在调试时就看不到背景了，也就无法确认Bloom经过透明度混合后的效果。</p><p>所以在<code>UberPost</code>中加入一张背景图，模仿alpha混合的效果。</p><p>这样就可以在编辑器中看到背景了。</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">#ifdef BG_TEXTUREfloat4 bg &#x3D; SAMPLE_TEXTURE2D_X(_BG_Texture, sampler_PointClamp, input.texcoord);alpha &#x3D; clamp(alpha, 0, 1);color &#x3D; color * alpha + bg * (1 - alpha);return half4(color, 1);#endif</code></pre></div></figure><figure><img src="bg.png" alt="BG" /><figcaption aria-hidden="true">BG</figcaption></figure><h1 id="结语">结语</h1><p>到这里，HDR Bloom在MR环墋下就可以正常工作了。<br />但凡事都有代价，这里的代价就是显存带宽的增加，要根据实际情况来决定是否使用。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>基于TMP与VEG的实时文字粒子消融效果</title>
    <link href="/2025/03/18/TMP-VEG/"/>
    <url>/2025/03/18/TMP-VEG/</url>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>产品现有一需求，要运行时更改文字且添加消融与粒子消散。<br />虽然不算很复杂，还是记录一下。</p><p>想了下从TMP文字的SDF图来着手应该是比较不错的方案。</p><h1 id="tmp消融shader">TMP消融Shader</h1><p>这里先看下TMP的原始shader，就是采样SDF图，再根据是否要轮廓、阴影等效果加上对应的代码。<br />那就很简单了，采样个噪声图，根据时间clip一下，再取个宽度，step后给个颜色就完事了。<br />这就简单贴一下</p><figure><div class="code-wrapper"><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl">float noise &#x3D; tex2D(_NoiseTex, input.atlas *  100).a;float w &#x3D; noise - _BleedCompensation;clip(w);float isEdge &#x3D; step(w - _Width, 0);         ......                    faceColor +&#x3D; isEdge * _OutlineColor;faceColor.a &#x3D; saturate(faceColor.a);</code></pre></div></figure><p>一开始忘了去限制alpha，导致溢出</p><figure><img src="TMP文字消融.gif" alt="TMP文字消融" /><figcaption aria-hidden="true">TMP文字消融</figcaption></figure><h1 id="粒子">粒子</h1><p>粒子用的是VEG，大体思路是</p><ul><li>用脚本把TMP的mesh和字体SDF贴图传进去</li><li>用表面模式去随机采样，拿到位置和UV以及颜色。</li><li>UV就可以直接采样SDF了，然后小于指定参数的粒子就消灭掉</li></ul><p>到这里粒子就是生成在文字上的了。</p><p><img src="粒子.png" /></p><p>然后是消融</p><ul><li>传入同样一张噪声图，一样的参数去把边缘取出来。非边缘部分的粒子同样就直接消灭</li><li>然后放出来一些参数去配置大小和颜色。</li><li>最后随便给个Turbulence和速度就完活了</li></ul><p><img src="SG.png" /></p><p>要根据当前文字数量可以动态调整要生成的粒子数量，避免浪费。</p><p>最后用Timeline去统一配置下动画就完工。</p><p><img src="TMP文字粒子.gif" /></p><h1 id="vfxbinderbase">VFXBinderBase</h1><p>为了以后方便使用，参照VFXBinderBase的写法，写个VFXTMPBinder来自动绑定TMP的Mesh</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using TMPro;using UnityEngine;using UnityEngine.VFX;using UnityEngine.VFX.Utility;namespace DefaultNamespace&#123;    [VFXBinder(&quot;GameObject&#x2F;TextMeshPro&quot;)]    public class VFXTMPBinder : VFXBinderBase    &#123;                public TextMeshPro Target;                public string Property &#123; get &#123; return (string)m_Property; &#125; set &#123; m_Property &#x3D; value; &#125; &#125;                 [VFXPropertyBinding( &quot;UnityEngine.Mesh&quot;) ,SerializeField]        protected ExposedProperty m_Property &#x3D; &quot;mesh&quot;;                        public override bool IsValid(VisualEffect component)        &#123;            return Target !&#x3D; null &amp;&amp; component.HasMesh(m_Property);        &#125;        public override void UpdateBinding(VisualEffect component)        &#123;            component.SetMesh(m_Property, Target.mesh);        &#125;                        public override string ToString()        &#123;            return string.Format(&quot;Mesh : &#39;&#123;0&#125;&#39; -&gt; &#123;1&#125;&quot;, m_Property, Target &#x3D;&#x3D; null ? &quot;(null)&quot; : Target.name);        &#125;    &#125;&#125;</code></pre></div></figure><h1 id="优化">优化</h1><p>这里有个小问题就是比较小的字的网格也比较小，但随机取样没有考虑这一点，所以导致每个字上的粒子数量密度不均匀。</p><p>解决的办法就是去改TMP源码，写网格的时候比如在UV里在加上当前网格的大小，然后粒子采样时用这个参数去过滤掉多出来的粒子就可以了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Shader中深度相关坐标的转换</title>
    <link href="/2023/08/14/depth/"/>
    <url>/2023/08/14/depth/</url>
    
    <content type="html"><![CDATA[<p>简要记录一下shader中几种Depth的定义与转换规则，同时再记录下容易混淆的裁切空间，NDC，屏幕空间。</p><h1 id="视角空间">视角空间</h1><p>那就一个一个看，先看UNITY_MATRIX_V，从世界坐标到视角坐标。<br />这个矩阵和之前类似，视角坐标系是右手，所以Z轴要翻转（UNITY_MATRIX_V这个矩阵就已经包含翻转了）。也就是Z轴朝向屏幕外。<br />这里的posVS.z表示的是物体距离摄像机在摄像机forward反方向的距离。所以如果要用记得取负。记得这里和裁切平面没有什么关系。</p><h1 id="裁切空间">裁切空间</h1><p>这里指在顶点着色器中输出的有<code>SV_POSITION</code>语义的裁切坐标。<br />一般直接由<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float4 TransformObjectToHClip(float3 positionOS)&#123;    &#x2F;&#x2F; More efficient than computing M*VP matrix product    return mul(GetWorldToHClipMatrix(), mul(GetObjectToWorldMatrix(), float4(positionOS, 1.0)));&#125;</code></pre></div></figure><br />这一函数直接得出。<br />后面的ObjectToWorldMatrix不用多说，看看前面的矩阵就是UNITY_MATRIX_VP。<br />来看看UNITY_MATRIX_P。即从视角空间至裁切空间的投影矩阵。<br />具体的推导就不写了，就记录一下结果的各个含义。<br />首先posCS.w = -posVS.z。<br />posCS.xyz 在未进行透视除法之前意义不大。</p><p>但是这里在DX和GL上就有区别了。</p><p>DX的Y轴是指向下方的，而GL的Y轴是指向上方的。<br />造成这一差异的原因是Untiy在DX环境中修改了投影矩阵，翻转了Y轴。</p><p>而且DX的Z轴，近平面为0，但Gl的Z轴近平面为-1</p><h3 id="y轴翻转">Y轴翻转</h3><p>这是因为Untiy默认遵循OpenGL的约定，UV的原点（0，0）在左下角。<br />但是DX默认为左上角。所以unity在DX环境中时，将贴图传至GPU时，会翻转贴图（可以用RenderDOC来验证）。</p><p>这里摘自<ahref="https://zhuanlan.zhihu.com/p/438828654">Unity坐标系变换那些事</a><br />任何引擎或者API的世界坐标都是Y轴朝上，但屏幕空间都是Y轴朝下的。所以一定历奇数次的翻转。<br />DX选择在视口变换时翻转。<br />GL则是在最后让操作系统去翻转。</p><p>首先 untiy的世界空间，视角空间，屏幕空间以及NDC全都是Y轴朝上的。</p><p>所以untiy为了统一，当环境为DX时，在投影矩阵上偷偷翻转y轴（通过RenderDoc看他的投影矩阵和用C#代码看的不一样）。<br />这样DX视口变换又翻转了一次，相当于没有翻转，所以让DX和GL保持了一致。而没有被翻转即意味着在RenderDoc中看到的就是倒立的图像。<br />最终Untiy会在写到Buffer中时翻转一次。<br />而如果是GL，因为GL会在最终让操作系统翻转一次，所以unity就无需再次翻转了。</p><h1 id="ndc坐标">NDC坐标</h1><p>可以手动做透视除法来将裁切空间坐标变成NDC。<br />做完透视除法后，w分量为1就没有存储的意义了。</p><p>所以NDC.xy = posCS.xy/posCS.w范围即（-1，1），相当于屏幕UV了。<br />在GL中，左下角为（-1，-1）右上角为（1，1）<br />如果单纯的让DX也这样做<br />那在DX中，左上角为（-1，-1）右下角（1，1），为了兼容，这里也要Y轴翻转。<br />所以NDC.y = - posCS.y/posCS.w<br />但这仅仅在我们手动计算时才需要。</p><p>而NDC.z =posCS.z/posCS.w即深度了，近平面1，远平面0。这里untiy自动做了深度翻转（通过修改UNITY_MATRIX_P矩阵）。为了提升远处的精度。<br />如果是Opengl，这里就是近平面的-1到远平面的1。</p><h1 id="屏幕空间">屏幕空间</h1><p>当参数传递至片元着色器时，这个语义的值是经历了透视除法和视口变换的。这里是由GPU完成的。<br />这时的posHCS.xy表示屏幕空间，范围是从左下角的（0，0），到右上角的_ScreenParams.xy。<br />如果要用作UV，uv = input.positionHCS.xy /_ScreenParams.xy;这样就映射回了（0-1）</p><p>posHCS.z则是从posCS.z映射到（0，1）。<br />如果是DX，则完全等同，如果是gl则要从（-1，1）映射到（0，1）</p><p>这也是最终写入深度图的值。如果直接采样深度图，得到的也是这个值。</p><p>因为NDC.w =1没有存储的意义，所以posHCS.w与posCS.w一样，都是等于-posVS.z，表示物体距离摄像机在摄像机forward方向的距离</p><h1 id="rawdepth">RawDepth</h1><p>上面得到的值即原始深度，仅能用来比较大小，应该没什么物理含义。</p><h1 id="linear01depth">Linear01Depth</h1><p>0表示相机位置，1表示远平面。这里的深度就是线性的了，有实际物理意义了。<br />一般用<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float Linear01Depth(float depth, float4 zBufferParam)&#123;    return 1.0 &#x2F; (zBufferParam.x * depth + zBufferParam.y);&#125;</code></pre></div></figure><br />来取，简单乘以远平面，或者直接<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">&#x2F;&#x2F; zBufferParam &#x3D; &#123; (f-n)&#x2F;n, 1, (f-n)&#x2F;n*f, 1&#x2F;f &#125;float LinearEyeDepth(float depth, float4 zBufferParam)&#123;    return 1.0 &#x2F; (zBufferParam.z * depth + zBufferParam.w);&#125;</code></pre></div></figure><br />就能得到实际物体的在Z轴上的深度了。即posVS.z。</p><h1 id="重建坐标">重建坐标</h1><p>在很多全屏后处理中，依据深度图来重建坐标也是经常要用的。<br />首先是得到UV，即左下角（0，0）右上角（1，1）的坐标。<br />即 float2 UV = IN.positionHCS.xy / _ScaledScreenParams.xy;</p><h2 id="重建裁切坐标">重建裁切坐标</h2><p>这里的裁切坐标是进行透视除法之后的坐标<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">    float4 positionCS &#x3D; float4(positionNDC * 2.0 - 1.0, deviceDepth, 1.0);#if UNITY_UV_STARTS_AT_TOP    positionCS.y &#x3D; -positionCS.y;#endif</code></pre></div></figure></p><h2 id="取消透视除法">取消透视除法</h2><p>取消的第一步就是要计算posCS.w，即-posVS.z。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">float ZVS &#x3D; LinearEyeDepth(rawDepth, _ZBufferParams);float4 posCS &#x3D; ZVS * posHCS;</code></pre></div></figure></p><h2 id="重建视角坐标">重建视角坐标</h2><p>用逆矩阵相乘即可。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float4 positionVS &#x3D; mul(invProjMatrix, posCS);</code></pre></div></figure><br />这里Untiy的ComputeViewSpacePosition函数会主动再把Z轴取反，不知道出于什么考虑。<br />再往下的由视角坐标再重建世界坐标就不赘述了。<br />但这种一步一步慢慢倒推是没必要的，untiy的Common库中有效率更高的做法，这里有一个齐次世界坐标我是没搞明白，但最终的结果是一样的。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float3 ComputeWorldSpacePosition(float2 positionNDC, float deviceDepth, float4x4 invViewProjMatrix)&#123;    float4 positionCS  &#x3D; ComputeClipSpacePosition(positionNDC, deviceDepth);    float4 hpositionWS &#x3D; mul(invViewProjMatrix, positionCS);    return hpositionWS.xyz &#x2F; hpositionWS.w;&#125;</code></pre></div></figure></p><h2 id="深度偏移">深度偏移</h2><p>对于那些需要深度偏移的shader。最后输出的深度要转换成原始深度。<br />最简单的方式就是<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float deviceDepth &#x3D; ComputeNormalizedDeviceCoordinatesWithZ(currentPos, GetWorldToHClipMatrix()).z;#ifndef  UNITY_UV_STARTS_AT_TOPdeviceDepth &#x3D; (deviceDepth +1 )&#x2F;2;#endifoutDepth &#x3D; deviceDepth;</code></pre></div></figure></p><h1 id="总结">总结</h1><p>untiy为了统一两种API，整了一堆绕来绕去的骚操作，还全部隐藏起来不开源。<br />自带的FrameDebug还为不同的API自动翻转了图像，不用RenderDoc根本不知道到底图像是怎么翻转的。<br />总之就踩到坑再回来补充吧。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GTAO</title>
    <link href="/2023/08/09/GTAO/"/>
    <url>/2023/08/09/GTAO/</url>
    
    <content type="html"><![CDATA[<p>既然HBAO实现了，那就再进一步，看看GTAO到底有多GT。<br />主要参考了原始论文与作者发布的PPT，以及Github上一开源的<ahref="https://github.com/GameTechDev/XeGTAO">GameTechDev/XeGTAO</a>，外加HDRP自带的GTAO的实现。<br /><img src="GTAO01.png" alt="GTAO in URP" /></p><p>先大致翻译一下原始论文吧</p><h1 id="摘要">摘要</h1><p>环境光遮蔽是游戏和其他实时应用中用来近似全局光照效果的一种普遍方法。然而，对于任意场景的环境光遮蔽积分并不存在解析解，使用一般的数值积分算法太慢，因此实际中常常对这种近似进行经验性的调整，以使其在外观上看起来令人满意，即使它们并没有准确地计算环境光遮蔽积分。在这项工作中，我们引入了一种新的环境光遮蔽表达方式，即GTAO，在当前主机硬件上能够在半毫秒内匹配基准真实值。这是通过使用环境光遮蔽方程的另一种表达方式以及一种有效的实现来实现的，该实现使用时空滤波来分布计算。然后，我们通过一种新颖的技术扩展了GTAO，该技术考虑了近场全局光照，而在仅使用环境光遮蔽时会丢失这种效果。最后，我们引入了一种用于镜面遮蔽的技术，即GTSO，与环境光遮蔽相称，允许从基于探针的光照中计算逼真的镜面反射。我们的技术高效，结果接近光线追踪的基准真实值，并已集成到最近的AAA主机游戏中。</p><h1 id="介绍">1 介绍</h1><p>全局光照是一项重要的视觉特性，在逼真渲染中具有决定性作用，因为感知场景照明的很大一部分来自间接反射。然而，通常情况下，计算全局光照非常昂贵，目前无法包含在实时应用中，除非进行严重的简化。</p><p>在这些近似模拟中，<em>环境光遮蔽（AO）</em>是最受欢迎的近似模拟之一，因为它改善了对物体形状（对比度）的感知，并捕捉了全局光照中一些最重要的效果，特别是由于附近遮挡物引起的软阴影效果。环境光遮蔽还可以与其他全局光照算法一起使用，甚至在使用预计算（烘焙）辐照度时也很有用，因为这些效果通常需要以相对较低的空间分辨率计算（或存储），因此逐像素计算环境光遮蔽可以增强间接照明的整体外观。不幸的是，在某些情况下（例如在1080p分辨率下以60帧每秒渲染），计算环境光遮蔽积分仍然很昂贵，因此过去已经开发了近似方法以实现足够快的性能。</p><p>我们引入了一种名为<em>基准真实环境光遮蔽（GTAO）</em>的新型屏幕空间技术，旨在在速度足够快的情况下匹配真实环境光遮蔽，并适用于高要求的应用，例如现代主机游戏。我们的技术基于<code>基于地平线(horizon-based)</code>的方法，但使用问题的另一种表达方式。这种表达方式使我们能够显著降低效果的成本，并且在假设我们的场景被表示为高度场（深度缓冲）的情况下，仍然可以用来精确解决环境光遮蔽积分问题。我们通过使用时序投影和空间滤波来高效地实现我们的技术，每帧仅需0.5毫秒即可计算出无噪声的环境光遮蔽解决方案（在索尼Playstation4上，适用于以1080p分辨率运行的游戏）。</p><p>基于这种表达方式，我们扩展了我们的环境光遮蔽解决方案，以模拟在仅使用环境光遮蔽时通常被忽视的一组照明效果。一方面，我们引入了一种近似技术，可以计算出一个非常快速的校正因子，以考虑近场全局光照效果。这种技术基于以下观察结果：局部表面反照率与环境光遮蔽项之间存在关系，以及多次反射的近场照明。根据这个观察结果，我们开发了一种高效、简单和局部的技术，以考虑在仅计算环境光遮蔽时丢失的局部照明效果。</p><p>最后，我们介绍一种新的技术，与环境光遮蔽对称，但适用于任意镜面材料，我们称之为<em>基准真实镜面遮蔽”（GTSO）</em>。我们开发了它的表达形式，并提出了一种基于近似的技术来计算它，该技术将可见性近似为弯曲法线和点处环境光遮蔽的函数。GTSO能够有效地计算基于探针的光照下的镜面反射，同时考虑了表面的遮蔽情况。</p><div class="note note-info">            <p>即分成三个部分</p><ul><li>GTAO 用来做环境光遮蔽</li><li>近场全局光照</li><li>GTSO镜面反射遮蔽，减少反射漏光。有点类似与HDRP使用BentNormal来减少漏光，这里直接从深度法线中生成全局的BentNormal</li></ul>          </div><h1 id="背景与相关工作">2 背景与相关工作</h1><p>从一个有着法线<spanclass="math inline"><em>n</em><sub><em>x</em></sub></span>的点<spanclass="math inline"><em>x</em></span>沿朝向方向<spanclass="math inline"><em>ω</em><sub><em>o</em></sub></span>反射的辐射<spanclass="math inline"><em>L</em><sub><em>r</em></sub>(<em>x</em>,<em>ω</em><sub><em>o</em></sub>)</span>可以建模为：</p><p><span class="math display">$$\begin{equation}\begin{aligned}L_r(x, \omega_o) = \int_{\mathcal{H} ^2} L_i(x, \omega_i) f_r(x,\omega_i, \omega_o) \langle n_x, \omega_i \rangle ^+ d\omega_i\end{aligned} \tag{1}\end{equation}$$</span></p><p>其中<span class="math inline">ℋ<sup>2</sup></span>是以<spanclass="math inline"><em>x</em></span>为中心，<spanclass="math inline"><em>n</em><sub><em>x</em></sub></span>为其轴的半球体，<spanclass="math inline"><em>L</em><sub><em>i</em></sub>(<em>x</em>,<em>ω</em><sub><em>i</em></sub>)</span>是从方向<spanclass="math inline"><em>ω</em><sub><em>i</em></sub></span>到<spanclass="math inline"><em>x</em></span>的入射辐照度，<spanclass="math inline"><em>f</em><sub><em>r</em></sub>(<em>x</em>,<em>ω</em><sub><em>i</em></sub>,<em>ω</em><sub><em>o</em></sub>)</span>是<spanclass="math inline"><em>x</em></span>处的双向反射分布函数（BRDF），<spanclass="math inline">〈<em>n</em><em>x</em>, <em>ω</em><em>i</em>〉<sup>+</sup></span>是一个递归运算符，依赖于整个场景中的反射（和发射）辐射。虽然许多研究都集中在解决这个问题上，但在像游戏等高要求的场景中，它仍然过于昂贵。在这里，我们关注<em>环境光遮蔽</em>技术，并参考Ritschel等人的调查报告[RDGK12]中关于该领域的更广泛的概述。</p><p>环境光遮蔽[ZIK98]通过引入一系列假设来近似方程(1)：</p><ul><li>所有光来自于一个无限均匀的环境光源，可能会被<spanclass="math inline"><em>x</em></span>周围的几何物体遮蔽</li><li><spanclass="math inline"><em>x</em></span>周围的所有表面都是纯吸收的（即不反射任何光）</li><li><spanclass="math inline"><em>x</em></span>处的表面是漫反射的。这将方程(1)转化为：</li></ul><p><span class="math display">$$\begin{equation}\begin{aligned}L_r(x, \omega_o) &amp;= L_i\frac{ \rho(x)}{\pi} \int_{\mathcal{H}^2}V(x, \omega_i) \langle n_x, \omega_i \rangle ^+ d\omega_i \\&amp;=L_i \frac{ \rho(x)}{\pi} \mathcal{A}(x)\end{aligned} \tag{2}\end{equation}$$</span></p><p>其中 <span class="math inline">𝒜(<em>x</em>)</span> 表示点 <spanclass="math inline"><em>x</em></span> 处的环境遮蔽项，<spanclass="math inline">$\frac{ρ(x)}π$</span> 为反射率为 <spanclass="math inline"><em>ρ</em>(<em>x</em>)</span>的漫反射双向反射分布函数（BRDF），而 <spanclass="math inline"><em>V</em>(<em>x</em>,<em>ω</em><sub><em>i</em></sub>)</span>是点 <span class="math inline"><em>x</em></span> 处在方向 <spanclass="math inline"><em>ω</em><sub><em>i</em></sub></span>上的可见性项，如果在方向 <spanclass="math inline"><em>ω</em><sub><em>i</em></sub></span>上存在比给定距离 <span class="math inline"><em>r</em></span>更近的遮挡物，则返回 <span class="math inline">0</span>，否则返回 <spanclass="math inline">1</span>。</p><p>请注意，之前的研究[ZIK98，Mit07，BSD08]将可见性项 <spanclass="math inline"><em>V</em>(<em>x</em>,<em>ω</em><sub><em>i</em></sub>)</span>建模为相对于遮挡物距离的衰减函数，将 <spanclass="math inline">𝒜(<em>x</em>)</span>称为<em>遮蔽度</em>。这种衰减函数是一个临时解决方案，以避免忽略近场互反射产生的典型环境光遮蔽过度变暗的问题；</p><p>与之相反，我们引入了一种新的公式来添加这部分丢失的光线（第5节），同时保持辐射度上正确的环境遮蔽项。<br /><div class="note note-info">            <p>那看这意思还需要引入近场全局照明才能补充这部分？</p>          </div><br />值得注意的是，还有一种环境遮蔽的替代定义，其中忽略了视角变形：尽管在本文的其余部分中，我们遵循辐射度正确的余弦加权公式，但在附录A 中，我们描述了我们在这种替代形式下的技术。</p><h2 id="ssao">SSAO</h2><p>环境遮蔽项 <span class="math inline">𝒜(<em>x</em>)</span>受到场景中所有几何体的影响，通常通过射线追踪来计算[ZIK98]，尽管也存在适用于交互式渲染的基于点的方法[Bun05，REG+09]。然而，这对于实时应用来说仍然过于昂贵。为了避免昂贵的三维全场景可见性计算，Mittring[Mit07]提出将所有计算移动到屏幕空间，假设只有相机可见的几何体才起到遮挡物的作用。这是通过在点<span class="math inline"><em>x</em></span> 周围的球形区域内采样场景的GPU深度图，并评估点在深度图中是否被遮蔽（在后面）。从那以后，对屏幕空间采样方法进行了几次改进，改进了采样策略[LS10，SKUT+10，HSEE15]并通过滤波来减少噪声[MML12]。</p><h2 id="hbao">HBAO</h2><p>Bavoil 等人在文献 [BSD08]中提出，根据光线可以到达的最大地平线角来计算非遮蔽区域。他们将积分域转化为一组由表面切线<spanclass="math inline"><em>ϕ</em></span>参数化的方向，然后在每个方向上计算总的非遮蔽立体角，将方程（2）转化为：<br /><span class="math display">$$\mathcal{A}(x) \approx \hat{A}(x) = \frac{1}{\pi} \int_{0}^{\pi}\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}} V(\phi, \theta) \left|\sin(\theta) \right| d\theta d\phi \tag{3}$$</span><br />在这里，<span class="math inline">1/<em>π</em></span> 项用于归一化至<span class="math inline">1</span>（即 <spanclass="math inline">𝒜(<em>x</em>) ∈ [0,1]</span>）。请注意，在这里我们区分实际的环境遮蔽<span class="math inline">𝒜(<em>x</em>)</span> 和近似的屏幕空间项 <spanclass="math inline"><em>Â</em>(<em>x</em>)</span>。</p><p>Alchemy Ambient Obscurance [MOBH11, MML12]后来改进了屏幕空间方法的鲁棒性，并增加了所使用的采样过程的效率。虽然HBAO的效率相对较高，但仍然昂贵，因为在查找最大地平线时，需要针对每个像素从深度图中收集许多样本。Timonen[Tim13a]通过在整个图像上执行线性扫描来改进这一点，从而使他能够通过将采样分摊到图像中的多个像素上，在常数时间内找到给定方向的最大地平线角。与我们的工作相似，同一作者[Tim13b]提出了一种新的环境遮蔽估计方法，通过线性扫描和过滤深度图，能够以很小的代价匹配真实解，从而可以计算非常大的聚集半径下的环境遮蔽，覆盖整个屏幕。</p><p>我们的工作通过提出一种高效的环境遮蔽公式来改进这些工作，无需临时的衰减函数，通过允许非常高效的分析积分来节省计算时间。避免使用临时衰减函数的关键是我们对于包括近场遮蔽体的间接照明的高效近似。此外，所有这些工作都假设是漫反射表面：相反，我们将环境遮蔽的概念推广到非兰伯特表面，引入了一种处理镜面遮蔽的技术。</p><h1 id="总览">3 总览</h1><p>在这项工作中，我们有两个主要目标：</p><p>一方面，我们的目标是拥有一种能够与真实结果匹配的环境遮蔽技术，同时又足够高效，可以在要求严格的实时应用中使用。</p><p>另一方面，我们希望扩展可以被有效近似的全局光照效果的范围。</p><p>第一个目标在输入数据、通道数量和指令数量方面施加了严格限制。受到这些限制，我们开发了一种在屏幕空间中工作的技术，仅以深度缓冲和表面法线作为输入（这些法线可以通过微分从深度缓冲中导出，或者可以单独提供），并且可以与其他全局光照源（特别是烘焙的辐照度）共存并增强。</p><p>为了实现第二个目标，我们放松了传统环境遮蔽的一些假设。特别地，虽然我们保持白色（或单色）圆顶照明的假设，但我们放宽了纯朗伯表面的假设，包括了近场遮蔽体的漫反射互反射效应。</p><p>消除先前的限制，我们可以将方程（2）转换为<br /><span class="math display">$$L_r (x, \omega_o) = (1 - F (\omega_o)) L_i \frac{ \rho(x)} { \pi}\mathcal{G}(\mathcal{A}(x)) + F(\omega_o) \mathcal{L}(x, \omega_o)\mathcal{S}(x), \tag{4}$$</span></p><p>其中，<span class="math inline"><em>F</em></span>表示菲涅尔反射项，<span class="math inline">𝒜(<em>x</em>)</span>是我们的环境光遮蔽项（第4节），它与基准真实结果相匹配，我们称之为基准真实环境光遮蔽（GTAO）。<spanclass="math inline">𝒢(<em>x</em>)</span>是一个函数，基于环境光遮蔽项，引入了漫反射近场间接光照（第5节），而<span class="math inline">𝒮(<em>x</em>)</span>则是镜面遮蔽项（第6节），它与预卷积的 <strong>BRDF</strong> <spanclass="math inline">ℒ</span>相乘。接下来，我们将对这些项逐一进行阐述。</p><h1 id="gtao">4 GTAO</h1><p>我们对环境光遮蔽的构建遵循了 Bavoil 等人的基于地平线的方法[BSD08]，但是我们做出了一些关键的差异，使得在不牺牲质量的前提下能够进行高效的计算。</p><p>首先，我们重新构建了地平线计算所依据的参考坐标系，从而重新定义了积分域：我们遵循Timonen [Tim13a] 的方法，相对于视角向量 <spanclass="math inline"><em>ω</em><sub><em>o</em></sub></span>计算地平线角（见图2）。这意味着地平线在围绕点 <spanclass="math inline"><em>x</em></span>的整个球面范围内进行搜索，并且球面积分轴被设置为 <spanclass="math inline"><em>ω</em><sub><em>o</em></sub></span>。实际上，这使我们能够简化表述，正如我们稍后将看到的，还可以减少所需的超越函数数量。</p><p>第二个主要的差异是，与 Bavoil 的工作不同，我们的可见性项 <spanclass="math inline"><em>V</em>(<em>ϕ</em>,<em>θ</em>)</span>仅是一个二元函数，而不是关于遮蔽距离的连续衰减函数（环境光遮蔽）。以这种方式构建环境光遮蔽允许我们将方程（3）的内部积分简单地计算为方向<span class="math inline"><em>ϕ</em></span> 的两个最大地平线角度 <spanclass="math inline"><em>θ</em>1(<em>ϕ</em>)</span> 和 <spanclass="math inline"><em>θ</em>2(<em>ϕ</em>)</span>之间弧线的积分。在围绕 <spanclass="math inline"><em>ω</em><sub><em>o</em></sub></span>进行积分，并使用二元可见性项，将方程（3）转化为：</p><p><span class="math display">$$\mathcal{A}(x) = \frac{1}{\pi} \int_{0}^{\pi}\underbrace{\int_{\theta_1(\phi)}^{\theta_2(\phi)} \cos(\theta - \gamma)^+ \lvert \sin(\theta) \rvert d\theta }_{a} d\phi \tag{5}$$</span></p><p>其中，<span class="math inline"><em>γ</em></span> 是法线 <spanclass="math inline"><em>n</em><sub><em>x</em></sub></span> 和视角向量<span class="math inline"><em>ω</em><sub><em>o</em></sub></span>之间的角度，而 <spanclass="math inline"><em>c</em><em>o</em><em>s</em>(<em>θ</em>)<sup>+</sup> = max (cos(<em>θ</em>),0)</span>。事实上，这个公式的构造非常重要，因为它允许解析地计算内部积分<spanclass="math inline"><em>â</em></span>，同时与基准真实环境光遮蔽匹配。这意味着只需要通过随机的<span class="math inline"><em>ϕ</em></span>进行蒙特卡洛积分，来数值地计算最外层的积分。在接下来的部分，我们将详细说明如何计算地平线角和内部积分<span class="math inline"><em>â</em></span>。</p><h2 id="计算最大地平线角度">计算最大地平线角度</h2><p>在解方程（5）中，关键是要找到图像平面上由旋转角度 <spanclass="math inline"><em>ϕ</em></span> 参数化的方向 <spanclass="math inline"><em>t̂</em>(<em>ϕ</em>)</span> 的最大地平线角度 <spanclass="math inline"><em>θ</em><sub>1</sub>(<em>ϕ</em>)</span> 和 <spanclass="math inline"><em>θ</em><sub>2</sub>(<em>ϕ</em>)</span>。为了做到这一点，我们在像素<spanclass="math inline"><em>x̂</em></span>（点 <spanclass="math inline"><em>x</em></span> 的投影像素）的 <spanclass="math inline"><em>n</em> × <em>n</em></span>邻域中，分别在屏幕空间方向 <spanclass="math inline"><em>t̂</em>(<em>ϕ</em>)</span> 和 <spanclass="math inline"> − <em>t̂</em>(<em>ϕ</em>)</span>上进行搜索，以获取每个角度，并相对于视角向量 <spanclass="math inline"><em>ω</em><sub><em>o</em></sub></span>获得最大地平线角度，如下所示：<br /><span class="math display">$$\begin{equation}\begin{aligned}\theta_1(\phi) = \arccos\left( \max_{s&lt;n/2}  \left \langle  \omega_s,\omega_o \right \rangle  ^+ \right)\end{aligned} \tag{6}\end{equation}$$</span></p><p>其中，<span class="math inline">$ω_s = \frac{s - x}{\lVert s - x\rVert}$</span>，而 <span class="math inline"><em>s</em></span>是图像平面上像素的世界空间投影，定义为 <spanclass="math inline"><em>ŝ</em> = <em>x̂</em> + <em>t̂</em>(<em>ϕ</em>) ⋅ <em>s</em></span>。角度<span class="math inline"><em>θ</em><sub>2</sub></span>的计算类似，只是使用 <spanclass="math inline"><em>ŝ</em> = <em>x̂</em> − <em>t̂</em>(<em>ϕ</em>) ⋅ <em>s</em></span>。请注意，邻域<span class="math inline"><em>n</em></span>的大小根据相机距离进行缩放：这是为了使 <spanclass="math inline"><em>Â</em>(<em>x</em>)</span>与视角无关，并且将其限制为像素的最大半径，以避免在靠近近裁剪平面的非常近的物体上产生过大的聚集半径，这会不必要地破坏GPU 缓存。</p><p>鉴于我们只关心辐射度立体角，我们只需要跟踪最大角度，而不需要像以前的工作中那样跟踪其他量（例如最大距离）。这允许在AMD GCN 硬件[AMD12]（我们的目标平台）上只使用一个四分之一速度指令（rsqrt）来计算搜索循环。使用这个公式，着色器完全受内存限制。</p><h2 id="计算内部积分">计算内部积分</h2><p>Timonen [Tim13a]通过在运行时访问预计算结果的查找表来计算这个积分（包括衰减函数）。然而，我们公式的一个关键特性是，在给定我们计算的地平线角度<span class="math inline"><em>θ</em><sub>1</sub></span> 和 <spanclass="math inline"><em>θ</em><sub>2</sub></span>的情况下，我们可以解析地求解方程（5）中的内部积分 <spanclass="math inline"><em>â</em></span>，如下所示：</p><p><span class="math display">$$\begin{equation}\begin{aligned}a &amp;= \frac{1}{4} \left( -\cos(2\theta_1 - \gamma) + \cos(\gamma) +2\theta_1 \sin(\gamma) \right) \\  &amp;+ \frac{1}{4} \left( -\cos(2\theta_2 - \gamma) + \cos(\gamma) +2\theta_2 \sin(\gamma) \right)\end{aligned} \tag{7}\end{equation}$$</span></p><p>需要注意的是，这个公式要求法线 <spanclass="math inline"><em>n</em><sub><em>x</em></sub></span> 位于由 <spanclass="math inline"><em>t̂</em>(<em>ϕ</em>)</span> 和 <spanclass="math inline"><em>ω</em><sub><em>o</em></sub></span> 定义的平面<span class="math inline"><em>P</em></span>上，但通常不满足这个条件。按照 Timonen [Tim13a] 的方法，我们将角度 <spanclass="math inline"><em>γ</em></span> 定义为规范化投影法线 <spanclass="math inline">$\frac{\overrightarrow{n_x}}{||n_x||} \in P$</span>与 <span class="math inline"><em>ω</em><sub><em>o</em></sub></span>之间的角度，即 <span class="math inline">$γ = \arccos\left(\langle\frac{\overrightarrow{n_x}}{\lVert n_x \rVert}, \omega_o\rangle\right)$</span>。然后，我们通过法线 <spanclass="math inline"><em>n</em><sub><em>x</em></sub></span>的范数对点积进行修正，这使得方程（5）变成如下形式：</p><p><span class="math display">$$\hat{A}(x) = \frac{1}{\pi} \int_{0}^{\pi} \lVert \overrightarrow{n_x}\rVert \hat{a}(\phi) d\phi \tag{8}$$</span></p><p>我们发现我们的解析解非常快，特别是在使用快速的<code>acos</code>和<code>sqrt</code>指令[Dro14]的情况下。在超越函数方面，经过优化，我们的代码只包含2个<code>cos</code>和1个<code>sin</code>，再加上另外三个<code>acos</code>函数用于设置积分域。这使得我们的着色器在内存方面受限，所需的ALU操作在性能方面几乎没有什么差异。</p><h3 id="实现细节">4.1 实现细节</h3><p>我们的技术受内存限制，因此内存访问次数决定了目标平台的最终性能。鉴于我们的性能目标是将技术集成到以每秒60帧运行的游戏中，我们只有大约半毫秒的时间来进行计算，这使得实现优化变得必要。一方面，我们在半分辨率上计算环境光遮蔽，然后将其上采样到全分辨率。此外，为了在不损害性能的情况下计算尽可能多的样本，我们将遮蔽积分分布在空间和时间上：我们在每个像素中仅采样一个方向的地平线，但使用双边滤波器对4×4的邻域内的信息进行重建。此外，我们通过在6个不同的旋转之间交替，并使用指数累积缓冲重新投影结果，积极利用时间相干性。所有这些使每个像素有总共4 × 4 × 6 = 96个有效采样方向。图3展示了空间和时间聚集对最终重建的影响。</p><p>与环境光遮蔽技术不同，我们的表述中不考虑任何衰减函数，这可能导致计算出的遮蔽出现突然的不连续性，尤其是当我们的聚集半径未覆盖整个屏幕时。为了最小化伪影，我们采用了一种保守的衰减策略。思路是确保基准真实近场遮蔽，而对于远场遮蔽将其衰减为零，因为通常情况下，远场遮蔽与间接光照在我们的用例中是一起处理的。我们的衰减函数是从给定的足够大的距离开始，线性混合从1到0，直到最大的搜索半径。</p><p>最后，由于我们无法从深度缓冲区推断出物体的厚度，薄的特征往往会产生过多的遮蔽，从而不太真实。虽然可以通过深度剥离等方法来解决这个问题，但在我们的情况下不切实际。相反，我们引入了一种保守的启发式方法，该方法基于这样的假设：物体的厚度与其屏幕空间大小相似。这种启发式方法对地平线搜索（方程（6））进行了修改，因此对于搜索的每次迭代s ∈ [1, n/2]，我们更新地平线角 θ 如下：<br /><span class="math display">$$\theta = \begin{cases}\max(\theta_s, \theta) &amp; \text{if } \cos(\theta_s) \geq\cos(\theta_{s-1}) \\\text{blend}(\theta_{s-1}, \theta_s) &amp; \text{if } \cos(\theta_s)&lt; \cos(\theta_{s-1})\end{cases} \tag{9}$$</span></p><p>其中，<spanclass="math inline"><em>b</em><em>l</em><em>e</em><em>n</em><em>d</em></span>是基于指数移动平均的混合运算符，而 <spanclass="math inline"><em>θ</em><sub>0</sub> = 0</span>。这种启发式方法还具有不会对简单角落（例如墙壁）的遮蔽结果产生偏见的特性，而这在我们的应用中是常见的情况。图4展示了这个启发式方法的效果。</p><div class="note note-info">            <p>GTAO的部分到此为止了，再下面就是光照和GTSO的部分了，有精力再说吧。</p>          </div><h1 id="hdrp实现">HDRP实现</h1><p>然后再看看HDRP是怎么实现的</p><h1 id="gtao.compute">GTAO.compute</h1><p>用的是计算着色器<br />从最关键的GTAOMain函数入手</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float currDepth &#x3D; GetDepthForCentral(dispatchThreadId.xy);float3 positionVS &#x3D; GetPositionVS(dispatchThreadId.xy, currDepth);</code></pre></div></figure><p>取深度，重建计算视角空间坐标</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float4 normalBufferData &#x3D; LOAD_TEXTURE2D_X(_NormalBufferTexture, dispatchThreadId.xy);</code></pre></div></figure><p>取法线</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float offset &#x3D; GetOffset(dispatchThreadId.xy);float2 rayStart &#x3D; dispatchThreadId.xy;float integral &#x3D; 0;</code></pre></div></figure><p>偏移包含了空间偏移与时序偏移。<br />射线起点用的是屏幕空间。<br />integral是用来累加计算的。</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">#ifdef TEMPORAL    const int dirCount &#x3D; 1;#else    const int dirCount &#x3D; _AODirectionCount;#endif</code></pre></div></figure><p>依据是否启用时序来决定切面的数量。</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float3 V &#x3D; normalize(-positionVS);float fovCorrectedradiusSS &#x3D; clamp(_AORadius * _AOFOVCorrection * rcp(positionVS.z), _AOStepCount, _AOMaxRadiusInPixels);float step &#x3D; max(1, fovCorrectedradiusSS * _AOInvStepCountPlusOne);</code></pre></div></figure><p>因为是视线空间，取反即视线向量。<br />依据fov和位置远近，确定采样半径和步长。</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float2 dir &#x3D; GetDirection(dispatchThreadId.xy, i);float2 negDir &#x3D; -dir + 1e-30;&#x2F;&#x2F; Find horizonsfloat2 maxHorizons;maxHorizons.x &#x3D; HorizonLoop(positionVS, V, rayStart, dir, offset, step, 0);maxHorizons.y &#x3D; HorizonLoop(positionVS, V, rayStart, negDir, offset, step, 0);</code></pre></div></figure><p>然后就开始遍历方向。<br />确定方向，正反两个方向取找到最大水平角度。<br />这里的<code>GetDirection</code>和<code>HorizonLoop</code>之后再说。</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float3 normalVS &#x3D; GetNormalVS(normalBufferData);</code></pre></div></figure><p>取法线</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float3 sliceN &#x3D; normalize(cross(float3(dir.xy, 0.0f), V.xyz));float3 projN &#x3D; normalVS - sliceN * dot(normalVS, sliceN);float projNLen &#x3D; length(projN);float cosN &#x3D; dot(projN &#x2F; projNLen, V);</code></pre></div></figure><p>sliceN是切面的法线<br />projN表面法线在切面上的投影，简称投影法线<br />cosN即表面法线与视线的投影</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float3 T &#x3D; cross(V, sliceN);float N &#x3D; -sign(dot(projN, T)) * GTAOFastAcos(cosN);</code></pre></div></figure><p>T：表面的切线<br />N：投影法线与视线的角度</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">maxHorizons.x &#x3D; -GTAOFastAcos(maxHorizons.x);maxHorizons.y &#x3D; GTAOFastAcos(maxHorizons.y);</code></pre></div></figure><p>反三角，求出对应水平角度</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">maxHorizons.x &#x3D; N + max(maxHorizons.x - N, -HALF_PI);maxHorizons.y &#x3D; N + min(maxHorizons.y - N, HALF_PI);</code></pre></div></figure><p>限制一下范围</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">integral +&#x3D; AnyIsNaN(maxHorizons) ? 1 : IntegrateArcCosWeighted(maxHorizons.x, maxHorizons.y, N, cosN);</code></pre></div></figure><p>计算AO</p><p>然后来看看<code>HorizonLoop</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float HorizonLoop(float3 positionVS, float3 V, float2 rayStart, float2 rayDir, float rayOffset, float rayStep, int mipModifier)</code></pre></div></figure><ul><li>positionVS:起始点位置</li><li>V：视线</li><li>rayStart：步进起点，屏幕空间</li><li>rayDir：步进方向，屏幕空间</li><li>rayOffset：随机偏移，0-1</li><li>rayStep：每次步进长度</li><li>mipModifier：没有用到</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float maxHorizon &#x3D; -1.0f;  &#x2F;&#x2F; cos(pi)float t &#x3D; rayOffset * rayStep + rayStep;</code></pre></div></figure><p>最大水平角是用cos的形式记录的<br />t表示步进的长度，初始长度要偏移一个rayOffset</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float2 samplePos &#x3D; max(2, min(rayStart + t * rayDir, _AOBufferSize.xy - 2));</code></pre></div></figure><p>确保采样位置不超出屏幕</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float sampleDepth &#x3D; GetDepthSample(samplePos, i &gt; startWithLowerRes);float3 samplePosVS &#x3D; GetPositionVS(samplePos.xy, sampleDepth);</code></pre></div></figure><p>采样深度和计算视线空间坐标</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float3 deltaPos &#x3D; samplePosVS - positionVS;float deltaLenSq &#x3D; dot(deltaPos, deltaPos);float currHorizon &#x3D; dot(deltaPos, V) * rsqrt(deltaLenSq);maxHorizon &#x3D; UpdateHorizon(maxHorizon, currHorizon, deltaLenSq);</code></pre></div></figure><p>计算并更新最大水平角度</p><p>最后看看这个<code>UpdateHorizon</code><br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float UpdateHorizon(float maxH, float candidateH, float distSq)&#123;    float falloff &#x3D; saturate((1.0 - (distSq * _AOInvRadiusSq)));    return (candidateH &gt; maxH) ? lerp(maxH, candidateH, falloff) : lerp(maxH, candidateH, 0.03f);        &#x2F;&#x2F; TODO: Thickness heuristic here.&#125;</code></pre></div></figure><br />依据AO半径裁切，不是直接替换最大角度，而是Lerp，对应了论文中提及的blend操作。</p><h1 id="urp实现">URP实现</h1><p>其实从屏幕空间用深度重建视角空间坐标没必要用完整的<code>UNITY_MATRIX_I_P</code>矩阵的，像Untiy的做法都是传入矩阵的一部分，如下<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float3 GetPositionVS(float2 positionSS, float depth)&#123;    float linearDepth &#x3D; LinearEyeDepth(depth, _ZBufferParams);    return float3((positionSS * _AODepthToViewParams.xy - _AODepthToViewParams.zw) * linearDepth, linearDepth);&#125;</code></pre></div></figure><br />这里只是图方便，省的再传入一组参数了，先暂且记下，以后要是需要优化就回过头再改。<br />Shader都大同小异，没啥好说的了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HBAO</title>
    <link href="/2023/08/07/HBAO/"/>
    <url>/2023/08/07/HBAO/</url>
    
    <content type="html"><![CDATA[<p>今天来玩玩HBAO，目前URP仅有SSAO，HDRP则用的是GTAO。先在URP实现个HBAO，如果还有余力的话就再实现GTAO吧。<br />原理啥的就不详细写了，各种文章一大堆，就先简单说个大概。</p><figure><img src="HBAOS02.png" alt="HBAO in URP" /><figcaption aria-hidden="true">HBAO in URP</figcaption></figure><h1 id="ssao">SSAO</h1><p>先看URP自带的SSAO，别看Shader里定义了一堆pass，除了第一个SSAO_Occlusion，其他全是各种模糊。<br />详细看看第一个pass<br />大致流程就是</p><ul><li>先针对天空盒以0退出</li><li>对于超出了用户设定的Falloff的值也提前退出</li><li>获取法线（直接采样或者从深度推算）</li><li>从深度重建视线坐标</li><li>然后就是遍历每个采样点<ul><li>采样蓝噪声随机在半球上取点</li><li>然后转换成裁切坐标？</li><li>计算Z（深度）同时得出uv坐标</li><li>用UV再去采样深度</li><li>确保再次用UV采样的点在半球内</li><li>同样重建第二次用UV采样的点的坐标</li><li>依据和法线的夹角与长度确定对AO的贡献。</li></ul></li></ul><h1 id="hbao">HBAO</h1><p>先看<ahref="https://www.researchgate.net/publication/215506032_Image-space_horizon-based_ambient_occlusion">原文</a>，很精简，只有一页。干脆全篇翻译一下吧。</p><h2 id="介绍">介绍</h2><p>环境光遮蔽是一种光照模型，对于漫反射表面上某点，通过其直接可见的遮挡，来近似计算出到达的光线数量。它让人可感知到物体的曲率和空间的接近关系。与<ahref="">Mittring 2007</a>和<a href="">Shanmugam and Arikan2007</a>类似，我们提出了一种实时环境光遮蔽算法，作为后处理，主要基于眼睛角度的深度图像。该方法不需要场景相关的预计算，适用于动态场景。我们提出的方法不存在<ahref="">Shanmugam and Arikan 2007</a>中的过度遮挡问题，并且与<ahref="">Mittring 2007</a>不同，采样仅局限于影响半径内。</p><p>我们给定下述形式表述一给定表面的点P处的环境光遮挡A。<br /><span class="math display">$$\begin{equation}A=1-\frac{1}{2π} \int_{ω}^{} V(\stackrel{→}{ω})W(\stackrel{→}{ω})dω\tag*{(1)}\end{equation}$$</span></p><div class="note note-info">            <p>对每个角度都计算遮挡与否，0或者1，然后乘以影响系数后累加。<br />普通的SSAO就是这么计算的，随机取点，判断是否遮挡。</p>          </div><p>这里<span class="math inline"><em>V</em></span>表示法向单位半球<spanclass="math inline"><em>ω</em></span>上的可见性，返回<spanclass="math inline">1</span>表示一束光线从<spanclass="math inline"><em>P</em></span>点开始沿着<spanclass="math inline">$\stackrel{→}{ω}$</span>方向与遮挡物相交，否则返回<spanclass="math inline">0</span>，<spanclass="math inline"><em>W</em></span>是一个线性衰减函数。</p><h2 id="hbao-1">HBAO</h2><p>我们使用一球面坐标系，有一与视线<spanclass="math inline">$\mathop{V}\limits^{\rightarrow}$</span>对齐的天顶轴，方位角<spanclass="math inline"><em>θ</em></span>与仰角<spanclass="math inline"><em>α</em></span>（见图2a）。<br /><img src="HBAO2a.png"alt="2a 方位角θ绕着视线\mathop{V}\limits^{\rightarrow}。切线角t(θ)是表面切线的带符号仰角。" /></p><p>与<a href="">Max 1986</a>的水平映射类似，我们通过有符号的水平角<spanclass="math inline"><em>h</em>(<em>θ</em>)</span>定义的水平线来分割单位球体（见图2b）。</p><figure><img src="HBAO2b.png"alt="2b 水平角h(θ)是当α&gt;= t(θ)时的最大仰角，满足对于任意α&lt; h(θ)使得\stackrel{→}{ω}被遮蔽" /><figcaption aria-hidden="true">2b 水平角<spanclass="math inline"><em>h</em>(<em>θ</em>)</span>是当<spanclass="math inline"><em>α</em> &gt;  = <em>t</em>(<em>θ</em>)</span>时的最大仰角，满足对于任意<spanclass="math inline"><em>α</em> &lt; <em>h</em>(<em>θ</em>)</span>使得<spanclass="math inline">$\stackrel{→}{ω}$</span>被遮蔽</figcaption></figure><div class="note note-info">            <p>简单理解就是<spanclass="math inline"><em>h</em>(<em>θ</em>)</span>表示<spanclass="math inline"><em>θ</em></span>方向上斜率最大的那个仰角。</p>          </div><p>假设<spanclass="math inline"><em>P</em></span>的邻域是连续的高度场，通常在地平线以下追踪的光线已知与遮挡物相交，因此可以省略这些光线的相交测试。在连续高度场的假设下，方程1可以重写为：<br /><span class="math display">$$\begin{equation}A=1-\frac{1}{2π} \int_{θ =-π}^{π}\int_{α = t(θ )}^{h(θ )}W(\stackrel{→}{ω})cos(α )dα dθ\tag*{(2)}\end{equation}$$</span><br /><div class="note note-info">            <p>所以最终是对仰角在<spanclass="math inline"><em>t</em>(<em>θ</em>)</span>与<spanclass="math inline"><em>h</em>(<em>θ</em>)</span>之间的射线求遮蔽值。<br />这里还隐含了一个定义就是只要求出了最大的仰角，那么其之下的仰角也都是必定遮蔽的，这就是作者提出要求连续高度场的意思。</p>          </div></p><p>我们使用线性衰减函数<spanclass="math inline"><em>W</em>(<em>θ</em>) = <em>m</em><em>a</em><em>x</em>(0,1−<em>r</em>(<em>θ</em>)/<em>R</em>)</span>，其中<spanclass="math inline"><em>r</em>(<em>θ</em>)</span> 是 <spanclass="math inline"><em>P</em></span> 和 <spanclass="math inline">$\stackrel{→}{ω}$</span>方向上的地平点之间的距离，<span class="math inline"><em>R</em></span>是半径。在这种情况下，<br /><span class="math display">$$\begin{equation}A=1-\frac{1}{2π} \int_{θ =-π}^{π}(sin(h(θ)) -sin(t(θ))) W(θ)dθ\tag*{(3)}\end{equation}$$</span></p><div class="note note-info">            <p>这里的<spanclass="math inline"><em>W</em>(<em>θ</em>)</span>指的不是之前的<spanclass="math inline">$W(\stackrel{→}{ω})$</span>，指的是整体上在<spanclass="math inline"><em>θ</em></span>这个方位角的切面上的衰减。</p>          </div><h2 id="图像空间积分">图像空间积分</h2><p>我们的算法将每像素的深度和眼空间法线作为输入。对于每个像素，我们计算其眼空间的位置<spanclass="math inline"><em>P</em></span>，并且我们通过使用图像空间的不同方向和步长，来对存储在深度图像中的高度场进行采样，使用蒙特卡洛方法，对等式3进行积分。</p><p>我们在图像空间选取围绕着当前像素的<spanclass="math inline"><em>N</em><sub><em>d</em></sub></span>个方向<spanclass="math inline"><em>θ</em></span>，这些方向对应于眼空间中Z轴周围的方向（在图2a中表示为<spanclass="math inline"><em>V</em></span>）。</p><p>对于每个角度<spanclass="math inline"><em>θ</em></span>，我们通过在图像空间中沿着线段来采样深度图像，并以此计算地平线角度<spanclass="math inline"><em>h</em>(<em>θ</em>)</span>。<br />受影响的眼空间的半径<spanclass="math inline"><em>R</em></span>被投影到图像平面，并分为等长度的<spanclass="math inline"><em>N</em><sub><em>s</em></sub></span>个步骤。</p><p>为了找到方向<spanclass="math inline"><em>θ</em></span>上的地平线角度，我们首先计算切线角度<spanclass="math inline"><em>t</em>(<em>θ</em>)</span>，并将视线射线与由<spanclass="math inline"><em>P</em></span>和表面法线<spanclass="math inline">$\stackrel{→}{n}$</span>定义的切平面相交。<br />然后我们沿着方向<spanclass="math inline"><em>θ</em></span>在深度图像中前进，并计算<spanclass="math inline"><em>D</em> = <em>S</em><sub><em>i</em></sub> − <em>P</em></span>，其中<spanclass="math inline"><em>S</em><sub><em>i</em></sub></span>是给定样本<spanclass="math inline"><em>S</em><sub><em>i</em></sub></span>的重建眼空间位置。<br />基于仰角<spanclass="math inline"><em>α</em>(<em>S</em><em>i</em>) = <em>a</em><em>t</em><em>a</em><em>n</em>(−<em>D</em>.<em>z</em>/||<em>D</em>.<em>x</em><em>y</em>||)</span>，地平线角度<spanclass="math inline"><em>h</em>(<em>θ</em>)</span>是<spanclass="math inline"><em>m</em><em>a</em><em>x</em>(<em>t</em>(<em>θ</em>),<em>α</em>(<em>S</em><em>i</em>),<em>i</em>=1..<em>N</em><sub><em>s</em></sub>)</span>，其中<spanclass="math inline"><em>N</em><sub><em>s</em></sub></span>是每个方向的步骤数。我们忽略满足<spanclass="math inline">||<em>S</em><em>i</em> − <em>P</em>|| &gt; <em>R</em></span>的样本。因为<spanclass="math inline"><em>D</em>.<em>z</em></span>必须是与偏移<spanclass="math inline"><em>D</em>.<em>x</em><em>y</em></span>相关联的确切深度，所以我们始终确保在纹素中心进行采样。为此，我们将沿着每个方向的样本的纹理坐标捕捉到最近的纹素中心（见图2c）。</p><figure><img src="HBAO2c.png" alt="2c 4个方向和2个纹素步长的样本位置示例" /><figcaption aria-hidden="true">2c4个方向和2个纹素步长的样本位置示例</figcaption></figure><p>为了将带状伪影换成噪声，我们会对每个像素随机抖动步长，并对每个像素随机旋转<spanclass="math inline"><em>N</em><sub><em>d</em></sub></span>个均匀方向。尽管通常使用单个深度层可以产生合理的结果，但也可以通过使用多个层次来扩展，例如前后两个面。</p><h2 id="shader-实现">Shader 实现</h2><p>直接贴代码吧，大部分取自<ahref="https://github.com/nvpro-samples/gl_ssao">Nvidia的示例仓库</a></p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float Falloff(float DistanceSquare)&#123;    return DistanceSquare * _NegInvR2 + 1.0;&#125;float ComputeAO(float3 p, float3 n, float3 s)&#123;    float3 v &#x3D; s - p;    float VdotV &#x3D; dot(v, v);    float NdotV &#x3D; dot(n, v) * rsqrt(VdotV);    return clamp(NdotV - _NDotVBias, 0, 1) * clamp(Falloff(VdotV), 0, 1);&#125;float3 FetchViewPos(float2 uv)&#123;    float rawDepth &#x3D; SampleDepth(uv);    float3 viewPos &#x3D; ComputeViewSpacePosition(uv, rawDepth,UNITY_MATRIX_I_P);    return viewPos;&#125;float random(float v)&#123;    return frac(sin(v * 42.5) * 43758.5453123);&#125;float4 GetJitter(float2 uv)&#123;    &#x2F;&#x2F; (cos(Alpha),sin(Alpha),rand1,rand2)    &#x2F;&#x2F; return textureLod( texRandom, (gl_FragCoord.xy &#x2F; AO_RANDOMTEX_SIZE), 0);    float Alpha &#x3D; SAMPLE_BLUE_NOISE((uv + BlueNoiseOffset) * BlueNoiseScale);    Alpha *&#x3D; 2.0 * PI;    return float4(cos(Alpha), sin(Alpha), random(Alpha), random(Alpha + 57));&#125;float2 RotateDirection(float2 Dir, float2 CosSin)&#123;    return float2(Dir.x * CosSin.x - Dir.y * CosSin.y,                  Dir.x * CosSin.y + Dir.y * CosSin.x);&#125;&#x2F;&#x2F;----------------------------------------------------------------------------------float3 ComputeCoarseAO(float2 FullResUV, float RadiusPixels, float4 Rand, float3 ViewPosition, float3 ViewNormal)&#123;    &#x2F;&#x2F; Divide by NUM_STEPS+1 so that the farthest samples are not fully attenuated    float StepSizePixels &#x3D; RadiusPixels &#x2F; (_NUM_STEPS + 1);    const float Alpha &#x3D; 2.0 * PI &#x2F; _NUM_DIRECTIONS;    float AO &#x3D; 0;    for (float DirectionIndex &#x3D; 0; DirectionIndex &lt; _NUM_DIRECTIONS; ++DirectionIndex)    &#123;        float Angle &#x3D; Alpha * DirectionIndex;        &#x2F;&#x2F; Compute normalized 2D direction        float2 Direction &#x3D; RotateDirection(float2(cos(Angle), sin(Angle)), Rand.xy);        &#x2F;&#x2F; Jitter starting sample within the first step        float RayPixels &#x3D; (Rand.z * StepSizePixels + 1.0);        for (float StepIndex &#x3D; 0; StepIndex &lt; _NUM_STEPS; ++StepIndex)        &#123;            float2 SnappedUV &#x3D; round(RayPixels * Direction) &#x2F; _ScreenParams.xy + FullResUV;            float3 S &#x3D; FetchViewPos(SnappedUV);            &#x2F;&#x2F; return S;            RayPixels +&#x3D; StepSizePixels;            AO +&#x3D; ComputeAO(ViewPosition, ViewNormal, S);        &#125;    &#125;    AO &#x2F;&#x3D; _NUM_DIRECTIONS * _NUM_STEPS;    return clamp(1.0 - AO * 2, 0.0, 1.0);&#125;half4 HBAO(Varyings input) : SV_Target&#123;    UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);    float2 uv &#x3D; input.texcoord;    float3 ViewPosition &#x3D; FetchViewPos(uv);    float3 worldNormal &#x3D; SampleNormal(uv);    float3 ViewNormal &#x3D; TransformWorldToViewNormal(worldNormal);    ViewNormal.z &#x3D; -ViewNormal.z;    float RadiusPixels &#x3D; _RadiusToScreen &#x2F; ViewPosition.z;    float4 Rand &#x3D; GetJitter(uv);    float AO &#x3D; ComputeCoarseAO(uv, RadiusPixels, Rand, ViewPosition, ViewNormal);    AO &#x3D; pow(AO, 2);    &#x2F;&#x2F; AO &#x3D; 1 - AO;    return float4(AO, AO, AO, 1);&#125;</code></pre></div></figure><h1 id="与lit整合">与Lit整合</h1><p>最简单的方式就是直接修改原SSAO的shader然后仅替换计算部分，这样就无需修改原Lit。或者想完善一点就单独增加一个Feature，仿照SSAO的写法，单独写入一张RT，然后再修改Lit取采样这张AO。但是很多URP的函数没有暴露出来，比如RenderGraph，所以还得cloneURP的仓库去改URP源码。这就先放一放吧，等实现了GTAO再放一起来做吧。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>常见模糊后处理</title>
    <link href="/2023/08/04/Blur/"/>
    <url>/2023/08/04/Blur/</url>
    
    <content type="html"><![CDATA[<h1 id="模糊">模糊</h1><p>最近做的很多效果最终都需要模糊，如镜面反射要模糊模拟粗糙度反射，体积光要降采样然后模糊来降低性能消耗同时柔化效果<br />更不要说UI上需要模糊背景，透明物体要毛玻璃等等效果，还是很有必要好好整理一下相关的方案同时打包成库方便以后调用。<br /><span id="more"></span><br />这就不得不提及毛星云大佬的<ahref="https://zhuanlan.zhihu.com/p/125744132">高品质后处理：十种图像模糊算法的总结与实现</a>。<br />其中的全部方案都包含在他的开源项目<ahref="https://github.com/QianMo/X-PostProcessing-Library">X-PostProcessing-Library</a>中。<br />当中提及<code>后续也将提供对Unity引擎URP/LWRP/HDRP的兼容支持。</code>但如今也只能惋惜了。</p><p>本着学习以及方便自己日后使用的目的，暂将其中模糊相关实用的部分整理成URP支持的RendererFeature、VolumeComponent等形式。</p><p>当然本仓库也不是单纯的翻译，除了可以用作全屏后处理，也抽象成工具类库，方便其他非相机的效果调用模糊处理。<br />同时提供了一些特定的RenderFeature，比如3D场景中的磨砂玻璃等。</p><p><a href="https://github.com/MaZhengKe/Blur">项目地址</a><br />这里只记录和URP相关的部分，具体模糊的算法就不赘述了。</p><figure><img src="Blur01.jpg" alt="模糊" /><figcaption aria-hidden="true">模糊</figcaption></figure><figure><img src="Blur02.png" alt="VolumeComponent" /><figcaption aria-hidden="true">VolumeComponent</figcaption></figure><h1 id="script">Script</h1><p>先把这里的各个模糊后处理Pass中通用的部分提出来，抽象成一个基类</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public abstract class BaseBlurRendererPass : ScriptableRenderPass&#123;    protected abstract BlurRendererFeature.ProfileId ProfileId &#123; get; &#125;        protected abstract string ShaderName &#123; get; &#125;    protected string MaskBlendShaderName &#x3D; &quot;KuanMi&#x2F;MaskBlend&quot;;    protected Shader m_Shader;    protected ScriptableRenderer m_Renderer;    protected Material m_Material;    protected Material m_BlendMaterial;    protected RenderTextureDescriptor descriptor;    protected static readonly int BlurRadius &#x3D; Shader.PropertyToID(&quot;_Offset&quot;);    protected static readonly int BlitTexture &#x3D; Shader.PropertyToID(&quot;_BlitTexture&quot;);    protected static readonly int BlurOffset &#x3D; Shader.PropertyToID(&quot;_BlurOffset&quot;);    protected static readonly int BlitTextureSt &#x3D; Shader.PropertyToID(&quot;_BlitTexture_ST&quot;);    internal static readonly int GoldenRot &#x3D; Shader.PropertyToID(&quot;_GoldenRot&quot;);    internal static readonly int Params &#x3D; Shader.PropertyToID(&quot;_Params&quot;);    public override void OnCameraSetup(CommandBuffer cmd, ref RenderingData renderingData)    &#123;        base.OnCameraSetup(cmd, ref renderingData);        var cameraTargetDescriptor &#x3D; renderingData.cameraData.cameraTargetDescriptor;        descriptor &#x3D; cameraTargetDescriptor;        descriptor.depthBufferBits &#x3D; 0;        descriptor.msaaSamples &#x3D; 1;    &#125;    public abstract void ExecuteWithCmd(CommandBuffer cmd, ref RenderingData renderingData);    public virtual bool Setup(ScriptableRenderer renderer)    &#123;        if(!GetMaterial())            return false;        m_Renderer &#x3D; renderer;        return true;    &#125;        private bool GetMaterial()    &#123;        if (m_Material !&#x3D; null)        &#123;            return true;        &#125;        if (m_Shader &#x3D;&#x3D; null)        &#123;            m_Shader &#x3D; Shader.Find(ShaderName);            if (m_Shader &#x3D;&#x3D; null)            &#123;                return false;            &#125;        &#125;        m_Material &#x3D; CoreUtils.CreateEngineMaterial(m_Shader);        m_BlendMaterial &#x3D; CoreUtils.CreateEngineMaterial(Shader.Find(MaskBlendShaderName));        return m_Material !&#x3D; null;    &#125;    public virtual void Dispose()    &#123;        CoreUtils.Destroy(m_Material);    &#125;&#125;</code></pre></div></figure><p>为了便于在Pass中获取Volume的属性，再提一个泛型抽象类出来</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public abstract class BaseBlurRendererPassWithVolume&lt;K&gt; : BaseBlurRendererPass where K : BaseBlur&#123;    protected K blurVolume;    protected MaskBlur maskBlur;    protected bool isMask &#x3D;&gt; maskBlur.isMask.value;    protected RTHandle m_MaskTexture;    public override void OnCameraSetup(CommandBuffer cmd, ref RenderingData renderingData)    &#123;        base.OnCameraSetup(cmd, ref renderingData);        var stack &#x3D; VolumeManager.instance.stack;        blurVolume &#x3D; stack.GetComponent&lt;K&gt;();        maskBlur &#x3D; stack.GetComponent&lt;MaskBlur&gt;();        descriptor.width &#x2F;&#x3D; blurVolume.DownSample.value;        descriptor.height &#x2F;&#x3D; blurVolume.DownSample.value;        if (isMask)        &#123;            RenderingUtils.ReAllocateIfNeeded(ref m_MaskTexture, descriptor, FilterMode.Bilinear,                TextureWrapMode.Clamp, name: &quot;_MaskTex&quot;);        &#125;    &#125;    public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)    &#123;        if (m_Material &#x3D;&#x3D; null)        &#123;            Debug.LogError(&quot;Material is null&quot;);            return;        &#125;        var stack &#x3D; VolumeManager.instance.stack;        blurVolume &#x3D; stack.GetComponent&lt;K&gt;();        maskBlur &#x3D; stack.GetComponent&lt;MaskBlur&gt;();        var cmd &#x3D; CommandBufferPool.Get();        using (new ProfilingScope(cmd, ProfilingSampler.Get(ProfileId)))        &#123;            &#x2F;&#x2F; Debug.Log(&quot;ad&quot; + Time.frameCount);            ExecuteWithCmd(cmd, ref renderingData);            if (isMask)            &#123;                m_BlendMaterial.SetFloat(&quot;_Spread&quot;, maskBlur.areaSmooth.value);                m_BlendMaterial.SetColor(&quot;_MaskColor&quot;,maskBlur.maskColor.value);                if (maskBlur.maskType.value &#x3D;&#x3D; MaskBlur.MaskType.Circle)                &#123;                    m_BlendMaterial.EnableKeyword(&quot;_CIRCLE&quot;);                    m_BlendMaterial.SetVector(&quot;_Center&quot;, maskBlur.center.value);                    m_BlendMaterial.SetFloat(&quot;_Area&quot;, maskBlur.radius.value);                &#125;                else                &#123;                    m_BlendMaterial.DisableKeyword(&quot;_CIRCLE&quot;);                    m_BlendMaterial.SetFloat(&quot;_Area&quot;, maskBlur.areaSize.value);                    m_BlendMaterial.SetFloat(&quot;_Offset&quot;, maskBlur.offset.value);                &#125;                Blit(cmd, m_MaskTexture, m_Renderer.cameraColorTargetHandle, m_BlendMaterial);            &#125;        &#125;        context.ExecuteCommandBuffer(cmd);        CommandBufferPool.Release(cmd);    &#125;    public override bool Setup(ScriptableRenderer renderer)    &#123;        if (!base.Setup(renderer))            return false;        blurVolume &#x3D; VolumeManager.instance.stack.GetComponent&lt;K&gt;();        return blurVolume.IsActive();    &#125;    public override void Dispose()    &#123;        base.Dispose();        m_MaskTexture?.Release();    &#125;&#125;</code></pre></div></figure><p>这里为了方便复用，把模糊的遮罩单独提出来，单独用一个Pass来混合，但这其实是浪费性能的做法。</p><p>然后留给具体的模糊后处理的事情就只剩申请RT与绘制调用了。<br />以DualBlurRenderPass为例子<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public class DualBlurRenderPass : BaseBlurRendererPassWithVolume&lt;DualBlur&gt;&#123;    protected override BlurRendererFeature.ProfileId ProfileId &#x3D;&gt; BlurRendererFeature.ProfileId.DualBlur;        protected override string ShaderName &#x3D;&gt; &quot;KuanMi&#x2F;DualBlur&quot;;    RTHandle[] m_Down;    RTHandle[] m_Up;    const int k_MaxPyramidSize &#x3D; 16;    public DualBlurRenderPass()    &#123;        m_Down &#x3D; new RTHandle[k_MaxPyramidSize];        m_Up &#x3D; new RTHandle[k_MaxPyramidSize];    &#125;    public override void OnCameraSetup(CommandBuffer cmd, ref RenderingData renderingData)    &#123;        base.OnCameraSetup(cmd, ref renderingData);        for (int i &#x3D; 0; i &lt; blurVolume.Iteration.value; i++)        &#123;            RenderingUtils.ReAllocateIfNeeded(ref m_Down[i], descriptor, FilterMode.Bilinear, TextureWrapMode.Clamp,                name: &quot;_Down&quot; + i);            RenderingUtils.ReAllocateIfNeeded(ref m_Up[i], descriptor, FilterMode.Bilinear, TextureWrapMode.Clamp,                name: &quot;_Up&quot; + i);            descriptor.width &#x2F;&#x3D; 2;            descriptor.height &#x2F;&#x3D; 2;        &#125;    &#125;    public override void ExecuteWithCmd(CommandBuffer cmd, ref RenderingData renderingData)    &#123;        var blurRadius &#x3D; blurVolume.BlurRadius.value;        var iteration &#x3D; blurVolume.Iteration.value;        m_Material.SetVector(BlitTextureSt, new Vector4(1, 1, 0, 0));        m_Material.SetFloat(BlurRadius, blurRadius);        Blitter.BlitCameraTexture(cmd, m_Renderer.cameraColorTargetHandle, m_Down[0],            RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store, m_Material, 1);        var lastDown &#x3D; m_Down[0];        for (int i &#x3D; 1; i &lt; iteration; i++)        &#123;            Blitter.BlitCameraTexture(cmd, lastDown, m_Down[i], RenderBufferLoadAction.DontCare,                RenderBufferStoreAction.Store, m_Material, 1);            lastDown &#x3D; m_Down[i];        &#125;        var lastUp &#x3D; lastDown;        for (int i &#x3D; iteration - 2; i &gt;&#x3D; 0; i--)        &#123;            Blitter.BlitCameraTexture(cmd, lastUp, m_Up[i], RenderBufferLoadAction.DontCare,                RenderBufferStoreAction.Store, m_Material, 0);            lastUp &#x3D; m_Up[i];        &#125;        &#x2F;&#x2F; Blit(cmd, lastUp, m_Renderer.cameraColorTargetHandle);        Blitter.BlitCameraTexture(cmd, lastUp, isMask ? m_MaskTexture : m_Renderer.cameraColorTargetHandle, RenderBufferLoadAction.DontCare,            RenderBufferStoreAction.Store, m_Material, 0);    &#125;    public override void Dispose()    &#123;        base.Dispose();        foreach (var rtHandle in m_Down)        &#123;            rtHandle?.Release();        &#125;        foreach (var rtHandle in m_Up)        &#123;            rtHandle?.Release();        &#125;    &#125;&#125;</code></pre></div></figure></p><p>申请需要的两组上下采样的RT，先降采样，然后升采样，最后依据是否需要和遮罩混合决定是直接绘制到相机上还是遮罩上。</p><h2 id="volumecomponenteditor">VolumeComponentEditor</h2><p>这是控制在Volume组件里显示属性的类。<br />写法很套路化<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">[CustomEditor(typeof(MaskBlur))]public class MaskBlurEditor : VolumeComponentEditor&#123;    SerializedDataParameter m_isMask;    SerializedDataParameter m_areaSmooth;    SerializedDataParameter m_maskColor;    ......    public override void OnEnable()    &#123;        var o &#x3D; new PropertyFetcher&lt;MaskBlur&gt;(serializedObject);        m_isMask &#x3D; Unpack(o.Find(x &#x3D;&gt; x.isMask));        m_maskType &#x3D; Unpack(o.Find(x &#x3D;&gt; x.maskType));        m_maskColor &#x3D; Unpack(o.Find(x &#x3D;&gt; x.maskColor))        ......    &#125;    public override void OnInspectorGUI()    &#123;        PropertyField(m_isMask);        PropertyField(m_maskType);                if(m_maskType.value.intValue &#x3D;&#x3D; (int)MaskBlur.MaskType.Rectangle)        &#123;            PropertyField(m_offset);                    &#125;        else if(m_maskType.value.intValue &#x3D;&#x3D; (int)MaskBlur.MaskType.Circle)        &#123;            PropertyField(m_center);        &#125;    &#125;&#125;</code></pre></div></figure></p><h1 id="shader">Shader</h1><p>因为原仓库也是用hlsl，所以基本没什么变换，<br />顶点着色器仿照URP其他后处理，采用VERTEXID_SEMANTIC来计算裁切坐标。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">DefaultVaryings defaultVert(DefaultAttributes IN)&#123;    DefaultVaryings output;    output.positionCS &#x3D; GetFullScreenTriangleVertexPosition(IN.vertexID);    output.uv &#x3D; output.positionCS.xy * 0.5 + 0.5;    #if UNITY_UV_STARTS_AT_TOP    output.uv.y &#x3D; 1 - output.uv.y;    #endif    return output;&#125;</code></pre></div></figure></p><h1 id="工具库">工具库</h1><p>然后就是要考虑怎么让其他效果能方便的调用。<br />大致思路有两个，一个就通过RTID来在RendererFeature之间传递。<br />或者把全部Pass都提成工具类，在其他需要模糊效果的Pass中实例化然后调用。<br />最后还是觉得后者更靠谱一点。</p><p>所以把具体的模糊算法再抽象一层<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public abstract class BaseTool&#123;    public abstract string ShaderName &#123; get; &#125;    public Material Material &#123; get; protected set; &#125;        internal static readonly int GoldenRot &#x3D; Shader.PropertyToID(&quot;_GoldenRot&quot;);    internal static readonly int Params &#x3D; Shader.PropertyToID(&quot;_Params&quot;);        protected ScriptableRenderPass _renderPass;        public BaseTool(ScriptableRenderPass renderPass)    &#123;        _renderPass &#x3D; renderPass;                Material &#x3D; CoreUtils.CreateEngineMaterial(Shader.Find(ShaderName));    &#125;    public abstract void OnCameraSetup(RenderTextureDescriptor descriptor);    public abstract void Execute(CommandBuffer cmd, RTHandle source, RTHandle target);        public virtual void Dispose()    &#123;        CoreUtils.Destroy(Material);    &#125;&#125;</code></pre></div></figure><br />把具体的参数的配置剥离开，相机视口的属性也剥离开。<br />这样就方便了在其他Pass中直接引用模糊的功能。<br />比如在之前写的体积光中</p><p>不直接绘制到视窗中，而是先绘制到一张RT上，把这张RT传给模糊工具，让其模糊后绘制到另一张RT上，然后再与视窗加法混合。<br />当然如果考虑性能，应该是能合并很多操作到一个Shader中的。但为了开发测试方便，这里先分开，真的有需要再汇总全部后处理。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GitPackage</title>
    <link href="/2023/07/31/GitPackage/"/>
    <url>/2023/07/31/GitPackage/</url>
    
    <content type="html"><![CDATA[<p>为了便于复用，需要把一些常用的功能做成Package，要管理这些Package的话单独建一个UPM的库有点没有必要，直接用Git来管理就好。<br />这里记录下使用Git发布、更新包的流程。</p><h1 id="目录结构">目录结构</h1><p>与一般的Package没有什么不同，可以参照Unity官方的一些包来配置。<br />其实这里对于文件夹命名等没有什么明确的要求，一般来说分成以下几个部分。</p><h2 id="documentation">Documentation~</h2><p>文档的目录，一般存放一些md格式的说明。以~结尾的文件夹不会在编辑器中显示。</p><h2 id="samples">Samples~</h2><p>存放示例的目录，一般来说这个目录下的每个文件夹就对应了PackageManager的Samples中的一个示例。<br />需要在Package.json文件中定义，这个下面再说。</p><h2 id="tests">Tests</h2><p>顾名思义，存放测试的地方。</p><h2 id="runtime-editor">Runtime Editor</h2><p>一般来说会有这两个文件夹，区分运行时代码与编辑器代码。<br />同时下面会有两个asmdef来定义两个程序集合。</p><h2 id="package.json">package.json</h2><p>包的定义文件。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;name&quot;: &quot;top.kuanmi.outline&quot;,  &quot;displayName&quot;: &quot;Outline&quot;,  &quot;version&quot;: &quot;0.1.1&quot;,  &quot;unity&quot;: &quot;2022.1&quot;,  &quot;description&quot;: &quot;Outline for URP&quot;,  &quot;dependencies&quot;: &#123;    &quot;com.unity.render-pipelines.universal&quot;: &quot;13.1.8&quot;  &#125;,  &quot;samples&quot;: [    &#123;      &quot;displayName&quot;: &quot;Outline for URP&quot;,      &quot;description&quot;: &quot;Simple Outline for URP&quot;,      &quot;path&quot;: &quot;Samples~&#x2F;Example&quot;    &#125;  ]&#125;</code></pre></div></figure><br />参数就不一一解释了。</p><h2 id="readme.md-changelog.md-license.md">README.md CHANGELOG.mdLICENSE.md</h2><p>一些文本文件了，不影响实际使用。</p><h1 id="git">Git</h1><p>然后是Git相关的一些<br />可以通过打Tag的形式来管理版本。<br />git tag 1.0.0<br />git push -u origin main –tags</p><p>安装时就通过指定Tag，或者分支的形式选定版本</p><p>https://github.com/MaZhengKe/URPOutline.git#1.0.0</p><p>但是目前还没有找到让Package manager扫描全部Tag的方式。</p><h1 id="subtree">subtree</h1><p>那平时开发与维护还需要一个仓库，这两个仓库有依赖关系。</p><p>所以再新开一个空项目，初始化Git。</p><p>初次提交之后，可以通过如下命令来引入依赖的Git仓库<br />git subtree add –prefix=Assets/Outlinehttps://github.com/MaZhengKe/URPOutline main</p><p>这样就在子路径下引入了依赖。</p><p>然后就按照正常的流程去修改，提交。</p><p>当需要推送到子仓库或者发布版本时：<br />git subtree push –prefix=Assets/Outlinehttps://github.com/MaZhengKe/URPOutline main</p><p>打Tag仍需要回到原Git环境下去打。</p>]]></content>
    
    
    <categories>
      
      <category>编码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Package</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>相机镜面反射</title>
    <link href="/2023/07/31/MirrorCamera/"/>
    <url>/2023/07/31/MirrorCamera/</url>
    
    <content type="html"><![CDATA[<p>除了常见的反射探针，SSR，之前变换相机矩阵，还有一种最简单的方式就是直接添加一个镜面相机。<br /><span id="more"></span></p><figure><img src="mirrorCamera.jpg" alt="相机镜面反射" /><figcaption aria-hidden="true">相机镜面反射</figcaption></figure><h1 id="脚本">脚本</h1><p>脚本方面主要是使镜面相机和主相机镜像同步，包含FOV等等。</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">    void MirrorCam()    &#123;        Camera camera &#x3D; originalCamera;#if UNITY_EDITOR        var focusedWindow &#x3D; EditorWindow.focusedWindow;        if (focusedWindow &#x3D;&#x3D; null)            return;        var type &#x3D; focusedWindow.GetType().Name;        switch (type)        &#123;            case &quot;SceneView&quot;:            case &quot;GameView&quot;:                currentView &#x3D; type;                break;        &#125;        if (Application.isPlaying &#x3D;&#x3D; false &amp;&amp; currentView &#x3D;&#x3D; &quot;SceneView&quot;)        &#123;            var sceneView &#x3D; SceneView.lastActiveSceneView;            camera &#x3D; sceneView.camera;        &#125;#endif        if (camera !&#x3D; null)        &#123;            mirrorCamera.fieldOfView &#x3D; camera.fieldOfView;            mirrorCamera.aspect &#x3D; camera.aspect;            MirrorTransformForPlane(mirrorCamera.transform, camera.transform, plane);        &#125;    &#125;    public static Quaternion mirrorRot(Transform plane, Quaternion cam)    &#123;        var forward &#x3D; plane.forward;        var reflect &#x3D; Vector3.Reflect(cam * Vector3.forward, forward);        var reflectup &#x3D; Vector3.Reflect(cam * Vector3.up, forward);        return Quaternion.LookRotation(reflect, reflectup);    &#125;    public static Vector3 mirrorPos(Transform plane, Vector3 oldPos)    &#123;        var forward &#x3D; plane.forward;        var planPos &#x3D; plane.position;        var dis &#x3D; planPos - oldPos;        var cros &#x3D; Vector3.Cross(dis, forward).normalized;        var ccos &#x3D; Vector3.Cross(cros, forward);        var refDis &#x3D; Vector3.Reflect(dis, ccos);        return refDis + planPos;    &#125;    private static void MirrorTransformForPlane(Transform mirrorTransform, Transform originTransform, Transform plane)    &#123;        var originPosition &#x3D; originTransform.position;        var originRotation &#x3D; originTransform.rotation;        var mirrorPosition &#x3D; mirrorPos(plane, originPosition);        var mirrorRotation &#x3D; mirrorRot(plane, originRotation);        mirrorTransform.position &#x3D; mirrorPosition;        mirrorTransform.rotation &#x3D; mirrorRotation;    &#125;</code></pre></div></figure><p>这里就设置一下镜面相机的位置和旋转。<br />编辑器中要特殊对待，取场景的相机。</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">    private void LateUpdate()    &#123;        MirrorCam();    &#125;#if UNITY_EDITOR    void OnRenderObject()    &#123;        MirrorCam();    &#125;#endif</code></pre></div></figure><p>运行时在LateUpdate中设置，编辑器中就用OnRenderObject吧。</p><h1 id="shader-graph">Shader Graph</h1><p>这里的Shader很简单，用SG连一下就行了。</p><figure><img src="mirrorSG.png" alt="镜面SG" /><figcaption aria-hidden="true">镜面SG</figcaption></figure><p>屏幕UV要取对称，用菲涅尔简单模拟一下全反射，采样一下法线稍微做一下偏移。</p>]]></content>
    
    
    <categories>
      
      <category>渲染</category>
      
    </categories>
    
    
    <tags>
      
      <tag>反射</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>URP体积光</title>
    <link href="/2023/07/31/VolumeLight/"/>
    <url>/2023/07/31/VolumeLight/</url>
    
    <content type="html"><![CDATA[<h1 id="前述">前述</h1><p>又造一个轮子，为了庆祝URP终于出了TAA，撸一个简单体积光来庆祝一下。<br />就最最基础的用光线步进，采样阴影贴图。稍微抖动一下搭配TAA。<br />还是有一些URP的坑在里面的。简单记录一下，以备将来查验。<br /><span id="more"></span><br /><img src="VLight01.png" alt="平行光" /><br /><img src="VLight02.png" alt="射灯" /><br /><ahref="https://github.com/MaZhengKe/VolumetricLighting">项目地址</a>，直接PackageManager导入Git仓库就行</p><h1 id="renderer-feature">Renderer Feature</h1><p>因为不打算再写一个RenderFeature了，直接用现成的<code>Full Screen Pass Renderer Feature</code>，所以就按照这个Pass要求的Shader的写法，要写两个Pass</p><ul><li>DrawProcedural</li><li>Blit</li></ul><p>这里就是第一个坑。如果只写一个Pass，在编辑器是没问题的，打包出来就失效，还不报错。。。</p><h1 id="shader">Shader</h1><h2 id="顶点">顶点</h2><p>可以直接用vertexID来计算位置。这个<code>VERTEXID_SEMANTIC</code>语义还挺少见的。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">Varyings vert(Attributes IN)&#123;    Varyings output;    output.positionCS &#x3D; GetFullScreenTriangleVertexPosition(IN.vertexID);    output.texCoord0 &#x3D; output.positionCS.xy * 0.5 + 0.5;    #if UNITY_UV_STARTS_AT_TOP    output.texCoord0.y &#x3D; 1 - output.texCoord0.y;    #endif    return output;&#125;</code></pre></div></figure><br />记得考虑到DX与OpenGL的区别。</p><h2 id="片元">片元</h2><p>首先是依据深度图重建世界坐标，用这个坐标作为步进的终点。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">#if UNITY_REVERSED_Zreal depth &#x3D; SampleSceneDepth(IN.texCoord0);#elsereal depth &#x3D; lerp(UNITY_NEAR_CLIP_VALUE, 1, SampleSceneDepth(IN.texCoord0));#endiffloat3 worldPos &#x3D; ComputeWorldSpacePosition(IN.texCoord0, depth, UNITY_MATRIX_I_VP);</code></pre></div></figure></p><p>这里考虑一下米氏散射。即光线散射的方向和光线的照射方向有关。<br />步进前的准备<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float3 rayOrigin &#x3D; _WorldSpaceCameraPos;float numSteps &#x3D; 30;float3 ray &#x3D; worldPos - rayOrigin;float3 rayDir &#x3D; (worldPos - rayOrigin) &#x2F; numSteps;float n &#x3D; length(rayDir);float density &#x3D; 0;float cosAngle &#x3D; dot(-_MainLightPosition.xyz, normalize(ray));</code></pre></div></figure><br />起点是相机位置，采样的位置是从起点到终点均匀的30个点。</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">for (int i &#x3D; 1; i &lt; numSteps; i++)&#123;    float3 pos &#x3D; rayOrigin + rayDir * (i + noise(IN.texCoord0*i+_Time.xy));    float4 shadowCoord &#x3D; TransformWorldToShadowCoord(pos);    float light &#x3D; MainLightRealtimeShadow(shadowCoord);    light *&#x3D; MieScattering2(cosAngle, _MieK);    light *&#x3D; n;    density +&#x3D; light;&#125;</code></pre></div></figure><p>这里针对采样点做了前后的偏移抖动，保证从侧面看体积光的分界线分明。搭配TAA效果还可以。</p><p>然后就是采样阴影，计算米氏散射系数，</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">density &#x3D; 1 - exp(-density);density *&#x3D; _scale;return half4(density, density, density, 1.0);</code></pre></div></figure><p>最后依据强度取对数并乘以系数就完活。</p><h1 id="聚光灯点光源">聚光灯/点光源</h1><p>平行光用整个屏幕步进，聚光灯与点光源就没必要全屏了，还可以通过AABB来剔除。</p><h2 id="mesh">Mesh</h2><p>点光源的网格很简单，Blender弄个棱角球等比放大即可。<br />聚光灯就实时根据角度和高度去生成两个锥体包裹起来。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">private Vector3[] GetVertices()&#123;    var vertices &#x3D; new Vector3[num + 2];    float halfAngle &#x3D; Light.spotAngle * 0.5f * Mathf.Deg2Rad;    float qAngle &#x3D; halfAngle * 0.5f;    float r &#x3D; Light.range &#x2F; Mathf.Cos(qAngle);    float h &#x3D; r * Mathf.Cos(halfAngle);    float v &#x3D; Mathf.Sin(halfAngle) * r;    v &#x2F;&#x3D; Mathf.Cos(Mathf.PI * 2 &#x2F; (num * 2));    vertices[0] &#x3D; Vector3.zero;    for (int i &#x3D; 0; i &lt; num; i++)    &#123;        vertices[i + 1] &#x3D; new Vector3(Mathf.Cos(i * Mathf.PI * 2 &#x2F; num) * v,            Mathf.Sin(i * Mathf.PI * 2 &#x2F; num) * v, h);    &#125;    vertices[num + 1] &#x3D; new Vector3(0, 0, r);    return vertices;&#125;private void AddTriangle(ref int[] triangles, ref int index, int a, int b, int c)&#123;    triangles[index++] &#x3D; a;    triangles[index++] &#x3D; b;    triangles[index++] &#x3D; c;&#125;private int[] GetTriangles()&#123;    var triangles &#x3D; new int[num * 2 * 3];    int index &#x3D; 0;    for (int i &#x3D; 0; i &lt; num; i++)    &#123;        AddTriangle(ref triangles, ref index, num + 1, i + 1, (i + 1) % num + 1);        AddTriangle(ref triangles, ref index, 0, (i + 1) % num + 1, i + 1);    &#125;    return triangles;&#125;</code></pre></div></figure></p><h2 id="shader-1">Shader</h2><p>和平行光类似，但步进的起点与终点可以手动计算，计算得出射线与光照范围的交点，再根据相机与场景深度是否在范围内，可以缩小光线步进的距离。</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">Sphere sphere;sphere.origin &#x3D; lightPositionWS.xyz;sphere.r &#x3D; _Range;Line viewLine;viewLine.origin &#x3D; _WorldSpaceCameraPos;viewLine.direction &#x3D; normalize(ray);#ifdef _POINT_LIGHTfloat3 nearPoint;float3 farPoint;float num &#x3D; LineToSpherePoint(viewLine, sphere, nearPoint, farPoint);clip(num - 0.5);#elsehalf4 spotDirection &#x3D; _AdditionalLightsSpotDir[perObjectLightIndex];const float halfAngle &#x3D; _SpotAngle * 0.5 * PI &#x2F; 180;float3 spotDir &#x3D; -spotDirection.xyz;Cone cone;cone.C &#x3D; lightPositionWS.xyz + spotDir * _Range * cos(halfAngle);cone.H &#x3D; lightPositionWS.xyz;cone.r &#x3D; _Range * tan(halfAngle) * cos(halfAngle);Hemisphere hemisphere;hemisphere.sphere &#x3D; sphere;hemisphere.normal &#x3D; spotDir;hemisphere.angle &#x3D; halfAngle;float3 TP1;float3 TP2;float num &#x3D; LineToConePoint(viewLine, cone, TP1, TP2);float3 P1;float3 P2;float num2 &#x3D; LineToHemispherePoint(viewLine, hemisphere, P1, P2);float sumNum &#x3D; num + num2;clip(sumNum - 0.5);float3 nearPoint &#x3D; TP1 + P1;float3 farPoint &#x3D; TP2 + P2;#endif</code></pre></div></figure><p>如果是点光源就简单一点，计算视线与球体的交点即可。</p><p>聚光灯复杂一点，要算视线与锥体侧边的交点，以及视线与一球冠（圆台）的交点。</p><p>关于直线（射线）与各种三维曲面的交点，有时间单独记录在一篇文章吧。</p><h2 id="附加光索引">附加光索引</h2><p>这里还有一点比较麻烦的是获取指定灯光的索引。<br />untiy并没有提供官方的API。但从RenderPass的renderingData.lightData.visibleLights;中可以得到一个列表。<br />这个列表的索引和实际索引顺序相同，只是前面要剔除平行光。<br />所以最后还是没能逃过写RenderFeature。</p><h2 id="render-feature">Render Feature</h2><p>这里就不赘述了，借鉴了SRP的炫光的写法，为每个要添加体积光的Light添加一个PointVolumeLight或者SpotVolumeLight。<br />用一静态列表来记录需要渲染的体积光。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public abstract class BaseVolumeLight : MonoBehaviour&#123;    public static readonly List&lt;BaseVolumeLight&gt; BaseVolumeLightList &#x3D; new();    protected virtual void OnEnable()    &#123;        Light &#x3D; GetComponent&lt;Light&gt;();        if (Light &#x3D;&#x3D; null)        &#123;            Debug.LogError(&quot;Light is null, please add a light component&quot;);            return;        &#125;        if (!LightTypeIsSupported())        &#123;            Debug.LogError(&quot;Light type is not supported&quot;);            return;        &#125;        material &#x3D; CoreUtils.CreateEngineMaterial(Shader.Find(shaderName));        GenMesh();        BaseVolumeLightList.Add(this);    &#125;    private void OnDisable()    &#123;        BaseVolumeLightList.Remove(this);        DestroyImmediate(material);        material &#x3D; null;    &#125;&#125;</code></pre></div></figure><br />这样就能在pass中获取到要渲染的对象了。</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public class SpotVolumeRenderPass : ScriptableRenderPass&#123;    private readonly ProfilingSampler m_ProfilingSampler &#x3D; ProfilingSampler.Get(VolumeRenderFeature.ProfileId.SpotVolume);    public Mesh defaultMesh &#123; get; set; &#125;    public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)    &#123;                var cmd &#x3D; CommandBufferPool.Get();        using (new ProfilingScope(cmd, m_ProfilingSampler))        &#123;            var volumeLights &#x3D; BaseVolumeLight.BaseVolumeLightList;            foreach (var volumeLight in volumeLights)            &#123;                var visibleLights &#x3D; renderingData.lightData.visibleLights;                var lightIndex &#x3D; -1;                for (int i &#x3D; 0; i &lt; visibleLights.Length; i++)                &#123;                    if (visibleLights[i].light &#x3D;&#x3D; volumeLight.Light)                    &#123;                        lightIndex &#x3D; i - 1;                    &#125;                &#125;                                if(lightIndex &#x3D;&#x3D; -1 || volumeLight.intensity &lt;&#x3D; float.Epsilon) continue;                volumeLight.lightIndex &#x3D; lightIndex;                volumeLight.UpdateIfNeed();                                var mesh  &#x3D; volumeLight.mesh? volumeLight.mesh : defaultMesh;                cmd.DrawMesh(mesh, volumeLight.matrix, volumeLight.material);            &#125;        &#125;                context.ExecuteCommandBuffer(cmd);        CommandBufferPool.Release(cmd);    &#125;        public void Dispose()    &#123;            &#125;&#125;</code></pre></div></figure><p>写都写了，把平行光也做成一个pass吧。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public class DirectionalVolumeRenderPass : ScriptableRenderPass&#123;    private readonly ProfilingSampler m_ProfilingSampler &#x3D; ProfilingSampler.Get(VolumeRenderFeature.ProfileId.DirectionalVolume);        private static readonly int Intensity &#x3D; Shader.PropertyToID(&quot;_Intensity&quot;);    private static readonly int MieK &#x3D; Shader.PropertyToID(&quot;_MieK&quot;);            private VolumetricLighting m_VolumetricLighting;    private Material m_Material;        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)    &#123;                if (m_Material &#x3D;&#x3D; null)        &#123;            Debug.LogErrorFormat(                &quot;&#123;0&#125;.Execute(): Missing material. DirectionalVolumeRenderPass pass will not execute. Check for missing reference in the renderer resources.&quot;,                GetType().Name);            return;        &#125;        var stack &#x3D; VolumeManager.instance.stack;        m_VolumetricLighting &#x3D; stack.GetComponent&lt;VolumetricLighting&gt;();        if (!m_VolumetricLighting.IsActive())            return;        m_Material.SetFloat(Intensity, m_VolumetricLighting.intensity.value);        m_Material.SetFloat(MieK, m_VolumetricLighting.mieK.value);        var cmd &#x3D; CommandBufferPool.Get();        using (new ProfilingScope(cmd, m_ProfilingSampler))        &#123;            CoreUtils.DrawFullScreen(cmd, m_Material);        &#125;                context.ExecuteCommandBuffer(cmd);        CommandBufferPool.Release(cmd);    &#125;    public bool Setup(Material material)    &#123;        m_Material &#x3D; material;        return true;    &#125;        public void Dispose()    &#123;    &#125;&#125;</code></pre></div></figure><br />这里顺便用了VolumeComponent，方便在场景中调整全局平行体积光的效果。</p><h1 id="优化与改进">优化与改进</h1><h2 id="blue-noise">Blue Noise</h2><p>之前抖动步进距离是采用的一般的shader内的随机数，但还是有一种更好更适合光线步进的噪声，BlueNoise。<br />具体这东西有多神奇请移步<ahref="http://momentsingraphics.de/BlueNoise.html">BlueNoise</a>。</p><p>可惜的是这没办法实时单帧内在GPU生成，只能预先生成然后采样，好消息是仅需64*64分辨率平铺，肉眼也很难发现重复结构，我觉得这才是BlueNoise最最神奇的地方，而且也基本发现不了有什么突出的结构。<br /><img src="BlueNoise01.png" alt="64*64平铺" /></p><p>为了搭配TAA，有两种方式，一是随时间随机抖动整体偏移一张噪声图，二是用TextureArray，随时间随机采样不同的噪声图。好在噪声图不大，即使放上64张，一共也才512<em>512。<br />为了方便使用，下面打包了一张512</em>512的包含了64张64*64的噪声图，可以方便在Untiy中直接生成TextureArray，图片来源<ahref="http://momentsingraphics.de/BlueNoise.html">图片来源</a><br /><img src="output.png" alt="512*512图集" /></p><p>只能说这个噪声太神奇了，原先平行光需要采样15次的效果，搭配TAA仅需4次。射灯原先10次采样，现在仅需3次就能有不错的效果。</p><p><img src="VLight-32.png" alt="采样32次" /><br /><img src="VLight-4.png" alt="采样4次" /></p><h2 id="可控性">可控性</h2><p>其实在日常中，很少能发现体积光的现象，一般只有在山洞，森林等光线单一且潮湿的地方才有。<br />但这种效果却在游戏中经常运用。</p><p>会过来看Shader，发现其实这里也没有多么“物理”，比如平行光就没有计算衰减，最后的归一化函数也是基于经验。<br />所以调整一下最后的归一化函数，增加几个系数，便于调整美术效果。</p><ul><li>均匀度：调整步进总量光线强度与实际显示亮度的关系</li><li>最大强度：便于调整整体的颜色和强度</li><li>距离衰减系数：是否考虑距离或角度的衰减</li><li>阴影反向衰减强度：阴影不仅不计入光线总量，反而会反向衰减现有的光线总量，会加深阴影的表现，但“不物理”。</li></ul><h2 id="升降采样与模糊">升降采样与模糊</h2><p>算最常见的优化方案了，确实体积光也没必要全分辨率渲染，而且模糊后再搭配TAA效果应该也不错，边缘也不会那么锐利。<br />这就单独再开一篇文章记录吧，打算在URP中用RenderFeature和Volume框架复刻毛星云大佬的那个模糊后处理的库。</p>]]></content>
    
    
    <categories>
      
      <category>渲染</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shader</tag>
      
      <tag>体积光</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于TMP、SDF、光线步进的体积字渲染</title>
    <link href="/2023/07/26/TMP/"/>
    <url>/2023/07/26/TMP/</url>
    
    <content type="html"><![CDATA[<h1 id="体积字">体积字</h1><p>为了方便美术去修改场景中的有体积字，在TMP基础上，用光线步进加SDF去渲染体积字。<br /><span id="more"></span><br /><img src="VTMP_13.png" alt="体积渲染" /></p><p>先贴<a href="https://zhuanlan.zhihu.com/p/42923421">参考</a></p><h1 id="mesh">Mesh</h1><p>直接改原版的TMP有点麻烦，退而求其次，在TMP构造好Mesh后，修改这个Mesh，以适应新的Shader。</p><p>原本TMP构造出的网格是一个个面片，每个字符由两个三角形拼成。</p><figure><img src="VTMP_01.png" alt="原始TMP网格" /><figcaption aria-hidden="true">原始TMP网格</figcaption></figure><p>然后以这个mesh为基础，再添加4个点，5个面，纵向拉伸成一个个立方体.</p><figure><img src="VTMP_02.png" alt="拉伸后网格" /><figcaption aria-hidden="true">拉伸后网格</figcaption></figure><p>新网格中除了保存之前的网格中的信息外，还要额外添加几个。分别是</p><ul><li>每个字符左下角顶点的坐标</li><li>每个字符右上角顶点坐标</li><li>每个字符左下角顶点的UV</li></ul><p>除了这些，整体的厚度也写入材质中去。</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public void SetMesh()&#123;    var mesh &#x3D; textMeshPro.mesh;    var newMesh &#x3D; new Mesh();    newMesh.name &#x3D; &quot;km&quot;;    var vertices &#x3D; new Vector3[mesh.vertices.Length * 2];    for (var i &#x3D; 0; i &lt; mesh.vertices.Length; i++)    &#123;        vertices[i] &#x3D; mesh.vertices[i];        vertices[i + mesh.vertices.Length] &#x3D; mesh.vertices[i] + new Vector3(0, 0, width);    &#125;    newMesh.vertices &#x3D; vertices;    var sum &#x3D; mesh.triangles.Length &#x2F; (2 * 3);        var triangles &#x3D; new int[mesh.triangles.Length * 6];        for (var i &#x3D; 0; i &lt; sum; i++)    &#123;        var s &#x3D; i * 6;        &#x2F;&#x2F; 前面        triangles[s + 0] &#x3D; mesh.triangles[s + 0];        triangles[s + 1] &#x3D; mesh.triangles[s + 1];        triangles[s + 2] &#x3D; mesh.triangles[s + 2];        triangles[s + 3] &#x3D; mesh.triangles[s + 3];        triangles[s + 4] &#x3D; mesh.triangles[s + 4];        triangles[s + 5] &#x3D; mesh.triangles[s + 5];        &#x2F;&#x2F; 后面        triangles[s + 0 + mesh.triangles.Length] &#x3D; mesh.triangles[s + 4] + mesh.vertices.Length;        triangles[s + 1 + mesh.triangles.Length] &#x3D; mesh.triangles[s + 3] + mesh.vertices.Length;        triangles[s + 2 + mesh.triangles.Length] &#x3D; mesh.triangles[s + 1] + mesh.vertices.Length;        triangles[s + 3 + mesh.triangles.Length] &#x3D; mesh.triangles[s + 1] + mesh.vertices.Length;        triangles[s + 4 + mesh.triangles.Length] &#x3D; mesh.triangles[s + 0] + mesh.vertices.Length;        triangles[s + 5 + mesh.triangles.Length] &#x3D; mesh.triangles[s + 4] + mesh.vertices.Length;        &#x2F;&#x2F; 右面        triangles[s + 0 + mesh.triangles.Length * 2] &#x3D; mesh.triangles[s + 0] + mesh.vertices.Length;        triangles[s + 1 + mesh.triangles.Length * 2] &#x3D; mesh.triangles[s + 1] + mesh.vertices.Length;        triangles[s + 2 + mesh.triangles.Length * 2] &#x3D; mesh.triangles[s + 1];        triangles[s + 3 + mesh.triangles.Length * 2] &#x3D; mesh.triangles[s + 1];        triangles[s + 4 + mesh.triangles.Length * 2] &#x3D; mesh.triangles[s + 0];        triangles[s + 5 + mesh.triangles.Length * 2] &#x3D; mesh.triangles[s + 0] + mesh.vertices.Length;        &#x2F;&#x2F; 下面        triangles[s + 0 + mesh.triangles.Length * 3] &#x3D; mesh.triangles[s + 5] + mesh.vertices.Length;        triangles[s + 1 + mesh.triangles.Length * 3] &#x3D; mesh.triangles[s + 5];        triangles[s + 2 + mesh.triangles.Length * 3] &#x3D; mesh.triangles[s + 4];        triangles[s + 3 + mesh.triangles.Length * 3] &#x3D; mesh.triangles[s + 4];        triangles[s + 4 + mesh.triangles.Length * 3] &#x3D; mesh.triangles[s + 4] + mesh.vertices.Length;        triangles[s + 5 + mesh.triangles.Length * 3] &#x3D; mesh.triangles[s + 5] + mesh.vertices.Length;        &#x2F;&#x2F; 左面        triangles[s + 0 + mesh.triangles.Length * 4] &#x3D; mesh.triangles[s + 4];        triangles[s + 1 + mesh.triangles.Length * 4] &#x3D; mesh.triangles[s + 3];        triangles[s + 2 + mesh.triangles.Length * 4] &#x3D; mesh.triangles[s + 3] + mesh.vertices.Length;        triangles[s + 3 + mesh.triangles.Length * 4] &#x3D; mesh.triangles[s + 3] + mesh.vertices.Length;        triangles[s + 4 + mesh.triangles.Length * 4] &#x3D; mesh.triangles[s + 4] + mesh.vertices.Length;        triangles[s + 5 + mesh.triangles.Length * 4] &#x3D; mesh.triangles[s + 4];        &#x2F;&#x2F; 上面        triangles[s + 0 + mesh.triangles.Length * 5] &#x3D; mesh.triangles[s + 1];        triangles[s + 1 + mesh.triangles.Length * 5] &#x3D; mesh.triangles[s + 1] + mesh.vertices.Length;        triangles[s + 2 + mesh.triangles.Length * 5] &#x3D; mesh.triangles[s + 2] + mesh.vertices.Length;        triangles[s + 3 + mesh.triangles.Length * 5] &#x3D; mesh.triangles[s + 2] + mesh.vertices.Length;        triangles[s + 4 + mesh.triangles.Length * 5] &#x3D; mesh.triangles[s + 2];        triangles[s + 5 + mesh.triangles.Length * 5] &#x3D; mesh.triangles[s + 1];    &#125;    newMesh.triangles &#x3D; triangles;    var normals &#x3D; new Vector3[mesh.normals.Length * 2];    for (var i &#x3D; 0; i &lt; mesh.normals.Length; i++)    &#123;        normals[i] &#x3D; mesh.normals[i];        normals[i + mesh.normals.Length] &#x3D; mesh.normals[i];    &#125;    newMesh.normals &#x3D; normals;    var tangents &#x3D; new Vector4[mesh.tangents.Length * 2];    for (var i &#x3D; 0; i &lt; mesh.tangents.Length; i++)    &#123;        tangents[i] &#x3D; mesh.tangents[i];        tangents[i + mesh.tangents.Length] &#x3D; mesh.tangents[i];    &#125;    newMesh.triangles &#x3D; triangles;    var colors32 &#x3D; new Color32[mesh.colors.Length * 2];    for (var i &#x3D; 0; i &lt; mesh.colors32.Length; i++)    &#123;        colors32[i] &#x3D; mesh.colors32[i];        colors32[i + mesh.colors32.Length] &#x3D; mesh.colors32[i];    &#125;    newMesh.colors32 &#x3D; colors32;    var uv &#x3D; new Vector2[mesh.uv.Length * 2];    for (var i &#x3D; 0; i &lt; mesh.uv.Length; i++)    &#123;        uv[i] &#x3D; mesh.uv[i];        uv[i + mesh.uv.Length] &#x3D; mesh.uv[i];    &#125;    newMesh.uv &#x3D; uv;    var sum2 &#x3D; newMesh.vertices.Length &#x2F; (4);    Debug.Log(sum2);    var uv3 &#x3D; new Vector2[mesh.uv.Length * 2];    var uv4 &#x3D; new Vector2[mesh.uv.Length * 2];    var uv5 &#x3D; new Vector2[mesh.uv.Length * 2];    for (int i &#x3D; 0; i &lt; sum2; i++)    &#123;        var s &#x3D; i * 4;        &#x2F;&#x2F; 左下角顶点坐标        Vector2 v &#x3D; newMesh.vertices[s + 0];        uv3[s + 0] &#x3D; v;        uv3[s + 1] &#x3D; v;        uv3[s + 2] &#x3D; v;        uv3[s + 3] &#x3D; v;        Vector2 tr &#x3D; newMesh.vertices[s + 2];        uv5[s + 0] &#x3D; tr;        uv5[s + 1] &#x3D; tr;        uv5[s + 2] &#x3D; tr;        uv5[s + 3] &#x3D; tr;        Vector2 blUV &#x3D; uv[s];        uv4[s + 0] &#x3D; blUV;        uv4[s + 1] &#x3D; blUV;        uv4[s + 2] &#x3D; blUV;        uv4[s + 3] &#x3D; blUV;    &#125;    newMesh.uv3 &#x3D; uv3;    newMesh.uv4 &#x3D; uv4;    newMesh.uv5 &#x3D; uv5;    var uv2 &#x3D; new Vector2[mesh.uv2.Length * 2];    for (var i &#x3D; 0; i &lt; mesh.uv2.Length; i++)    &#123;        uv2[i] &#x3D; mesh.uv2[i];        uv2[i + mesh.uv2.Length] &#x3D; mesh.uv2[i];    &#125;    newMesh.uv2 &#x3D; uv2;    meshFilter.mesh &#x3D; newMesh;    material.SetFloat(Width, width);&#125;</code></pre></div></figure><h1 id="shader">Shader</h1><p>网格准备好就轮到Shader了。</p><h2 id="顶点着色器">顶点着色器</h2><p>这里没什么特殊的，只要把相关的顶点属性传递到片元中就行了。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">pixel_t VertShader(vertex_t input)&#123;    pixel_t output;    UNITY_SETUP_INSTANCE_ID(input);    UNITY_TRANSFER_INSTANCE_ID(input, output);    UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);    &#x2F;&#x2F; 粗体    float bold &#x3D; step(input.texcoord0.w, 0);    &#x2F;&#x2F; 顶点偏移    float4 vert &#x3D; input.position;    float4 vPosition &#x3D; TransformObjectToHClip(vert.xyz);    float2 pixelSize &#x3D; vPosition.w;    pixelSize &#x2F;&#x3D; float2(_ScaleX, _ScaleY) * abs(mul((float2x2)UNITY_MATRIX_P, _ScreenParams.xy));    float scale &#x3D; rsqrt(dot(pixelSize, pixelSize));    scale *&#x3D; abs(input.texcoord0.w) * _GradientScale * (_Sharpness + 1);    if (UNITY_MATRIX_P[3][3] &#x3D;&#x3D; 0)        scale &#x3D; lerp(abs(scale) * (1 - _PerspectiveFilter), scale,                     abs(dot(TransformObjectToWorldNormal(input.normal.xyz),                             normalize(GetWorldSpaceViewDir(vert)))));    float weight &#x3D; lerp(_WeightNormal, _WeightBold, bold) &#x2F; 4.0;    weight &#x3D; (weight + _FaceDilate) * _ScaleRatioA * 0.5;    float bias &#x3D; (.5 - weight) + (.5 &#x2F; scale);    float alphaClip &#x3D; (1.0 - _OutlineWidth * _ScaleRatioA - _OutlineSoftness * _ScaleRatioA);    alphaClip &#x3D; alphaClip &#x2F; 2.0 - (.5 &#x2F; scale) - weight;    &#x2F;&#x2F; Support for texture tiling and offset    float2 textureUV &#x3D; input.texcoord1;    float2 faceUV &#x3D; TRANSFORM_TEX(textureUV, _FaceTex);    output.positionCS &#x3D; vPosition;    output.color &#x3D; input.color;    &#x2F;&#x2F; 字符图集上的UV    output.atlas &#x3D; input.texcoord0;    output.param &#x3D; float4(alphaClip, scale, bias, weight);    output.viewDir &#x3D; mul((float3x3)_EnvMatrix,                         _WorldSpaceCameraPos.xyz - mul(unity_ObjectToWorld, vert).xyz);    output.textures &#x3D; float4(faceUV, 0, 0);    output.positionWS &#x3D; TransformObjectToWorld(vert.xyz).xyz;    output.bltr &#x3D; float4(input.texcoord2.xy, input.texcoord4.xy);    output.bluv &#x3D; input.texcoord3;    return output;&#125;</code></pre></div></figure></p><h2 id="光线步进">光线步进</h2><p>然后就开始光线步进吧。<br />从片元的表面出发，沿视线方向，以步进到的位置采样SDF图。<br />如果超出了当前字符方块的范围，就Clip掉。否则就一直步进，直至进入字符SDF内部或者迭代次数耗尽。</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float3 posWS &#x3D; input.positionWS.xyz;float3 posBLOS &#x3D; float3(input.bltr.xy, 0);float3 posTROS &#x3D; float3(input.bltr.zw, _width);float2 blUV &#x3D; input.bluv.xy;float3 normal;float3 currentPos &#x3D; posWS;float3 currentPosOS &#x3D; TransformWorldToObject(currentPos);;float3 viewDir &#x3D; -normalize(input.viewDir);float dis &#x3D; GetDisFromPos(currentPosOS, posBLOS, blUV);if (dis &lt; 0)&#123;    if (currentPosOS.z &lt; 0.01)        normal &#x3D; float3(0, 0, -1);    else        normal &#x3D; float3(0, 0, 1);&#125;else&#123;    for (int i &#x3D; 0; i &lt; 20; i++)    &#123;        if (!isIn(posBLOS, posTROS, currentPosOS))        &#123;            clip(-1);        &#125;        dis &#x3D; GetDisFromPos(currentPosOS, posBLOS, blUV);        if (dis &lt; 0)        &#123;            break;        &#125;        currentPos +&#x3D; viewDir * dis * 0.3;        currentPosOS &#x3D; TransformWorldToObject(currentPos);;    &#125;    normal &#x3D; float3(normalize(GetNormalFromUV(GetUVFromPos(currentPosOS, posBLOS, blUV))), 0);&#125;</code></pre></div></figure><p>第一次迭代中如果是前后表面就不需要步进了。</p><figure><img src="VTMP_03.png" alt="基础形状" /><figcaption aria-hidden="true">基础形状</figcaption></figure><h2 id="法线">法线</h2><p>前后面法线很简单，侧面法线就用SDF图的梯度来计算<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float2 GetNormalFromUV(float2 uv)&#123;    float2 normal &#x3D; float2(0, 0);    float2 uv1 &#x3D; uv + float2(0, 1) &#x2F; 512;    float2 uv2 &#x3D; uv + float2(0, -1) &#x2F; 512;    float2 uv3 &#x3D; uv + float2(1, 0) &#x2F; 512;    float2 uv4 &#x3D; uv + float2(-1, 0) &#x2F; 512;    float4 c1 &#x3D; tex2D(_MainTex, uv1);    float4 c2 &#x3D; tex2D(_MainTex, uv2);    float4 c3 &#x3D; tex2D(_MainTex, uv3);    float4 c4 &#x3D; tex2D(_MainTex, uv4);    normal.y &#x3D; c2.a - c1.a;    normal.x &#x3D; c4.a - c3.a;    return normal;&#125;</code></pre></div></figure></p><figure><img src="VTMP_04.png" alt="法线" /><figcaption aria-hidden="true">法线</figcaption></figure><h2 id="深度偏移">深度偏移</h2><p>要通过SV_Depth来设定偏移后的深度<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float4 PixShader(pixel_t input, out float outDepth : SV_Depth) : SV_Target    float deviceDepth &#x3D; ComputeNormalizedDeviceCoordinatesWithZ(currentPos, GetWorldToHClipMatrix()).z;    #ifndef  UNITY_UV_STARTS_AT_TOP    deviceDepth &#x3D; (deviceDepth +1 )&#x2F;2;    #endif    outDepth &#x3D; deviceDepth;</code></pre></div></figure><br />这里有个大坑，在OpenGL下，深度要从-1，1映射到0，1</p><figure><img src="VTMP_05.png" alt="深度偏移" /><figcaption aria-hidden="true">深度偏移</figcaption></figure><h2 id="着色">着色</h2><p>这里就用LIT的PBR来着色<br />UV先简单用物体空间的XY。</p><figure><img src="VTMP_06.png" alt="PBR着色" /><figcaption aria-hidden="true">PBR着色</figcaption></figure><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float2 uv &#x3D; currentPos.xy * 1;SurfaceData surfaceData;InitializeStandardLitSurfaceData(uv, surfaceData);InputData inputData;float3 normalWS &#x3D; TransformObjectToWorldNormal(normal);input.positionWS &#x3D; currentPos;InitializeInputData(input, normalWS, inputData);half4 color &#x3D; UniversalFragmentPBR(inputData, surfaceData);return color;</code></pre></div></figure><h2 id="三向映射">三向映射</h2><p>侧面也需要UV，所以用法线作为权重，每个轴的坐标作为UV采样三次后混合</p><figure><img src="VTMP_07.png" alt="三向映射" /><figcaption aria-hidden="true">三向映射</figcaption></figure><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">half3 blendWeights &#x3D; pow (abs(normal), 3);blendWeights &#x3D; blendWeights &#x2F; (blendWeights.x + blendWeights.y + blendWeights.z);half2 xUV &#x3D; pos.zy &#x2F; 1;half2 yUV &#x3D; pos.xz &#x2F; 1;half2 zUV &#x3D; pos.xy &#x2F; 1;half4 albedoAlphaX &#x3D; SampleAlbedoAlpha(xUV, TEXTURE2D_ARGS(_BaseMap, sampler_BaseMap));half4 albedoAlphaY &#x3D; SampleAlbedoAlpha(yUV, TEXTURE2D_ARGS(_BaseMap, sampler_BaseMap));half4 albedoAlphaZ &#x3D; SampleAlbedoAlpha(zUV, TEXTURE2D_ARGS(_BaseMap, sampler_BaseMap));</code></pre></div></figure><h2 id="阴影">阴影</h2><p>增加一个ShadowCaster Pass来投射阴影。</p><figure><img src="VTMP_08.png" alt="三向映射" /><figcaption aria-hidden="true">三向映射</figcaption></figure><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">Pass&#123;    Name &quot;ShadowCaster&quot;    Tags    &#123;        &quot;LightMode&quot; &#x3D; &quot;ShadowCaster&quot;    &#125;    ZWrite On    ZTest LEqual    ColorMask 0    HLSLPROGRAM    #pragma target 3.0    #pragma vertex VertShader    #pragma fragment PixShadowCaster    #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;    #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;Shaders&#x2F;LitInput.hlsl&quot;    #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Lighting.hlsl&quot;    #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Shadows.hlsl&quot;    #include &quot;TMPro_Properties.hlsl&quot;    #include &quot;SDF.hlsl&quot;    ENDHLSL&#125;</code></pre></div></figure><p>这里的步进方向记得改为从主光源的方向来步进，同时不要忘记应用阴影偏移。<br />同样最后要用SV_Depth来偏移深度。</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float3 viewDir &#x3D; -normalize(_LightDirection);currentPos &#x3D; ApplyShadowBias(currentPos, normal, _LightDirection);</code></pre></div></figure><p>也别忘记在前向Pass中增加接收阴影的宏</p><figure><div class="code-wrapper"><pre class="language-none"><code class="language-none">        #pragma multi_compile _ _MAIN_LIGHT_SHADOWS _MAIN_LIGHT_SHADOWS_CASCADE _MAIN_LIGHT_SHADOWS_SCREEN</code></pre></div></figure><h2 id="屏幕空间ao">屏幕空间AO</h2><p>有了上面的代码，增加一个DepthNormalsPass就可以给SSAO提供法线和深度了。<br />这里参数调整的很大以看出区别。<br /><img src="VTMP_09.png" alt="SSAO" /></p><figure><img src="VTMP_10.png" alt="SSAO" /><figcaption aria-hidden="true">SSAO</figcaption></figure><h2 id="抗锯齿">抗锯齿</h2><p>因为没有网格，所以MSAA肯定是不行。直接就用URP的TAA了，效果还可以。<br />或者就添加圆角。</p><h2 id="倒角">倒角</h2><p>有点麻烦<br />先从倒角开始，倒一个面。基本思路就是在计算SDF时，在需要倒角切除的部分，手动增加一个距离。</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float GetDisFromPos(float3 posOS, float3 posBLWS, float2 blUV)&#123;    float2 UV &#x3D; GetUVFromPos(posOS, posBLWS, blUV);    float dis &#x3D; 1 - tex2D(_MainTex, UV).a * 2;        if(dis &lt; -0.1 )    &#123;        return 0;    &#125;        float v &#x3D;  abs(((posOS.z &#x2F; _width) - 0.5) * 2);    v &#x3D; (clamp( v, 0.9, 1) - 0.9)*10;    dis +&#x3D; v * 0.1;    return dis;&#125;</code></pre></div></figure><p>然后是法线，这就简单了，lerp一下就行了<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float3 BlenderNormal(float3 normal,float3 posOS)&#123;    float v &#x3D;  abs(((posOS.z &#x2F; _width) - 0.5) * 2);    v &#x3D; step(0.9, v);    float vv &#x3D; sign(((posOS.z &#x2F; _width) - 0.5) );    float3 nn &#x3D; normalize(float3(0,0,vv));    float3 fN &#x3D; normalize(nn + normal);    return lerp(normal,fN,v);&#125;</code></pre></div></figure></p><figure><img src="VTMP_11.png" alt="倒角" /><figcaption aria-hidden="true">倒角</figcaption></figure><h2 id="圆角">圆角</h2><p>然后是圆角。<br />参考<a href="https://zhuanlan.zhihu.com/p/42923421">这篇文章</a></p><p>关键是其中这个圆角矩形的SDF</p><figure><img src="VTMP_12.png" alt="圆角" /><figcaption aria-hidden="true">圆角</figcaption></figure><h2 id="改进">改进</h2><ul><li>可以仿照TMP，增加对应的外轮廓，下划线，斜体等等</li><li>UV贴图也可以改进，分成侧面和正反面两种UV，适配两种不同的材质。</li><li>法线的获取，目前是在Shader中采样四个点去计算，可以预先根据SDF图去生成对应的法线图，直接采样。</li></ul><h2 id="局限">局限</h2><p>因为没有常规的UV，所以没有办法烘焙光照，也不能给其他静态物体提供静态的光照。<br />但既然要用体积字，应该都是有运行时更改且动态的需求，所以一般不会用来烘焙。<br />如果需要那种字体侧面发光的效果，可以在后面放一个TMP，做成透明渐变来模拟泛光。</p><p>摄像机不能进入字符立方体内部，否则就要渲染反面且从近平面开始步进，得不偿失。</p>]]></content>
    
    
    <categories>
      
      <category>渲染</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDF</tag>
      
      <tag>光线步进</tag>
      
      <tag>体积字</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RThandle</title>
    <link href="/2023/07/20/RThandle/"/>
    <url>/2023/07/20/RThandle/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>SRP的接口一直在更改，是时候仔细看看RTHandle系统了。<br /><span id="more"></span><br />看RTHandle之前，先看看RenderTexture。</p><p>基本的理解就是RT数据是保存在GPU上的，RT仅仅是CPU这里对其管理的一个工具。<br />而Texture的数据才是能直接在CPU读取的，使用时会加载到显存中。</p><p>而RTHandle又是干啥的？</p><h1 id="rthandle-system">RTHandle system</h1><p>通篇看下来，最主要的目的就是为了处理不同RT的分辨率问题。</p><p>假使有多个相机要渲染不同的分辨率，那就要为各个RT分配不同分辨率的RT。而临时RT仅能在分辨率和属性完全相同的情况下复用，所以总体的内存使用量是全部各种分辨率的内存总和。<br />所以RTHandle system应运而生，这使得在不同分辨率的相机之间复用RT变得简单。<br />不再固定分辨率分配纹理，而是用给定的全屏分辨率相关的比例来分配</p><h1 id="具体使用">具体使用</h1><p>具体的用法上，不再像之前每帧去取一个TMPRT，而是用RTHandles.Alloc来让RTHandlesystem分配一个。<br />为了解决分辨率动态修改的问题，SRP还提供了一些工具函数，比如<code>RenderingUtils.ReAllocateIfNeeded</code>这里根据是否已经分配和是否分辨率等参数需要修改，来重新分配一个RTHandle。这个一般在OnCameraSetup中调用。</p><p>如果要设置渲染目标，就调用<code>CoreUtils.SetRenderTarget</code>。<br />设置全局或局部纹理，就普通的<code>cmd.SetGlobalTexture</code>就好。<br />最后不要忘记<code>Release()</code>释放</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RThandle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AnalyzeHDRPLit</title>
    <link href="/2023/07/03/AnalyzeHDRPLit/"/>
    <url>/2023/07/03/AnalyzeHDRPLit/</url>
    
    <content type="html"><![CDATA[<h1 id="lit">Lit</h1><p>在改动Lit之前有必要详细的逐行分析一下Lit的Shader<br />虽然类似的文章已经有了，但还是选择自己手敲一遍以加深印象。<br />版本是14.0.8</p><h1 id="common.hlsl">Common.hlsl</h1><p>路径 core/ShaderLibrary/Common.hlsl<br />untiy为SRP单独抽象出了一个库，com.unity.render-pipelines.core，包含了很多基础的渲染代码，同时被URP和HDRP使用。</p><h2 id="约定">约定</h2><p>首先就规定了一些惯例<br />坐标系:</p><ul><li>世界坐标系：Yup左手</li><li>当从世界空间到视图空间时，视图空间中的单位为右手，矩阵的行列式为负</li><li>对于立方体贴图采样（反射探针），视图空间仍然是左手（立方体贴图约定）并且行列式为正。</li><li>单位：一米</li></ul><p>然后是变量的后缀的约定</p><ul><li>WS：世界</li><li>RWS：相机相关的世界</li><li>VS：视角</li><li>OS：物体</li><li>CS：齐次裁切</li><li>TS：切线</li><li>TXS：贴图</li></ul><p>默认向量都是归一化的，非归一化用un前缀</p><p>用大写字母表示常见向量，向量总是指向像素外部。<br />大写字母也意味着归一化，除非有un的前缀</p><ul><li>V：视角</li><li>L：光线</li><li>N：法线</li><li>H：半程</li></ul><p>输入输出的结构体用帕斯卡命名，前缀表示类型<br />如 AttributesDefault VaryingsDefault<br />当使用这些结构体时，用input/output作为变量名</p><p>常量浮点写作1.0 不是1，1.0f，1.0h<br />全局变量uniform 使用_前缀，大写，然后驼峰 _LowercaseThenCamelCase</p><p>不要使用in，仅使用out或inout关键字，也不要使用inline<br />当声明out参数时，放到最后</p><p>其他shader库不应包含common.hlsl，应放在.shader文件中。</p><p>所以全局变量应放在常量缓冲区中。</p><p>在C#与hlsl中共享结构定义。<br />结构要基于float4对齐。<br />定义数组时，总是使用float4<br />不要使用 SetGlobalFloatArray 或 SetComputeFloatParams</p><p>这个库中的函数都是无状态的，即没有全局声明。<br />需要显式声明精度的可以使用float与half，同时支持两者的，可以使用real。</p><h2 id="real">real</h2><p>这里就是依据定义的宏来确定是real的精度，大致看下来在移动端以及switch上，默认会启用half精度。当然可以手动指定REAL_IS_HALF为1。</p><h2 id="宏定义">宏定义</h2><p>这里定义了一些方便使用的宏<br />#define SV_POSITION_QUALIFIERS<br />#define DEPTH_OFFSET_SEMANTIC SV_Depth</p><p>然后依据宏选择对应的api<br />PC就对应了D3D11.hlsl，大致包含了一些采样贴图的方式，等会再回过头来看看这个文件吧<br />接下来包含了Macros.hlsl与Random.hlsl，顾名思义，前者是主要是一些常量和一些模板方法，后者就是随机数了。</p><p>然后是Vulkan支持的Native Renderpass。这里先跳过。</p><p>然后是为了支持光追定义的宏<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">#if (SHADER_STAGE_RAY_TRACING &amp;&amp; UNITY_RAY_TRACING_GLOBAL_RESOURCES)    #define GLOBAL_RESOURCE(type, name, reg) type name : register(reg, space1);    #define GLOBAL_CBUFFER_START(name, reg) cbuffer name : register(reg, space1) &#123;#else    #define GLOBAL_RESOURCE(type, name, reg) type name;    #define GLOBAL_CBUFFER_START(name, reg) CBUFFER_START(name)#endif</code></pre></div></figure></p><h2 id="工具函数">工具函数</h2><p>再往下就是存储的工具函数了。、</p><ul><li>数学函数，如remap01，min，max，HasFlag等。</li><li>采样贴图</li><li>深度相关</li><li>还包含了一个PositionInputs的结构体，</li><li>并实现了一系列空间变换相关的函数。</li></ul><h1 id="d3d.hlsl">D3D.hlsl</h1><p>路径 core/ShaderLibrary/API/D3D.hlsl</p><p>是放到API中的，同级别的还有PSSL、Switch、Vulkan等等。所以可以猜出应该类似与接口一样，实现Unity常见的特定于平台的函数。</p><h2 id="常量">常量</h2><p>首先是用宏定义了一些常量。<br />如下<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">#define UNITY_UV_STARTS_AT_TOP 1#define UNITY_REVERSED_Z 1#define UNITY_NEAR_CLIP_VALUE (1.0)&#x2F;&#x2F; This value will not go through any matrix projection conversion#define UNITY_RAW_FAR_CLIP_VALUE (0.0)#define VERTEXID_SEMANTIC SV_VertexID#define INSTANCEID_SEMANTIC SV_InstanceID#define FRONT_FACE_SEMANTIC SV_IsFrontFace#define FRONT_FACE_TYPE bool#define IS_FRONT_VFACE(VAL, FRONT, BACK) ((VAL) ? (FRONT) : (BACK))</code></pre></div></figure><br />都可以通过名称来看出含义。</p><h2 id="支持的特性">支持的特性</h2><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">#define PLATFORM_SUPPORTS_EXPLICIT_BINDING#define PLATFORM_NEEDS_UNORM_UAV_SPECIFIER#define PLATFORM_SUPPORTS_BUFFER_ATOMICS_IN_PIXEL_SHADER#define PLATFORM_SUPPORTS_PRIMITIVE_ID_IN_PIXEL_SHADER</code></pre></div></figure><h2 id="采样贴图">采样贴图</h2><p>这里就顺便看下各种采样的区别吧<br />Sample 采样<br />SampleLevel 指定mipmap级别<br />SampleBias 输入mipmap偏差<br />SampleGrad 用梯度来选择mip级别<br />SampleCmpLevelZero 采样后与0比较<br />以及<br />Load 仅加载，即不寻址不过滤，使用指定的lod<br />Gather 收集周围4个像素的R通道</p><h1 id="shadervariables.hlsl">ShaderVariables.hlsl</h1><p>主要是定义一个名为UnityPerDraw的CBuffer。包含了和材质相关的一些全局变量，如球谐函数参数，renderBox，光照贴图参数，渲染层等等和材质相关的。</p><p>还顺便声明了一系列常用的采样器。</p><p>再往下就是贴图的声明，如深度，光照，阴影，ProbeVolume。</p><p>这里还改了SAMPLE_TEXTURE2D与SAMPLE_TEXTURE2D_BIAS的宏，全局应用_GlobalMipBias</p><p>然后是采样这些贴图的工具函数 如SampleCameraDepth、SampleCameraColor等<br />接着还是一些关于相机矩阵位置等参数的工具函数，如GetRawUnityObjectToWorld、GetCameraPositionWS等等。</p><h1 id="texturexr.hlsl">TextureXR.hlsl</h1><p>顾名思义，是为了XR的单通道渲染定义的一系列在XR中采样贴图的宏</p><h1id="shadervariablesglobal.cs.hlsl">ShaderVariablesGlobal.cs.hlsl</h1><p>这是一个由cs代码来自动生成的库文件。<br />单纯用来定义了一些全局变量，如_ViewMatrix、_ScreenSize、_Time等和材质无关的属性。<br />由此可以取看看ShaderVariablesGlobal.cs，通过cs代码来生成hlsl在HDRP中很常见。</p><h2 id="shadervariablesglobal.cs">ShaderVariablesGlobal.cs</h2><p>这个文件主要就是定义了一个结构体，其内容和hlsl中的cbuffer一模一样，值得注意的是这里的参数的排布应用了float4对齐。</p><h1 id="fraginputs.hlsl">FragInputs.hlsl</h1><p>一个结构体FragInputs，片元的输入，但这并不是Vert或者Frag的输出和输入，因为unity在传输时会打包再解包。</p><h1 id="litproperties.cs">LitProperties.cs</h1><p>和材质相关的属性，各种贴图与参数</p><h1 id="lightloopdef.hlsl">LightLoopDef.hlsl</h1><p>光照计算相关的定义</p><h1 id="lit.hlsl">Lit.hlsl</h1><p>PBR BSDF相关的计算</p><h1 id="lightloop.hlsl">LightLoop.hlsl</h1><p>?计算全部光源并汇总？</p><h1 id="varyingmesh.hlsl">VaryingMesh.hlsl</h1><p>顶点与片元的输入与输出，也包含了打包与解包相关函数。</p><h1 id="litdata.hlsl">LitData.hlsl</h1><p>???</p><h1 id="shaderpassforward.hlsl">ShaderPassForward.hlsl</h1><p>这里定义了前向渲染的顶点和片元着色器函数Vert与Frag。</p><h2 id="vert">Vert</h2><p>这里倒是意外的简单，常规的坐标变换，打包输出到片元着色器。</p><h1 id="frag">Frag</h1><p>头大的来了。<br />一行一行看！！！</p><h2 id="函数输入输出">函数输入输出</h2><p>输入就是从顶点打包过来的。<br />这里根据几个宏来判断是否需要多Target输出，<br />共有虚拟纹理，分光？，运动向量，深度偏移。这些都先不考虑，只看outColor。</p><figure><div class="code-wrapper"><pre class="language-none"><code class="language-none">FragInputs input = UnpackVaryingsToFragInputs(packedInput);</code></pre></div></figure><p>解包数据<br />AdjustFragInputsToOffScreenRendering(input, _OffScreenRendering &gt; 0,_OffScreenDownsampleFactor);<br />离屏渲染？？目前没有搞明白有什么作用，大致看起来是用来处理低分辨率的。<br />uint2 tileIndex = uint2(input.positionSS.xy) / GetTileSize();<br />获取像素网格坐标int<br />PositionInputs posInput = GetPositionInput(input.positionSS.xy,_ScreenSize.zw, input.positionSS.z, input.positionSS.w,input.positionRWS.xyz, tileIndex);<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">struct PositionInputs&#123;    float3 positionWS;  &#x2F;&#x2F; World space position (could be camera-relative)    float2 positionNDC; &#x2F;&#x2F; Normalized screen coordinates within the viewport    : [0, 1) (with the half-pixel offset)    uint2  positionSS;  &#x2F;&#x2F; Screen space pixel coordinates                       : [0, NumPixels)    uint2  tileCoord;   &#x2F;&#x2F; Screen tile coordinates                              : [0, NumTiles)    float  deviceDepth; &#x2F;&#x2F; Depth from the depth buffer                          : [0, 1] (typically reversed)    float  linearDepth; &#x2F;&#x2F; View space Z coordinate                              : [Near, Far]&#125;;</code></pre></div></figure><br />获取一系列各种空间下的坐标</p><figure><div class="code-wrapper"><pre class="language-none"><code class="language-none">float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);</code></pre></div></figure><p>计算视线<br />SurfaceData surfaceData;<br />BuiltinData builtinData;<br />GetSurfaceAndBuiltinData(input, V, posInput, surfaceData,builtinData);<br />这里就为之后的光照计算准备数据了，来源就是采样各个贴图或者预先计算。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">struct SurfaceData&#123;    uint materialFeatures;    real3 baseColor;    real specularOcclusion;    float3 normalWS;    real perceptualSmoothness;    real ambientOcclusion;    real metallic;    real coatMask;    real3 specularColor;    uint diffusionProfileHash;    real subsurfaceMask;    real transmissionMask;    real thickness;    float3 tangentWS;    real anisotropy;    real iridescenceThickness;    real iridescenceMask;    real3 geomNormalWS;    real ior;    real3 transmittanceColor;    real atDistance;    real transmittanceMask;&#125;;struct BuiltinData&#123;    real opacity;    real alphaClipTreshold;    real3 bakeDiffuseLighting;    real3 backBakeDiffuseLighting;    real shadowMask0;    real shadowMask1;    real shadowMask2;    real shadowMask3;    real3 emissiveColor;    real2 motionVector;    real2 distortion;    real distortionBlur;    uint isLightmap;    uint renderingLayers;    float depthOffset;    #if defined(UNITY_VIRTUAL_TEXTURING)    real4 vtPackedFeedback;    #endif&#125;;</code></pre></div></figure></p><p>看结构体就能知道这里函数的作用是什么了。</p><p>那就开看看这个函数</p><h2 id="双面法线">双面法线</h2><p>前面的和LodFade相关的先略过。<br />先看看和双面法线相关的<br />float3 doubleSidedConstants = GetDoubleSidedConstants();</p><figure><div class="code-wrapper"><pre class="language-none"><code class="language-none">ApplyDoubleSidedFlipOrMirror(input, doubleSidedConstants);</code></pre></div></figure><p>对应材质中的Mirror和Flip。定义了反面法线的朝向。<br />这里法线存在了input.tangentToWorld[2]中。</p><h2 id="uv">UV</h2><figure><div class="code-wrapper"><pre class="language-none"><code class="language-none">LayerTexCoord layerTexCoord;ZERO_INITIALIZE(LayerTexCoord, layerTexCoord);GetLayerTexCoord(input, layerTexCoord);</code></pre></div></figure><p>预处理UV。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">struct LayerTexCoord&#123;#ifndef LAYERED_LIT_SHADER    UVMapping base;    UVMapping details;#else    &#x2F;&#x2F; Regular texcoord    UVMapping base0;    UVMapping base1;    UVMapping base2;    UVMapping base3;    UVMapping details0;    UVMapping details1;    UVMapping details2;    UVMapping details3;    &#x2F;&#x2F; Dedicated for blend mask    UVMapping blendMask;#endif    &#x2F;&#x2F; Store information that will be share by all UVMapping    float3 vertexNormalWS; &#x2F;&#x2F; TODO: store also object normal map for object triplanar    float3 triplanarWeights;#ifdef SURFACE_GRADIENT    &#x2F;&#x2F; tangent basis for each UVSet - up to 4 for now    float3 vertexTangentWS0, vertexBitangentWS0;    float3 vertexTangentWS1, vertexBitangentWS1;    float3 vertexTangentWS2, vertexBitangentWS2;    float3 vertexTangentWS3, vertexBitangentWS3;#endif&#125;;struct UVMapping&#123;    int mappingType;    float2 uv;  &#x2F;&#x2F; Current uv or planar uv    &#x2F;&#x2F; Triplanar specific    float2 uvZY;    float2 uvXZ;    float2 uvXY;    float3 normalWS; &#x2F;&#x2F; vertex normal    float3 triplanarWeights;#ifdef SURFACE_GRADIENT    &#x2F;&#x2F; tangent basis to use when mappingType is UV_MAPPING_UVSET    &#x2F;&#x2F; these are vertex level in world space    float3 tangentWS;    float3 bitangentWS;    &#x2F;&#x2F; TODO: store also object normal map for object triplanar#endif&#125;;</code></pre></div></figure><br />LAYERED_LIT_SHADER 是分层，先略过。<br />所以共有两种UVMapping，base与details。<br />这也就要求相关的贴图的UV分布要一致。<br />观察UVMapping能看出这里还考虑了三平面映射UV。</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">void GetLayerTexCoord(FragInputs input, inout LayerTexCoord layerTexCoord)&#123;#ifdef SURFACE_GRADIENT    GenerateLayerTexCoordBasisTB(input, layerTexCoord);#endif    GetLayerTexCoord(   input.texCoord0.xy, input.texCoord1.xy, input.texCoord2.xy, input.texCoord3.xy,                        input.positionRWS, input.tangentToWorld[2].xyz, layerTexCoord);&#125;</code></pre></div></figure><p>GenerateLayerTexCoordBasisTB用来计算切线空间<br />GetLayerTexCoord用来生成对应的UVMapping</p><h2 id="高度图">高度图</h2><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">#if !defined(SHADER_STAGE_RAY_TRACING)    float depthOffset &#x3D; ApplyPerPixelDisplacement(input, V, layerTexCoord);    #ifdef _DEPTHOFFSET_ON    ApplyDepthOffsetPositionInput(V, depthOffset, GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);    #endif#else    float depthOffset &#x3D; 0.0;#endif</code></pre></div></figure><p>深度图相关，包含了深度偏移。</p><h2 id="透明度裁切">透明度裁切</h2><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">#if defined(_ALPHATEST_ON)    float alphaTex &#x3D; SAMPLE_UVMAPPING_TEXTURE2D(_BaseColorMap, sampler_BaseColorMap, layerTexCoord.base).a;    alphaTex &#x3D; lerp(_AlphaRemapMin, _AlphaRemapMax, alphaTex);    float alphaValue &#x3D; alphaTex * _BaseColor.a;    &#x2F;&#x2F; Perform alha test very early to save performance (a killed pixel will not sample textures)    #if SHADERPASS &#x3D;&#x3D; SHADERPASS_TRANSPARENT_DEPTH_PREPASS    float alphaCutoff &#x3D; _AlphaCutoffPrepass;    #elif SHADERPASS &#x3D;&#x3D; SHADERPASS_TRANSPARENT_DEPTH_POSTPASS    float alphaCutoff &#x3D; _AlphaCutoffPostpass;    #elif (SHADERPASS &#x3D;&#x3D; SHADERPASS_SHADOWS) || (SHADERPASS &#x3D;&#x3D; SHADERPASS_RAYTRACING_VISIBILITY)    float alphaCutoff &#x3D; _UseShadowThreshold ? _AlphaCutoffShadow : _AlphaCutoff;    #else    float alphaCutoff &#x3D; _AlphaCutoff;    #endif    GENERIC_ALPHA_TEST(alphaValue, alphaCutoff);#endif</code></pre></div></figure><p>不是重点先略过</p><h2 id="surfacedata">SurfaceData</h2><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float3 normalTS;float3 bentNormalTS;float3 bentNormalWS;float alpha &#x3D; GetSurfaceData(input, layerTexCoord, surfaceData, normalTS, bentNormalTS);&#x2F;&#x2F; This need to be init here to quiet the compiler in case of decal, but can be override later.surfaceData.geomNormalWS &#x3D; input.tangentToWorld[2];surfaceData.specularOcclusion &#x3D; 1.0;</code></pre></div></figure><p>来看看GetSurfaceData这个函数<br />主要就是采样各种贴图，获取SurfaceData。</p><h2 id="贴花">贴花</h2><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">#if HAVE_DECALS &amp;&amp; (defined(DECAL_SURFACE_GRADIENT) &amp;&amp; defined(SURFACE_GRADIENT))    if (_EnableDecals)    &#123;        DecalSurfaceData decalSurfaceData &#x3D; GetDecalSurfaceData(posInput, input, alpha);        ApplyDecalToSurfaceData(decalSurfaceData, input.tangentToWorld[2], surfaceData, normalTS);    &#125;#endif</code></pre></div></figure><p>也先略过吧。</p><h2 id="次法线">次法线</h2><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">#ifdef _BENTNORMALMAP    GetNormalWS(input, bentNormalTS, bentNormalWS, doubleSidedConstants);#else    bentNormalWS &#x3D; surfaceData.normalWS;#endif</code></pre></div></figure><p>获取次法线</p><h2 id="高光遮挡">高光遮挡</h2><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">#if defined(_SPECULAR_OCCLUSION_FROM_BENT_NORMAL_MAP)    &#x2F;&#x2F; If we have bent normal and ambient occlusion, process a specular occlusion    surfaceData.specularOcclusion &#x3D; GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));    &#x2F;&#x2F; Don&#39;t do spec occ from Ambient if there is no mask mask#elif defined(_MASKMAP) &amp;&amp; !defined(_SPECULAR_OCCLUSION_NONE)    surfaceData.specularOcclusion &#x3D; GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));#endif</code></pre></div></figure><p>如果启用了次法线贴图的镜面遮挡，就修改specularOcclusion属性。</p><h2 id="几何高光aa">几何高光AA</h2><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">#if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) &amp;&amp; !defined(SHADER_STAGE_RAY_TRACING)    &#x2F;&#x2F; Specular AA    #ifdef PROJECTED_SPACE_NDF_FILTERING    surfaceData.perceptualSmoothness &#x3D; ProjectedSpaceGeometricNormalFiltering(surfaceData.perceptualSmoothness, input.tangentToWorld[2], _SpecularAAScreenSpaceVariance, _SpecularAAThreshold);    #else    surfaceData.perceptualSmoothness &#x3D; GeometricNormalFiltering(surfaceData.perceptualSmoothness, input.tangentToWorld[2], _SpecularAAScreenSpaceVariance, _SpecularAAThreshold);    #endif#endif</code></pre></div></figure><p>用来处理几何锐角附近的高光锯齿，是通过修改光滑度来实现的，看来这一步可以预先在SP等贴图软件中提前处理，能节省一些性能。</p><h2 id="builtindata">BuiltinData</h2><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">GetBuiltinData(input, V, posInput, surfaceData, alpha, bentNormalWS, depthOffset, layerTexCoord.base, builtinData);</code></pre></div></figure><p>SurfaceDatas是和表面相关的属性，和材质相关。BuiltinData则是和环境相关，如全局光、阴影、透明度裁切阙值等。</p><p>GI有三种方式，光照贴图，球谐函数，还是新退出的用3D贴图来采样的球谐函数。</p><h2 id="postinitbuiltindata">PostInitBuiltinData</h2><p>然后是最后的修改，<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">ModifyBakedDiffuseLighting(V, posInput, surfaceData, builtinData);float multiplier &#x3D; GetIndirectDiffuseMultiplier(builtinData.renderingLayers);builtinData.bakeDiffuseLighting *&#x3D; multiplier;</code></pre></div></figure><br />都是对GI的修改。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">void ModifyBakedDiffuseLighting(float3 V, PositionInputs posInput, SurfaceData surfaceData, inout BuiltinData builtinData)&#123;    &#x2F;&#x2F; Since this is called early at PostInitBuiltinData and we need some fields from bsdfData and preLightData,    &#x2F;&#x2F; we get the whole structures redundantly earlier here - compiler should optimize out everything.    BSDFData bsdfData &#x3D; ConvertSurfaceDataToBSDFData(posInput.positionSS, surfaceData);    PreLightData preLightData &#x3D; GetPreLightData(V, posInput, bsdfData);    ModifyBakedDiffuseLighting(V, posInput, preLightData, bsdfData, builtinData);&#125;</code></pre></div></figure><br />又出现了两个结构体<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">struct BSDFData&#123;    uint materialFeatures;    real3 diffuseColor;    real3 fresnel0;    real ambientOcclusion;    real specularOcclusion;    float3 normalWS;    real perceptualRoughness;    real coatMask;    uint diffusionProfileIndex;    real subsurfaceMask;    real thickness;    bool useThickObjectMode;    real3 transmittance;    float3 tangentWS;    float3 bitangentWS;    real roughnessT;    real roughnessB;    real anisotropy;    real iridescenceThickness;    real iridescenceMask;    real coatRoughness;    real3 geomNormalWS;    real ior;    real3 absorptionCoefficient;    real transmittanceMask;&#125;;struct PreLightData&#123;    float NdotV;                     &#x2F;&#x2F; Could be negative due to normal mapping, use ClampNdotV()    &#x2F;&#x2F; GGX    float partLambdaV;    float energyCompensation;    &#x2F;&#x2F; IBL    float3 iblR;                     &#x2F;&#x2F; Reflected specular direction, used for IBL in EvaluateBSDF_Env()    float  iblPerceptualRoughness;    float3 specularFGD;              &#x2F;&#x2F; Store preintegrated BSDF for both specular and diffuse    float  diffuseFGD;    &#x2F;&#x2F; Area lights (17 VGPRs)    &#x2F;&#x2F; TODO: &#39;orthoBasisViewNormal&#39; is just a rotation around the normal and should thus be just 1x VGPR.    float3x3 orthoBasisViewNormal;   &#x2F;&#x2F; Right-handed view-dependent orthogonal basis around the normal (6x VGPRs)    float3x3 ltcTransformDiffuse;    &#x2F;&#x2F; Inverse transformation for Lambertian or Disney Diffuse        (4x VGPRs)    float3x3 ltcTransformSpecular;   &#x2F;&#x2F; Inverse transformation for GGX                                 (4x VGPRs)    &#x2F;&#x2F; Clear coat    float    coatPartLambdaV;    float3   coatIblR;    float    coatIblF;               &#x2F;&#x2F; Fresnel term for view vector    float    coatReflectionWeight;   &#x2F;&#x2F; like reflectionHierarchyWeight but used to distinguish coat contribution between SSR&#x2F;IBL lighting    float3x3 ltcTransformCoat;       &#x2F;&#x2F; Inverse transformation for GGX                                 (4x VGPRs)#if HAS_REFRACTION    &#x2F;&#x2F; Refraction    float3 transparentRefractV;      &#x2F;&#x2F; refracted view vector after exiting the shape    float3 transparentPositionWS;    &#x2F;&#x2F; start of the refracted ray after exiting the shape    float3 transparentTransmittance; &#x2F;&#x2F; transmittance due to absorption    float transparentSSMipLevel;     &#x2F;&#x2F; mip level of the screen space gaussian pyramid for rough refraction#endif&#125;;</code></pre></div></figure><br />前者是针对BSDF所需的全部参数的汇总，后者就是光源相关的属性。</p><p>来看看这两个结构体的获取</p><h1 id="convertsurfacedatatobsdfdata">ConvertSurfaceDataToBSDFData</h1><p>也是顾名思义，填充一些bsdf相关的属性。<br />如ao，高光，粗糙，金属，菲涅尔等等。</p><p>这里还根据材质需求的功能的不同，如是否需要SSS，曲面细分，各向异性，虹彩，清漆来填充不同的属性。</p><h1 id="getprelightdata">GetPreLightData</h1><p>同样的，根据不同的材质，会有针对性的修改，比如为了虹彩和清漆会修改菲涅尔，</p><p>这里对于面光源，环境照明，的参数是从一张预处理的贴图中采样的：GetPreIntegratedFGDGGXAndDisneyDiffuse<br />还有一些奇怪的属性energyCompensation、面光源相关等等，等用到时再回过头来看吧。</p><h1 id="lightloopoutput">LightLoopOutput</h1><p>获取完大部分的属性后终于来到了光照计算<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">struct LightLoopOutput&#123;    float3 diffuseLighting;    float3 specularLighting;&#125;;</code></pre></div></figure><br />输出很直接漫反射和高光。</p><h1 id="lightloopcontext">LightLoopContext</h1><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl"> struct LightLoopContext&#123;    int sampleReflection;#ifdef APPLY_FOG_ON_SKY_REFLECTIONS    float3 positionWS; &#x2F;&#x2F; For sky reflection, we need position to evalute height base fog#endif    HDShadowContext shadowContext;    uint contactShadow;         &#x2F;&#x2F; a bit mask of 24 bits that tell if the pixel is in a contact shadow or not    real contactShadowFade;     &#x2F;&#x2F; combined fade factor of all contact shadows    SHADOW_TYPE shadowValue;    &#x2F;&#x2F; Stores the value of the cascade shadow map    real splineVisibility;      &#x2F;&#x2F; Stores the value of the cascade shadow map (unbiased for splines)&#125;;struct HDShadowContext&#123;    StructuredBuffer&lt;HDShadowData&gt;  shadowDatas;    HDDirectionalShadowData         directionalShadowData;&#125;;struct HDShadowData&#123;    float3 rot0;    float3 rot1;    float3 rot2;    float3 pos;    float4 proj;    float2 atlasOffset;    float worldTexelSize;    float normalBias;    real4 zBufferParam;    float4 shadowMapSize;    float4 shadowFilterParams0;    float3 cacheTranslationDelta;    float isInCachedAtlas;    float4x4 shadowToWorld;&#125;;struct HDDirectionalShadowData&#123;    float4 sphereCascades[4];    real4 cascadeDirection;    real cascadeBorders[4];&#125;;</code></pre></div></figure><p>一层套一层<br />大部分都是定义的阴影<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">StructuredBuffer&lt;HDShadowData&gt;              _HDShadowDatas;&#x2F;&#x2F; Only the first element is used since we only support one directional lightStructuredBuffer&lt;HDDirectionalShadowData&gt;   _HDDirectionalShadowData;HDShadowContext InitShadowContext()&#123;    HDShadowContext         sc;    sc.shadowDatas &#x3D; _HDShadowDatas;    sc.directionalShadowData &#x3D; _HDDirectionalShadowData[0];    return sc;&#125;</code></pre></div></figure><br />结构体的值是整个获取的。</p><figure><div class="code-wrapper"><pre class="line-numbers language-hls" data-language="hls"><code class="language-hls">ApplyCameraRelativeXR(posInput.positionWS);&#x2F;&#x2F; Initialize the contactShadow and contactShadowFade fieldsInitContactShadow(posInput, context);</code></pre></div></figure><p>适配XR中的摄像机相关世界坐标。<br />获取级联阴影参数。</p><h2 id="平行光阴影">平行光阴影</h2><figure><div class="code-wrapper"><pre class="language-none"><code class="language-none">        DirectionalLightData light = _DirectionalLightDatas[_DirectionalShadowIndex];</code></pre></div></figure><p>获取平行光数据<br />float3 L = -light.forward;<br />方向<br />然后就是采样阴影贴图。结果存到shadowValue中。</p><h2 id="点光附加光直接">点光、附加光直接</h2><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">struct AggregateLighting&#123;    DirectLighting   direct;    IndirectLighting indirect;&#125;;</code></pre></div></figure><p>这里其实存的是全部附加光照的总和。</p><p>遍历全部的附加光<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">        while (v_lightListOffset &lt; lightCount)#endif        &#123;            v_lightIdx &#x3D; FetchIndex(lightStart, v_lightListOffset);#if SCALARIZE_LIGHT_LOOP            uint s_lightIdx &#x3D; ScalarizeElementIndex(v_lightIdx, fastPath);#else            uint s_lightIdx &#x3D; v_lightIdx;#endif            if (s_lightIdx &#x3D;&#x3D; -1)                break;            LightData s_lightData &#x3D; FetchLight(s_lightIdx);            &#x2F;&#x2F; If current scalar and vector light index match, we process the light. The v_lightListOffset for current thread is increased.            &#x2F;&#x2F; Note that the following should really be &#x3D;&#x3D;, however, since helper lanes are not considered by WaveActiveMin, such helper lanes could            &#x2F;&#x2F; end up with a unique v_lightIdx value that is smaller than s_lightIdx hence being stuck in a loop. All the active lanes will not have this problem.            if (s_lightIdx &gt;&#x3D; v_lightIdx)            &#123;                v_lightListOffset++;                if (IsMatchingLightLayer(s_lightData.lightLayers, builtinData.renderingLayers))                &#123;                    DirectLighting lighting &#x3D; EvaluateBSDF_Punctual(context, V, posInput, preLightData, s_lightData, bsdfData, builtinData);                    AccumulateDirectLighting(lighting, aggregateLighting);                &#125;            &#125;        &#125;</code></pre></div></figure></p><p>遍历完累加到一起。</p><h2 id="平行光直接">平行光直接</h2><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">uint i &#x3D; 0; &#x2F;&#x2F; Declare once to avoid the D3D11 compiler warning.if (featureFlags &amp; LIGHTFEATUREFLAGS_DIRECTIONAL)&#123;    for (i &#x3D; 0; i &lt; _DirectionalLightCount; ++i)    &#123;        if (IsMatchingLightLayer(_DirectionalLightDatas[i].lightLayers, builtinData.renderingLayers))        &#123;            DirectLighting lighting &#x3D; EvaluateBSDF_Directional(context, V, posInput, preLightData, _DirectionalLightDatas[i], bsdfData, builtinData);            AccumulateDirectLighting(lighting, aggregateLighting);        &#125;    &#125;&#125;</code></pre></div></figure><p>循环计算全部的平行光的直接照明</p><h2 id="面光源直接">面光源直接</h2><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">#if SHADEROPTIONS_AREA_LIGHTS    if (featureFlags &amp; LIGHTFEATUREFLAGS_AREA)    &#123;        uint lightCount, lightStart;    #ifndef LIGHTLOOP_DISABLE_TILE_AND_CLUSTER        GetCountAndStart(posInput, LIGHTCATEGORY_AREA, lightStart, lightCount);    #else        lightCount &#x3D; _AreaLightCount;        lightStart &#x3D; _PunctualLightCount;    #endif        &#x2F;&#x2F; COMPILER BEHAVIOR WARNING!        &#x2F;&#x2F; If rectangle lights are before line lights, the compiler will duplicate light matrices in VGPR because they are used differently between the two types of lights.        &#x2F;&#x2F; By keeping line lights first we avoid this behavior and save substantial register pressure.        &#x2F;&#x2F; TODO: This is based on the current Lit.shader and can be different for any other way of implementing area lights, how to be generic and ensure performance ?        if (lightCount &gt; 0)        &#123;            i &#x3D; 0;            uint      last      &#x3D; lightCount - 1;            LightData lightData &#x3D; FetchLight(lightStart, i);            while (i &lt;&#x3D; last &amp;&amp; lightData.lightType &#x3D;&#x3D; GPULIGHTTYPE_TUBE)            &#123;                lightData.lightType &#x3D; GPULIGHTTYPE_TUBE; &#x2F;&#x2F; Enforce constant propagation                lightData.cookieMode &#x3D; COOKIEMODE_NONE;  &#x2F;&#x2F; Enforce constant propagation                if (IsMatchingLightLayer(lightData.lightLayers, builtinData.renderingLayers))                &#123;                    DirectLighting lighting &#x3D; EvaluateBSDF_Area(context, V, posInput, preLightData, lightData, bsdfData, builtinData);                    AccumulateDirectLighting(lighting, aggregateLighting);                &#125;                lightData &#x3D; FetchLight(lightStart, min(++i, last));            &#125;            while (i &lt;&#x3D; last) &#x2F;&#x2F; GPULIGHTTYPE_RECTANGLE            &#123;                lightData.lightType &#x3D; GPULIGHTTYPE_RECTANGLE; &#x2F;&#x2F; Enforce constant propagation                if (IsMatchingLightLayer(lightData.lightLayers, builtinData.renderingLayers))                &#123;                    DirectLighting lighting &#x3D; EvaluateBSDF_Area(context, V, posInput, preLightData, lightData, bsdfData, builtinData);                    AccumulateDirectLighting(lighting, aggregateLighting);                &#125;                lightData &#x3D; FetchLight(lightStart, min(++i, last));            &#125;        &#125;    &#125;#endif</code></pre></div></figure><p>面光源，先略过吧</p><h1 id="直接光照">直接光照</h1><p>可以看出直接光照都是在类似<br />DirectLighting lighting = EvaluateBSDF_Directional(context, V, posInput,preLightData, _DirectionalLightDatas[i], bsdfData, builtinData);<br />这之类的函数中计算的<br />然后累加起来，所以这里来看看这个函数<br />ShadeSurface_Directional</p><p>EvaluateLight_Directional<br />处理雾气和大气相关，修改light颜色</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">SHADOW_TYPE shadow &#x3D; EvaluateShadow_Directional(lightLoopContext, posInput, light, builtinData, GetNormalForShadowBias(bsdfData));float NdotL  &#x3D; dot(bsdfData.normalWS, L); &#x2F;&#x2F; No microshadowing when facing away from light (use for thin transmission as well)shadow *&#x3D; NdotL &gt;&#x3D; 0.0 ? ComputeMicroShadowing(GetAmbientOcclusionForMicroShadowing(bsdfData), NdotL, _MicroShadowOpacity) : 1.0;lightColor.rgb *&#x3D; ComputeShadowColor(shadow, light.shadowTint, light.penumbraTint);</code></pre></div></figure><p>计算阴影</p><p>ShadeSurface_Infinitesimal<br />处理反射与投射</p><p>EvaluateBSDF<br />到这一步才用到了BSDF函数</p><h1 id="总结">总结</h1><p>为了之后的理解，还是按照HDRP的文件和函数分类结构，在URP中把URP的Lit重写一遍，最终目的是在URP中使用HDRP的Lit。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>URP-Lit-BRDF简析</title>
    <link href="/2023/06/27/URP-Lit-BRDF/"/>
    <url>/2023/06/27/URP-Lit-BRDF/</url>
    
    <content type="html"><![CDATA[<h1 id="前述">前述</h1><p>之前理清了lit包含的各个文件之间的联系，现在再回过头仔细看看到底它用的BRDF是什么。<br /><span id="more"></span><br />最终颜色分为两类<br />实时光与间接光</p><h1 id="实时光">实时光</h1><p>指平行光或者点光源等</p><h2 id="反射率方程">反射率方程</h2><p>先来看主光源的反射率方程</p><p><code>half NdotL = saturate(dot(normalWS, lightDirectionWS));</code><br />计算cosTheta<br /><code>half3 radiance = lightColor * (lightAttenuation * NdotL);</code><br />因为是平行光，仅计算一个方向，所以就简单的相乘即可<br /><code>half3 brdf = brdfData.diffuse;</code><br /><code>brdf += brdfData.specular * DirectBRDFSpecular(brdfData, normalWS, lightDirectionWS, viewDirectionWS);</code><br />然后就是BRDF了，分为两部分，漫反射与高光。</p><h3 id="实时光漫反射">实时光漫反射</h3><p>回过头看看漫反射怎么取的<br /><code>InitializeBRDFData(surfaceData.albedo, surfaceData.metallic, surfaceData.smoothness, brdfData);</code><br />输入仅有取自表面的反照率，金属，光滑</p><p><code>half oneMinusReflectivity = OneMinusReflectivityMetallic(metallic);</code></p><p>这里用到了一个魔法数 标准介电反射率系数 (= 4%)<br />OneMinusReflectivityMetallic 可以理解为吸收率？对应与learnopengl的PBR那篇文章中的 被折射 的比例kd。<br />一减去反射率 = 1-reflectivity = 1-lerp(dielectricSpec, 1, metallic) =lerp(1-dielectricSpec, 0, metallic)。<br />理解为金属的反射率为1，非金属的反射率为0.04</p><p><code>half reflectivity = half(1.0) - oneMinusReflectivity;</code></p><p>取反射率</p><p><code>half3 brdfDiffuse = albedo * oneMinusReflectivity;</code></p><p>从贴图的albedo乘以吸收率得到Diffuse，即最终漫反射的颜色。这里就是Lambertian漫反射的公式了。又被称为完全漫反射即漫反射的方向与角度无关。</p><h3 id="实时光高光">实时光高光</h3><p><code>half3 brdfSpecular = lerp(kDieletricSpec.rgb, albedo, metallic);</code><br />这里就是高光的颜色了，指即使是非金属，也会有0.04的反射高光，而金属的反射颜色就取自albedo。</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">outBRDFData.perceptualRoughness &#x3D; PerceptualSmoothnessToPerceptualRoughness(smoothness);outBRDFData.roughness           &#x3D; max(PerceptualRoughnessToRoughness(outBRDFData.perceptualRoughness), HALF_MIN_SQRT);outBRDFData.roughness2          &#x3D; max(outBRDFData.roughness * outBRDFData.roughness, HALF_MIN);outBRDFData.grazingTerm         &#x3D; saturate(smoothness + reflectivity);outBRDFData.normalizationTerm   &#x3D; outBRDFData.roughness * half(4.0) + half(2.0);outBRDFData.roughness2MinusOne  &#x3D; outBRDFData.roughness2 - half(1.0);</code></pre></div></figure><p>最后这里是为了之后的计算方便，提前计算了很多变量。<br />逐行看<br />perceptualRoughness 计算感知粗糙度（这个名字很奇怪）1-smoothness。<br />然后是真正使用的粗糙度<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">real PerceptualRoughnessToRoughness(real perceptualRoughness)&#123;    return perceptualRoughness * perceptualRoughness;&#125;</code></pre></div></figure><br />并不理解为什么这里要刻意降低粗糙度。</p><p>下面都是没有具体含义的仅为了优化计算的项了。</p><p>回到反射率方程</p><p>可以看到漫反射是贴图的albedo乘以吸收率得到Diffuse，吸收率仅与金属度相关。所以光滑度不影响漫反射。</p><p>然后brdfSpecular高光颜色近似理解为albedo * metallic。</p><h3 id="brdf">BRDF</h3><p>然后终于到了熟悉的Cook-TorranceBRDF的镜面反射部分了。即D，F与G函数。</p><ul><li>法线分布函数：估算在受到表面粗糙度的影响下，朝向方向与半程向量一致的微平面的数量。</li><li>几何函数、可见性：描述了微平面自成阴影的属性。当一个平面相对比较粗糙的时候，平面表面上的微平面有可能挡住其他的微平面从而减少表面所反射的光线。</li><li>菲涅尔方程：菲涅尔方程描述的是在不同的表面角下表面所反射的光线所占的比率。</li></ul><p>而具体的DFG函数采用哪一种，不同的引擎和管线有不同的选择。看看Untiy的URPLit用的是哪一种吧<br />Unity的注射中将F函数命名为V即可见性。</p><p>D采用的是GGX。即D = roughness^2 / ( NoH^2 * (roughness^2 - 1) + 1)^2。</p><p>但是F与G就采用了一种近似的优化方程。<br />V * F = 1.0 / ( LoH^2 * (roughness + 0.5) )<br />来源https://community.arm.com/events/1155</p><h1 id="间接光">间接光</h1><p>实时光看完了<br />再来看看环境光相关。</p><h2 id="间接光漫反射">间接光漫反射</h2><p>环境光照的漫反射直接取Lightmap或者SH 也是用的完全漫反射<br /><code>half3 indirectDiffuse = bakedGI;</code></p><h2 id="间接光镜面反射">间接光镜面反射</h2><p>环境光照的镜面反射颜色要根据反射向量，粗糙度，屏幕UV计算<br /><code>half3 indirectSpecular = GlossyEnvironmentReflection(reflectVector, positionWS, brdfData.perceptualRoughness, 1.0h, normalizedScreenSpaceUV);</code></p><p><code>half mip = PerceptualRoughnessToMipmapLevel(perceptualRoughness);</code><br />从粗糙的映射出一个mip等级</p><p><code>half4 encodedIrradiance = half4(SAMPLE_TEXTURECUBE_LOD(unity_SpecCube0, samplerunity_SpecCube0, reflectVector, mip));</code></p><p><code>irradiance = DecodeHDREnvironment(encodedIrradiance, unity_SpecCube0_HDR);</code><br />然后用反射向量采用采样</p><p><code>return irradiance * occlusion;</code><br />最后还要计算遮蔽</p><p><code>half3 c = indirectDiffuse * brdfData.diffuse;</code></p><figure><div class="code-wrapper"><pre class="language-none"><code class="language-none">这里看到indirectDiffuse仅包含了光照的强度</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">    half3 EnvironmentBRDFSpecular(BRDFData brdfData, half fresnelTerm)&#123;    float surfaceReduction &#x3D; 1.0 &#x2F; (brdfData.roughness2 + 1.0);    return half3(surfaceReduction * lerp(brdfData.specular, brdfData.grazingTerm, fresnelTerm));&#125;</code></pre></div></figure><p>依据粗糙度和菲涅尔调整高光。</p><h1 id="总结">总结</h1><p>URP的lit为了性能做了很多优化，BRDF也是用的简化的版本。看来有必要去看看HDRP中的Lit的实现了。</p>]]></content>
    
    
    <categories>
      
      <category>渲染</category>
      
    </categories>
    
    
    <tags>
      
      <tag>URP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>着色器变体</title>
    <link href="/2023/06/15/ShaderVariants/"/>
    <url>/2023/06/15/ShaderVariants/</url>
    
    <content type="html"><![CDATA[<h1 id="着色器变体">着色器变体</h1><p>汇总一下shader变体相关的内容<br /><span id="more"></span></p><h1 id="为什么要变体">为什么要变体</h1><p>最根本的原因是因为着色器在运行时产生分支的开销太大，有必要为了不同的条件产生不同的shader，减轻GPU的压力，用空间换时间。<br />主要是有以下几个目的</p><ul><li>可以将同一着色器分配给不同的材质，然后为不同的材质配置不同的关键字，就可以做到在同一个地方维护代码，提高复用性。</li><li>可以在运行时通过开关关键字改变着色器行为。</li><li>利用变体禁用不必要的逻辑，优化运行效率，如没有法线贴图，那就没必要再去采用一次。</li><li>开关一些特定功能，如光照贴图等等</li></ul><p>例如URP的lit就包含了一大堆关键字<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">&#x2F;&#x2F; -------------------------------------&#x2F;&#x2F; Material Keywords#pragma shader_feature_local _NORMALMAP#pragma shader_feature_local _PARALLAXMAP#pragma shader_feature_local _RECEIVE_SHADOWS_OFF#pragma shader_feature_local _ _DETAIL_MULX2 _DETAIL_SCALED#pragma shader_feature_local_fragment _SURFACE_TYPE_TRANSPARENT#pragma shader_feature_local_fragment _ALPHATEST_ON#pragma shader_feature_local_fragment _ _ALPHAPREMULTIPLY_ON _ALPHAMODULATE_ON#pragma shader_feature_local_fragment _EMISSION#pragma shader_feature_local_fragment _METALLICSPECGLOSSMAP#pragma shader_feature_local_fragment _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A#pragma shader_feature_local_fragment _OCCLUSIONMAP#pragma shader_feature_local_fragment _SPECULARHIGHLIGHTS_OFF#pragma shader_feature_local_fragment _ENVIRONMENTREFLECTIONS_OFF#pragma shader_feature_local_fragment _SPECULAR_SETUP&#x2F;&#x2F; -------------------------------------&#x2F;&#x2F; Universal Pipeline keywords#pragma multi_compile _ _MAIN_LIGHT_SHADOWS _MAIN_LIGHT_SHADOWS_CASCADE _MAIN_LIGHT_SHADOWS_SCREEN#pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS#pragma multi_compile _ EVALUATE_SH_MIXED EVALUATE_SH_VERTEX#pragma multi_compile_fragment _ _ADDITIONAL_LIGHT_SHADOWS#pragma multi_compile_fragment _ _REFLECTION_PROBE_BLENDING#pragma multi_compile_fragment _ _REFLECTION_PROBE_BOX_PROJECTION#pragma multi_compile_fragment _ _SHADOWS_SOFT#pragma multi_compile_fragment _ _SCREEN_SPACE_OCCLUSION#pragma multi_compile_fragment _ _DBUFFER_MRT1 _DBUFFER_MRT2 _DBUFFER_MRT3#pragma multi_compile_fragment _ _LIGHT_LAYERS#pragma multi_compile_fragment _ _LIGHT_COOKIES#pragma multi_compile _ _FORWARD_PLUS#include_with_pragmas &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;RenderingLayers.hlsl&quot;&#x2F;&#x2F; -------------------------------------&#x2F;&#x2F; Unity defined keywords#pragma multi_compile _ LIGHTMAP_SHADOW_MIXING#pragma multi_compile _ SHADOWS_SHADOWMASK#pragma multi_compile _ DIRLIGHTMAP_COMBINED#pragma multi_compile _ LIGHTMAP_ON#pragma multi_compile _ DYNAMICLIGHTMAP_ON#pragma multi_compile_fragment _ LOD_FADE_CROSSFADE#pragma multi_compile_fog#pragma multi_compile_fragment _ DEBUG_DISPLAY</code></pre></div></figure></p><h1 id="指令">指令</h1><p>一般有4个</p><ul><li>multi_compile</li><li>shader_feature<br />区别下文再详细描述</li></ul><h1 id="启用与禁用">启用与禁用</h1><ul><li>Shader.EnableKeyword：启用全局关键字（静态方法）</li><li>Shader.DisableKeyword：禁用全局关键字（静态方法）</li><li>CommandBuffer.EnableShaderKeyword：使用 CommandBuffer来启用全局关键字</li><li>CommandBuffer.DisableShaderKeyword：使用 CommandBuffer来禁用全局关键字</li><li>Material.EnableKeyword：为常规着色器启用本地关键字</li><li>Material.DisableKeyword：为常规着色器禁用本地关键字</li><li>ComputeShader.EnableKeyword：为计算着色器启用本地关键字</li><li>ComputeShader.DisableKeyword：为计算着色器禁用本地关键字</li></ul><h1 id="其他条件判断">其他条件判断</h1><h2 id="静态分支">静态分支</h2><p>编译时判断。<br />使用如用#if、#elif、#else和#endif预处理器指令，或#ifdef和#ifndef等，在编译时就确定的条件。<br />不影响性能。</p><h2 id="动态分支">动态分支</h2><p>运行时判断。<br />可以使用关键字来作为动态分支的条件。<br />也可以单纯使用if来创建。</p><h2 id="变体">变体</h2><p>根据条件来编译成多个着色器变体，在运行时选择与条件匹配的着色器程序。</p><h1 id="关键字">关键字</h1><p>可以不声明而直接使用关键字。但这样就不会产生对应的变体。</p><h2 id="关键字集">关键字集</h2><p>一组关键字合称为关键字集。不同的关键字集合组合起来就会产生数量相乘的组合变体。</p><h2 id="声明">声明</h2><p>声明时可以选择是用于变体还是动态分支。</p><ul><li>dynamic branch ： 用于动态分支</li><li>multi compile ： 创建一组变体</li><li>shader feature ： 如果不启用就不会生成对应的变体</li></ul><p>后两者顾名思义，前者是多重编译，即要为每种组合生成变体，而后者仅是开关着色器功能，如果编辑时不开启，那运行时也不会有。</p><h2 id="范围">范围</h2><p>除了上面的编译时的区别，还有范围的区别。有局部和全局的差别。<br />这决定了是否可以在运行时通过全局着色器关键字来重写。<br />默认是全局，但如果指定了局部，那就无非通过全局的方式来修改。<br />具体是添加“_local”</p><h2 id="阶段">阶段</h2><p>有以下几个阶段</p><ul><li>_vertex</li><li>_fragment</li><li>_hull</li><li>_domain</li><li>_geometry</li><li>_raytracing</li></ul><p>可以指定变体生成的阶段，顶点还是片元。<br />虽然unity会自动判别，假如如果一个变体仅在片元中生效，那会自动删除重复的顶点着色器，但这会浪费编译时间，所以最好顺手设定一下。</p><h2 id="用关键字来作为条件">用关键字来作为条件</h2><p>假使有如下代码<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">#pragma multi_compile QUALITY_LOW QUALITY_MED QUALITY_HIGHif (QUALITY_LOW)&#123;    &#x2F;&#x2F; code for low quality setting&#125;</code></pre></div></figure><br />如果这里改用dynamic_branch，那unity其实是为每个关键字创建了一个布尔变量，要求GPU去动态的判断。<br />而如果是shader_feature or multi_compile，则会依据当前的关键字状态，将对应的变体发送到GPU。</p><h2 id="其他语句">其他语句</h2><p>除了if，还可以使用如下的hlsl语句</p><ul><li>#if, #elif, #else and #endif.</li><li>#ifdef and #ifndef.<br />使用这些的话会导致以后更改#pragma更加困难，如更难将multi_compile 更改为shader_feature。（存疑，没有体会到）</li></ul><h1 id="为禁用关键字创建变体">为禁用关键字创建变体</h1><p>如果使用shaderfeature创建单关键字，那在禁用后还是会自动创建第二个启用的变体。即类似默认添加_。<br />而如果使用multi_compile创建单关键字，不声明则不会自动创建。</p><p>但如果是在使用multi_compile或者shader_feature创建两个或以上的关键字组，则可以在之前声明”_“，即为禁用全部关键字时创建一个变体。</p><p>shader_feature 如没有添加”_“，默认取第一个关键字，添加后则默认为空。手动在mat中启用其他非默认的关键字，之前的默认关键字还是会生成变体。</p><p>这里规则相当的绕，牵涉各种特殊情况，又和shader中的skip unusedshader_feature有关，建议还是通过查看shader文件的变体文件来确认最终有多少和那些变体。</p><h1 id="快捷方式">快捷方式</h1><p>untiy定义了一些快捷指令，以方便开关某些具体的功能，如点光源阴影，雾气，GPU实例化等等。</p><h1 id="配合材质窗口">配合材质窗口</h1><p>可以通过在Properties中使用Toggle、ToggleOff或者KeywordEnum等来方便的控制。</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shader</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>URP下的视差遮蔽映射（带像素偏移）</title>
    <link href="/2023/06/15/ParallaxMapping/"/>
    <url>/2023/06/15/ParallaxMapping/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>之前之所以要重写一遍URP的lit，其实主要目的就是为了这里能实现真正的带深度偏移的陡峭视差映射。<br /><span id="more"></span><br />URP自带的视差映射只是最最基本的用射线方向和高度去做偏移，只能在高度不高时有一点效果，要想更高一点的高度，只能像HDRP一样，分层用类似光线步进的方式去采样。</p><h1 id="高度图">高度图</h1><p>高度图可以有多种使用方式，最简单的就是用来变化顶点，但需要模型面数很高。<br />或者曲面细分后位移顶点，对GPU就有要求了。<br />还可以在像素级别实现。<br />通过偏移UV，来模拟高度。URP自身的高度图就是这样的，但URP没有支持像素深度位移。<br />即仅仅偏移了UV，但像素的深度没有改变，会导致看起来物体悬空。HDRP则实现了这一功能。</p><p>先来看看URP默认的高度图是怎么做的吧。<br />主要是这个函数<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">ApplyPerPixelDisplacement(viewDirTS, input.uv);</code></pre></div></figure></p><p>这里传入一个切线空间中的视线方向，以及UV，然后偏移这个UV，后续都采用偏移的UV来采样贴图。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">uv +&#x3D; ParallaxMapping(TEXTURE2D_ARGS(_ParallaxMap, sampler_ParallaxMap), viewDirTS, _Parallax, uv);</code></pre></div></figure></p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">half2 ParallaxOffset1Step(half height, half amplitude, half3 viewDirTS)&#123;    &#x2F;&#x2F; 应用缩放， 范围是[-amplitude&#x2F;2, amplitude&#x2F;2]    height &#x3D; height * amplitude - amplitude &#x2F; 2.0;    half3 v &#x3D; normalize(viewDirTS);    &#x2F;&#x2F; 魔法数0.42    v.z +&#x3D; 0.42;    &#x2F;&#x2F; v.xy &#x2F; v.z 反映出了视角方向的倾斜程度，倾斜程度越大，偏移越大    &#x2F;&#x2F; 如果视角方向和法线方向平行，那么偏移为0    return height * (v.xy &#x2F; v.z);&#125;</code></pre></div></figure><p>这里的采样高度是最简单的一种方式，单纯用原点向视线方向偏移的方式，采样一次即可。<br />具体效果如下</p><p><img src="ParallaxMappingSimple.gif" alt="简单视差映射" /><br />在缩放比例较小时效果还可以，稍微增大一些就不如下面提到的方法了。</p><h2 id="陡峭视差映射">陡峭视差映射</h2><p>主要参考自<ahref="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/05%20Parallax%20Mapping/">LearnOpenGL</a><br />具体的原理也不复杂，参看原文吧，下面给出Unity中的实现<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float2 ParallaxMapping2(Texture2D heightMap, SamplerState sampler_heightMap, half3 viewDir, half heightScale,                        float2 texCoords, float numLayers,float2 noiseUV,float _HeightMin, float _HeightMax)&#123;    &#x2F;&#x2F;每层深度    float layerDepth &#x3D; 1.0 &#x2F; numLayers;    &#x2F;&#x2F; 当前层级深度    float currentLayerDepth &#x3D; 0.0;    &#x2F;&#x2F;视点方向UV偏移总量    float2 P &#x3D; viewDir.xy &#x2F; (viewDir.z) * heightScale&#x2F;10;    &#x2F;&#x2F;每层高度UV偏移量    float2 deltaTexCoords &#x3D; P &#x2F; numLayers;    &#x2F;&#x2F;当前 UV    float2 currentTexCoords &#x3D; texCoords;    float currentDepthMapValue &#x3D; 1 - GetHeight(heightMap, sampler_heightMap, currentTexCoords,_HeightMin,_HeightMax);    &#x2F;&#x2F; 层高小于采样点高度，继续采样，直至采样点高度小于层高    for (int i &#x3D; 1; i &lt; 200 &amp;&amp; currentLayerDepth &lt; currentDepthMapValue; i++)    &#123;        &#x2F;&#x2F; 按高度层级进行 UV 偏移        currentTexCoords -&#x3D; deltaTexCoords;        &#x2F;&#x2F; 从高度贴图采样获取的高度        currentDepthMapValue &#x3D; 1 - GetHeight(heightMap, sampler_heightMap, currentTexCoords,_HeightMin,_HeightMax);        &#x2F;&#x2F; currentDepthMapValue &#x3D; 1 - getHeight(currentTexCoords);        &#x2F;&#x2F; 层高增加        currentLayerDepth +&#x3D; layerDepth;    &#125;    return (currentTexCoords - texCoords);&#125;</code></pre></div></figure><br />这就最简单的仅分层的视差映射了，当层数足够时，效果还可以，但如果层数太低，就会有分层的感觉，也算是光线步进的通病了。<br /><img src="ParallaxMapping02.gif" alt="陡峭视差映射" /></p><h1 id="视差遮蔽映射">视差遮蔽映射</h1><p>再然后就是对上述方式的改进，不是单纯用一个点来确定高度，而是用一个范围然后线性插值来得到，<br />改动如下<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float2 ParallaxMapping2(Texture2D heightMap, SamplerState sampler_heightMap, half3 viewDir, half heightScale,                        float2 texCoords, float numLayers,float2 noiseUV,float _HeightMin, float _HeightMax)&#123;    &#x2F;&#x2F;每层深度    float layerDepth &#x3D; 1.0 &#x2F; numLayers;    &#x2F;&#x2F; 当前层级深度    float currentLayerDepth &#x3D; 0.0;    &#x2F;&#x2F;视点方向UV偏移总量    float2 P &#x3D; viewDir.xy &#x2F; (viewDir.z) * heightScale&#x2F;10;    &#x2F;&#x2F;每层高度UV偏移量    float2 deltaTexCoords &#x3D; P &#x2F; numLayers;    &#x2F;&#x2F;当前 UV    float2 currentTexCoords &#x3D; texCoords;    float currentDepthMapValue &#x3D; 1 - GetHeight(heightMap, sampler_heightMap, currentTexCoords,_HeightMin,_HeightMax);    float2 prevTexCoords &#x3D; currentTexCoords;    float prevDepthMapValue &#x3D; currentDepthMapValue;    float preLayerDepth &#x3D; currentLayerDepth;    &#x2F;&#x2F; [UNITY_LOOP]    &#x2F;&#x2F; 层高小于采样点高度，继续采样，直至采样点高度小于层高    for (int i &#x3D; 1; i &lt; 200 &amp;&amp; currentLayerDepth &lt; currentDepthMapValue; i++)    &#123;        prevTexCoords &#x3D; currentTexCoords;        prevDepthMapValue &#x3D; currentDepthMapValue;        preLayerDepth &#x3D; currentLayerDepth;        &#x2F;&#x2F; 按高度层级进行 UV 偏移        currentTexCoords -&#x3D; deltaTexCoords;        &#x2F;&#x2F; 从高度贴图采样获取的高度        currentDepthMapValue &#x3D; 1 - GetHeight(heightMap, sampler_heightMap, currentTexCoords,_HeightMin,_HeightMax);        &#x2F;&#x2F; currentDepthMapValue &#x3D; 1 - getHeight(currentTexCoords);        &#x2F;&#x2F; 层高增加        currentLayerDepth +&#x3D; layerDepth;    &#125;    &#x2F;&#x2F; return (currentTexCoords - texCoords);    float prevDifference &#x3D; preLayerDepth - prevDepthMapValue;    float difference &#x3D; currentDepthMapValue - currentLayerDepth;    float t &#x3D; prevDifference &#x2F; (prevDifference + difference);    return lerp(prevTexCoords, currentTexCoords, t) - texCoords;&#125;</code></pre></div></figure></p><p><img src="ParallaxMapping03.gif" alt="视差遮蔽映射" /><br />能看出比之前要好上不少，尤其是相同层数的情况下，分层感少了很多，但还是有。</p><h1 id="再加上抖动">再加上抖动</h1><p>这个做法来自<ahref="https://zhuanlan.zhihu.com/p/458069534">这里</a>，采用屏幕空间的随机噪声，来抖动采样层数。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float noise(float2 uv,float FrameId)&#123;    uv +&#x3D; FrameId * (float2(47.0f,17.0f) * 0.695f);    const float3 magic &#x3D; float3(0.06711056f, 0.00583715f, 52.9829189f);    return frac(magic.z * frac(dot(uv, magic.xy)));&#125;    float minLayers &#x3D; 10;    float maxLayers &#x3D; numLayers;    maxLayers &#x3D; maxLayers * 0.5f + maxLayers * noise(noiseUV,_Time.y);    float adaptive &#x3D; abs(dot(viewDir, float3(0, 0, 1)));    numLayers &#x3D; lerp(minLayers, maxLayers, adaptive);</code></pre></div></figure></p><p><img src="ParallaxMapping04.gif" alt="加上抖动" /><br />可能在有TAA的情况下效果会不错，但目前URP还没有（2023会有），这个就等下次手撸TAA的时候再来看吧。</p><h1 id="hdrp中的做法">HDRP中的做法</h1><p>然后去翻了翻HDRP中对视差的做法，大体一致，但最后选择采样点时，不是单纯的用两个点来插值，<br />而是又加上了割线法，迭代三次，取一个更近似的解。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">real2 ParallaxOcclusionMapping(TEXTURE2D_PARAM(heightMap,sampler_heightMap),real lod, real lodThreshold, int numSteps, real3 viewDirTS, float2 uv , out real outHeight)&#123;    real stepSize &#x3D; 1.0 &#x2F; (real)numSteps;    real2 parallaxMaxOffsetTS &#x3D; viewDirTS.xy &#x2F; -viewDirTS.z;    real2 texOffsetPerStep &#x3D; stepSize * parallaxMaxOffsetTS;    real2 texOffsetCurrent &#x3D; real2(0.0, 0.0);        &#x2F;&#x2F; real prevHeight &#x3D; SAMPLE_TEXTURE2D_LOD(heightMap, sampler_heightMap, uv + texOffsetCurrent, lod).r;    real prevHeight &#x3D; ComputePerPixelHeightDisplacement(texOffsetCurrent, lod, uv,heightMap, sampler_heightMap);    texOffsetCurrent +&#x3D; texOffsetPerStep;    &#x2F;&#x2F; real currHeight &#x3D; SAMPLE_TEXTURE2D_LOD(heightMap, sampler_heightMap, uv + texOffsetCurrent, lod).r;    real currHeight &#x3D; ComputePerPixelHeightDisplacement(texOffsetCurrent, lod, uv,heightMap, sampler_heightMap);    real rayHeight &#x3D; 1.0 - stepSize; &#x2F;&#x2F; Start at top less one sample    &#x2F;&#x2F; Linear search    for (int stepIndex &#x3D; 0; stepIndex &lt; numSteps; ++stepIndex)    &#123;        &#x2F;&#x2F; Have we found a height below our ray height ? then we have an intersection        if (currHeight &gt; rayHeight)            break; &#x2F;&#x2F; end the loop        prevHeight &#x3D; currHeight;        rayHeight -&#x3D; stepSize;        texOffsetCurrent +&#x3D; texOffsetPerStep;        &#x2F;&#x2F; Sample height map which in this case is stored in the alpha channel of the normal map:        &#x2F;&#x2F; currHeight &#x3D; ComputePerPixelHeightDisplacement(texOffsetCurrent, lod, uv,heightMap, sampler_heightMap);        currHeight &#x3D; ComputePerPixelHeightDisplacement(texOffsetCurrent, lod, uv,heightMap, sampler_heightMap);    &#125;        real pt0 &#x3D; rayHeight + stepSize;    real pt1 &#x3D; rayHeight;    real delta0 &#x3D; pt0 - prevHeight;    real delta1 &#x3D; pt1 - currHeight;    real delta;    real2 offset;        &#x2F;&#x2F; Secant method to affine the search    &#x2F;&#x2F; Ref: Faster Relief Mapping Using the Secant Method - Eric Risser    for (int i &#x3D; 0; i &lt; 3; ++i)    &#123;        &#x2F;&#x2F; intersectionHeight is the height [0..1] for the intersection between view ray and heightfield line        real intersectionHeight &#x3D; (pt0 * delta1 - pt1 * delta0) &#x2F; (delta1 - delta0);        &#x2F;&#x2F; Retrieve offset require to find this intersectionHeight        offset &#x3D; (1 - intersectionHeight) * texOffsetPerStep * numSteps;        currHeight &#x3D; ComputePerPixelHeightDisplacement(offset, lod, uv,heightMap, sampler_heightMap);        &#x2F;&#x2F; currHeight &#x3D; getHeight(uv + texOffsetCurrent);        delta &#x3D; intersectionHeight - currHeight;        if (abs(delta) &lt;&#x3D; 0.01)            break;        &#x2F;&#x2F; intersectionHeight &lt; currHeight &#x3D;&gt; new lower bounds        if (delta &lt; 0.0)        &#123;            delta1 &#x3D; delta;            pt1 &#x3D; intersectionHeight;        &#125;        else        &#123;            delta0 &#x3D; delta;            pt0 &#x3D; intersectionHeight;        &#125;    &#125;    outHeight &#x3D; currHeight;        &#x2F;&#x2F; Fade the effect with lod (allow to avoid pop when switching to a discrete LOD mesh)    offset *&#x3D; (1.0 - saturate(lod - lodThreshold));    return offset;&#125;</code></pre></div></figure></p><h1 id="像素深度偏移">像素深度偏移</h1><p>先看看没有深度偏移之前的样子</p><p><img src="ParallaxMapping05.gif" alt="没有像素深度偏移" /><br />其他物体是浮在之前的平面上的，凹陷下去的部分也不会透显出其他物体。<br />这是因为写入的深度没有改变，还是之前平面的深度，实际应该根据视角和高度（深度），来像素级别的改变深度图。<br />所以这里需要<code>SV_Depth</code>这个关键字。<br />改动下原来的Shader片元的函数声明</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">void LitPassFragment(Varyings input, out half4 outColor : SV_Target0,out float outDepth : SV_Depth)&#123;    &#96;&#96;&#96;&#96;&#96;&#96;    float depthOffset  &#x3D; ApplyPerPixelDisplacement(viewDirTS, input.uv,input.positionCS.xy);            &#x2F;&#x2F; ApplyDepthOffsetPositionInput(viewDirWS, depthOffset, GetViewForwardDir(), GetWorldToHClipMatrix(), input);    input.positionWS +&#x3D; depthOffset * (-viewDirWS);    float deviceDepth &#x3D; ComputeNormalizedDeviceCoordinatesWithZ( input.positionWS, GetWorldToHClipMatrix()).z;        outDepth &#x3D; deviceDepth ;&#125;</code></pre></div></figure><p>这里的逻辑很清晰，就是把片元的世界坐标沿着视线的反方向偏移，然后再手动计算一次深度，最后吧把深度写入。</p><p><img src="ParallaxMapping06.gif" alt="像素深度偏移" /><br />这时深度信息就正确了。</p><h1 id="阴影">阴影</h1><p>同样的，在绘制阴影贴图时，也要添加对应的深度偏移<br />改动一下阴影pass的片元着色器<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">half4 ShadowPassFragment(Varyings input,out float outDepth : SV_Depth) : SV_Target&#123;    UNITY_SETUP_INSTANCE_ID(input);    UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);        float3 lightDirectionWS &#x3D; _LightDirection;        &#x2F;&#x2F; half3 viewDirWS &#x3D; GetWorldSpaceNormalizeViewDir(input.positionWS);    half3 viewDirWS &#x3D; normalize(lightDirectionWS);    half3 viewDirTS &#x3D; GetViewDirectionTangentSpace(input.tangentWS, input.normalWS, viewDirWS);    float depthOffset  &#x3D; ApplyPerPixelDisplacement(viewDirTS, input.uv,input.positionCS.xy);        input.positionWS +&#x3D; depthOffset * (-viewDirWS);    input.positionWS &#x3D; ApplyShadowBias(input.positionWS, input.normalWS, lightDirectionWS);        float deviceDepth &#x3D; ComputeNormalizedDeviceCoordinatesWithZ( input.positionWS, GetWorldToHClipMatrix()).z;    outDepth &#x3D; deviceDepth ;    return 0;&#125;</code></pre></div></figure><br />这里要注意的是，对于平行光来说，视线方向应该就是光线方向。</p><figure><img src="ParallaxMapping07.gif" alt="阴影" /><figcaption aria-hidden="true">阴影</figcaption></figure><p>阴影也考虑高度的话其实挺吃性能的，一般这种用作地面的平面，不投射阴影仅接收阴影也可以，或者阴影少几层影响也不大。</p><h1 id="vr">VR</h1><p>得益于URP的单通道渲染，几乎不需要什么改动就可以完美适配VR，VR下视差贴图的效果确实惊人，因为视差考虑到了双眼位置的不同，双眼的画面也就不同，这就比单纯的法线要生动真实的多。看来虚幻的VR开发指南中推荐用视差还是有道理的。</p><figure><img src="ParallaxMapping08.gif" alt="VR" /><figcaption aria-hidden="true">VR</figcaption></figure><h1 id="后续">后续</h1><p>如果说还有什么可以改进的，那就考虑软阴影，抗锯齿之类，以后有需要再说吧。</p>]]></content>
    
    
    <categories>
      
      <category>渲染</category>
      
    </categories>
    
    
    <tags>
      
      <tag>视差</tag>
      
      <tag>视差遮蔽映射</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>URP下定制PBRShader</title>
    <link href="/2023/06/15/pbr/"/>
    <url>/2023/06/15/pbr/</url>
    
    <content type="html"><![CDATA[<h1 id="复刻urplit">复刻URPLit</h1><span id="more"></span><p>考虑到项目移植各个平台的顺利，URP还是目前最实用的管线了，但自带的lit还是缺少很多功能，比如对VR很重要的几何高光抗锯齿，混合SSR也不是很方便，各向异性，环境法线，高光遮蔽，视差映射等等功能都是缺少的。<br />为了功能的收缩与扩张方便，还是有必要手撸一个PBR的。<br />而且Lit的代码为了兼容各种环境，比如Dot，VR，LODCross，做了大量的判断，代码很杂乱，很难修改。整理一遍也是为了更好的理解URP的Lit着色器。<br />以上存粹是为了说服自己造这个轮子。。。</p><h1 id="需求">需求</h1><p>先从简单的搞起，大致输入就先仿照URP最精简的Lit</p><ul><li>按金属粗糙的工作流</li><li>不透明</li><li>仅正面</li><li>alpha不裁切</li><li>接收阴影</li><li>阴影不级联</li><li>BaseMap(RGBA)</li><li>BaseColor(RGBA)</li><li>Metallic</li><li>MetallicMap（R金属 A光滑）</li><li>Smoothness</li><li>NormalMap</li><li>先不考虑高度图</li><li>OcclusionMap</li><li>OcclusionStrength</li><li>EmissionColor</li><li>EmissionMap</li><li>先不考虑细节贴图</li><li>先不考虑清漆</li><li>实时光仅平行光</li><li>有环境反射</li><li>先不考虑烘焙</li></ul><h1 id="开搞">开搞</h1><p>这里就没什么好说的了，公式就翻翻URP的lit的实现，先尽量汇总到一个文件里，方便之后比对。</p><h2 id="properties">Properties</h2><p>就参照上面的需求，大致列一下属性，不够之后再加。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">Properties&#123;    [MainTexture] _BaseMap(&quot;Albedo&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;    [MainColor] _Color(&quot;Color&quot;, Color) &#x3D; (1,1,1,1)        _Metallic(&quot;Metallic&quot;, Range(0.0, 1.0)) &#x3D; 0.0    _MetallicGlossMap(&quot;Metallic&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;    _Smoothness(&quot;Smoothness&quot;, Range(0.0, 1.0)) &#x3D; 0.5        _BumpMap(&quot;Normal Map&quot;, 2D) &#x3D; &quot;bump&quot; &#123;&#125;        _OcclusionStrength(&quot;Strength&quot;, Range(0.0, 1.0)) &#x3D; 1.0    _OcclusionMap(&quot;Occlusion&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;    [HDR] _EmissionColor(&quot;Color&quot;, Color) &#x3D; (0,0,0)    _EmissionMap(&quot;Emission&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;&#125;</code></pre></div></figure></p><h2 id="tags">Tags</h2><p>按照URP文档的要求，要配置一些通用的Tag<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">Tags&#123;    &quot;RenderType&quot; &#x3D; &quot;Opaque&quot;     &quot;RenderPipeline&quot; &#x3D; &quot;UniversalPipeline&quot;    &quot;UniversalMaterialType&quot; &#x3D; &quot;Lit&quot;&#125;</code></pre></div></figure></p><h2 id="pass">Pass</h2><p>URP要求一个Shader中要实现多个Pass，分别包含了</p><ul><li>UniversalForward</li><li>ShadowCaster</li><li>UniversalGBuffer</li><li>DepthOnly</li><li>DepthNormals</li><li>Meta</li><li>Universal2D</li></ul><p>顾名思义，不一一介绍了，最为最简单的仅前向的shader，这里就挑出以下五个实现</p><ul><li>UniversalForward</li><li>ShadowCaster</li><li>DepthOnly</li><li>DepthNormals</li><li>Meta</li></ul><h1 id="关键字">关键字</h1><p>参照urp的lit，分为材质的关键字、管线的关键字、unity的关键字和GPUInstancing。<br />材质的关键字主要用来定义一些局部的属性，如是否启用法线贴图，是否启用高度图，光滑的从哪里采样等等<br />这部分就先省略，之后优化时再加。<br />然后是管线的关键字，主要定义一些是否启用了主光源阴影，屏幕阴影，附加光阴影，软阴影等等。<br />这里就也先省略了，需要对应的功能再加。<br />然后是untiy的关键字。包含了光照贴图，阴影的shadowMask，雾气等等。</p><h1 id="存储结构">存储结构</h1><p>参考lit，把输入以及一些常用的采样分到一个文件中，具体的着色器函数在另一个文件，方便引用，那这里也依葫芦画瓢。<br />值得一提的是URP中还把常见的一些贴图又分到了一个SurfaceInpute中，这里就没有必要了，合并到一起。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">#ifndef MK_LIT_INPUT_INCLUDED#define MK_LIT_INPUT_INCLUDED#include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;CBUFFER_START(UnityPerMaterial)float4 _BaseMap_ST;half4 _BaseColor;half4 _EmissionColor;half _Smoothness;half _Metallic;half _OcclusionStrength;CBUFFER_ENDTEXTURE2D(_BaseMap);            SAMPLER(sampler_BaseMap);TEXTURE2D(_BumpMap);            SAMPLER(sampler_BumpMap);TEXTURE2D(_EmissionMap);        SAMPLER(sampler_EmissionMap);TEXTURE2D(_OcclusionMap);       SAMPLER(sampler_OcclusionMap);TEXTURE2D(_MetallicGlossMap);   SAMPLER(sampler_MetallicGlossMap);#endif &#x2F;&#x2F; MK_LIT_INPUT_INCLUDED</code></pre></div></figure><br />都是很常见的属性。</p><h1 id="顶点着色器">顶点着色器</h1><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">Varyings LitPassVertex(Attributes input)&#123;    &#x2F;&#x2F; 初始化赋值    Varyings output &#x3D; (Varyings)0;    &#x2F;&#x2F; GPUInstance和VR单pass的套路    UNITY_SETUP_INSTANCE_ID(input);    UNITY_TRANSFER_INSTANCE_ID(input, output);    UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);    &#x2F;&#x2F; 一个方便的小函数，包含了各种位置的计算    VertexPositionInputs vertexInput &#x3D; GetVertexPositionInputs(input.positionOS.xyz);    &#x2F;&#x2F;  求BTN    &#x2F;&#x2F; normalWS and tangentWS already normalize.    &#x2F;&#x2F; this is required to avoid skewing the direction during interpolation    &#x2F;&#x2F; also required for per-vertex lighting and SH evaluation    VertexNormalInputs normalInput &#x3D; GetVertexNormalInputs(input.normalOS, input.tangentOS);    &#x2F;&#x2F; 顶点光照颜色 这里就不用顶点光照了    half3 vertexLight &#x3D; VertexLighting(vertexInput.positionWS, normalInput.normalWS);    &#x2F;&#x2F; 也省略雾气    half fogFactor &#x3D; 0;    #if !defined(_FOG_FRAGMENT)        fogFactor &#x3D; ComputeFogFactor(vertexInput.positionCS.z);    #endif    &#x2F;&#x2F; UV缩放    output.uv &#x3D; TRANSFORM_TEX(input.texcoord, _BaseMap);    &#x2F;&#x2F; 输出法线    &#x2F;&#x2F; already normalized from normal transform to WS.    output.normalWS &#x3D; normalInput.normalWS;    &#x2F;&#x2F; 输出切线#if defined(REQUIRES_WORLD_SPACE_TANGENT_INTERPOLATOR) || defined(REQUIRES_TANGENT_SPACE_VIEW_DIR_INTERPOLATOR)    real sign &#x3D; input.tangentOS.w * GetOddNegativeScale();    half4 tangentWS &#x3D; half4(normalInput.tangentWS.xyz, sign);#endif#if defined(REQUIRES_WORLD_SPACE_TANGENT_INTERPOLATOR)    output.tangentWS &#x3D; tangentWS;#endif    &#x2F;&#x2F; 切线空间的视角向量#if defined(REQUIRES_TANGENT_SPACE_VIEW_DIR_INTERPOLATOR)    half3 viewDirWS &#x3D; GetWorldSpaceNormalizeViewDir(vertexInput.positionWS);    half3 viewDirTS &#x3D; GetViewDirectionTangentSpace(tangentWS, output.normalWS, viewDirWS);    output.viewDirTS &#x3D; viewDirTS;#endif    &#x2F;&#x2F; 输出光照贴图UV    OUTPUT_LIGHTMAP_UV(input.staticLightmapUV, unity_LightmapST, output.staticLightmapUV);#ifdef DYNAMICLIGHTMAP_ON    output.dynamicLightmapUV &#x3D; input.dynamicLightmapUV.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;#endif    &#x2F;&#x2F; 如果没有光照贴图，就用光照探针的SH    OUTPUT_SH(output.normalWS.xyz, output.vertexSH);    &#x2F;&#x2F; 雾气赋值#ifdef _ADDITIONAL_LIGHTS_VERTEX    output.fogFactorAndVertexLight &#x3D; half4(fogFactor, vertexLight);#else    output.fogFactor &#x3D; fogFactor;#endif    &#x2F;&#x2F; 输出世界位置#if defined(REQUIRES_WORLD_SPACE_POS_INTERPOLATOR)    output.positionWS &#x3D; vertexInput.positionWS;#endif    &#x2F;&#x2F; 输出阴影贴图UV#if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)    output.shadowCoord &#x3D; GetShadowCoord(vertexInput);#endif    output.positionCS &#x3D; vertexInput.positionCS;    return output;&#125;</code></pre></div></figure><p>那精简之后得到<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">Varyings LitPassVertex(Attributes input)&#123;    Varyings output &#x3D; (Varyings)0;    &#x2F;&#x2F; todo instance VR    VertexPositionInputs vertexInput &#x3D; GetVertexPositionInputs(input.positionOS.xyz);    VertexNormalInputs normalInput &#x3D; GetVertexNormalInputs(input.normalOS, input.tangentOS);    output.uv &#x3D; TRANSFORM_TEX(input.texcoord, _BaseMap);    output.normalWS &#x3D; normalInput.normalWS;    real sign &#x3D; input.tangentOS.w * GetOddNegativeScale();    half4 tangentWS &#x3D; half4(normalInput.tangentWS.xyz, sign);    output.tangentWS &#x3D; tangentWS;    OUTPUT_LIGHTMAP_UV(input.staticLightmapUV, unity_LightmapST, output.staticLightmapUV);    output.positionWS &#x3D; vertexInput.positionWS;    output.shadowCoord &#x3D; GetShadowCoord(vertexInput);    output.positionCS &#x3D; vertexInput.positionCS;    return output;&#125;</code></pre></div></figure></p><h1 id="片元">片元</h1><p>然后就是最复杂的片元了<br />URP的SurfaceData略显复杂，精简一下<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">struct SurfaceData&#123;    half3 albedo;    half  metallic;    half  smoothness;    half3 normalTS;    half3 emission;    half  occlusion;&#125;;</code></pre></div></figure><br />然后是初始化SurfaceData，就是采样一堆贴图，然后根据系数得出最终的每个片元的属性。简化一下如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">inline void InitializeStandardLitSurfaceData(float2 uv, out SurfaceData outSurfaceData)&#123;    half4 albedoAlpha &#x3D; SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, uv);    outSurfaceData.albedo &#x3D; albedoAlpha.rgb * _BaseColor.rgb;    half4 metallicSmoothness &#x3D; SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, uv);    outSurfaceData.metallic &#x3D; metallicSmoothness.r * _Metallic;    outSurfaceData.smoothness &#x3D; metallicSmoothness.a * _Smoothness;        half4 n &#x3D; SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, uv);    outSurfaceData.normalTS &#x3D; UnpackNormal(n);    outSurfaceData.emission &#x3D; SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, uv).rgb * _EmissionColor.rgb;    half occ &#x3D; SAMPLE_TEXTURE2D(_OcclusionMap, sampler_OcclusionMap, uv).g;        outSurfaceData.occlusion &#x3D; LerpWhiteTo(occ, _OcclusionStrength);&#125;</code></pre></div></figure><p>接着是初始化顶点的输入，主要涉及各种空间下的坐标以及GI、阴影、雾气等。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">void InitializeInputData(Varyings input, half3 normalTS, out InputData inputData)&#123;    inputData &#x3D; (InputData)0;    &#x2F;&#x2F; 世界坐标#if defined(REQUIRES_WORLD_SPACE_POS_INTERPOLATOR)    inputData.positionWS &#x3D; input.positionWS;#endif    &#x2F;&#x2F; 视角方向    half3 viewDirWS &#x3D; GetWorldSpaceNormalizeViewDir(input.positionWS);    &#x2F;&#x2F; 法线相关#if defined(_NORMALMAP) || defined(_DETAIL)    &#x2F;&#x2F; 如果有法线贴图就要用TBN重新计算    float sgn &#x3D; input.tangentWS.w;      &#x2F;&#x2F; should be either +1 or -1    float3 bitangent &#x3D; sgn * cross(input.normalWS.xyz, input.tangentWS.xyz);    half3x3 tangentToWorld &#x3D; half3x3(input.tangentWS.xyz, bitangent.xyz, input.normalWS.xyz);    #if defined(_NORMALMAP)    inputData.tangentToWorld &#x3D; tangentToWorld;    #endif    inputData.normalWS &#x3D; TransformTangentToWorld(normalTS, tangentToWorld);#else    inputData.normalWS &#x3D; input.normalWS;#endif    &#x2F;&#x2F; 归一化，还要考虑向量为0    inputData.normalWS &#x3D; NormalizeNormalPerPixel(inputData.normalWS);    inputData.viewDirectionWS &#x3D; viewDirWS;    &#x2F;&#x2F; 阴影#if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)    inputData.shadowCoord &#x3D; input.shadowCoord;#elif defined(MAIN_LIGHT_CALCULATE_SHADOWS)    inputData.shadowCoord &#x3D; TransformWorldToShadowCoord(inputData.positionWS);#else    inputData.shadowCoord &#x3D; float4(0, 0, 0, 0);#endif    &#x2F;&#x2F; 雾#ifdef _ADDITIONAL_LIGHTS_VERTEX    inputData.fogCoord &#x3D; InitializeInputDataFog(float4(input.positionWS, 1.0), input.fogFactorAndVertexLight.x);    inputData.vertexLighting &#x3D; input.fogFactorAndVertexLight.yzw;#else    inputData.fogCoord &#x3D; InitializeInputDataFog(float4(input.positionWS, 1.0), input.fogFactor);#endif    &#x2F;&#x2F; GI#if defined(DYNAMICLIGHTMAP_ON)    inputData.bakedGI &#x3D; SAMPLE_GI(input.staticLightmapUV, input.dynamicLightmapUV, input.vertexSH, inputData.normalWS);#else    inputData.bakedGI &#x3D; SAMPLE_GI(input.staticLightmapUV, input.vertexSH, inputData.normalWS);#endif    &#x2F;&#x2F; 屏幕空间UV    inputData.normalizedScreenSpaceUV &#x3D; GetNormalizedScreenSpaceUV(input.positionCS);    &#x2F;&#x2F; 阴影遮罩    inputData.shadowMask &#x3D; SAMPLE_SHADOWMASK(input.staticLightmapUV);    #if defined(DEBUG_DISPLAY)    #if defined(DYNAMICLIGHTMAP_ON)    inputData.dynamicLightmapUV &#x3D; input.dynamicLightmapUV;    #endif    #if defined(LIGHTMAP_ON)    inputData.staticLightmapUV &#x3D; input.staticLightmapUV;    #else    inputData.vertexSH &#x3D; input.vertexSH;    #endif    #endif&#125;</code></pre></div></figure></p><h2 id="gi">GI</h2><p>依据不同的光照贴图的编码，有不同的解码方式，这里先取巧用FULL_HDR，就可以不用解码了。<br />大致流程就是采样贴图，得出方向与强度，用halfLambert得出最终的GI。</p><h2 id="阴影">阴影</h2><p>这里仅算主光源阴影，Untiy还会采样烘焙的阴影贴图，去混合实时光阴影与烘焙阴影。</p><h2 id="pbr">PBR</h2><p>整个计算流程就是分为算AO，实际的URP会在这里取看有没有SSAO，我们先省略。<br />然后得出主光源的信息，这里就包含了阴影。<br />然后就是计算GI，主光源，附加光，顶点光。<br />最后两项先省略。<br />代码如下：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">half4 PBR(InputData inputData, SurfaceData surfaceData)&#123;    BRDFData brdfData;        InitializeBRDFData(surfaceData, brdfData);    AmbientOcclusionFactor aoFactor &#x3D; CreateAmbientOcclusionFactor(inputData, surfaceData);        Light mainLight &#x3D; GetMainLight(inputData, 1, aoFactor);        LightingData lightingData &#x3D; CreateLightingData(inputData, surfaceData);    lightingData.giColor &#x3D; GlobalIllumination(brdfData,                                              inputData.bakedGI, aoFactor.indirectAmbientOcclusion, inputData.positionWS,                                              inputData.normalWS, inputData.viewDirectionWS, inputData.normalizedScreenSpaceUV);        lightingData.mainLightColor &#x3D; LightingPhysicallyBased(brdfData,                                                             mainLight,                                                             inputData.normalWS, inputData.viewDirectionWS);    return CalculateFinalColor(lightingData, 1);&#125;</code></pre></div></figure><br />详细的计算GI与实时光的代码就不贴了，总之这样就算有了一个改动方便的PBR。后续再想增加一些SSR、环境法线之类的功能就方便很多了。<br />当然这个还很不完善，比如级联阴影，透明，等等都没有考虑。<br />很多分支都被删减了，先看看好不好用吧，如果可行那就以后再慢慢补充。</p><h1 id="分文件">分文件</h1><p>还是有必要按照原来逻辑把hlsl代码分开，不然后期不太好维护。<br />大致分为以下几个文件</p><ul><li>AmbientOcclusionAO计算，包括直接光与间接光，SSAO得出的结果在前向渲染里也是在这里采样的。</li><li>BRDF 这里就是PBR那一套公式了</li><li>EntityLighting 涉及球谐函数以及光照贴图的采样（包括解码）</li><li>GlobalIllumination在对EntityLighting封装的基础上，添加了诸如BoxProjected，混合，根据光照贴图编码方式选择具体的解码，采样反射探针等</li><li>ImageBasedLighting 包含了一些基于图像的光照工具函数</li><li>Lighting主要的光照计算，除了调用上面的BRDF，其实还包含了Unlit，BlinnPhong，BakedLit等多种光照模型。</li><li>LitForwardPass 包含顶点与片元。</li><li>LitInput 包含从材质传递过来的全部输入</li><li>RealtimeLights 实时光的获取，并调用阴影</li><li>Shadows阴影相关，阴影贴图的采样，级联，也包含了采样光照贴图里的阴影贴图并混合</li><li>SurfaceData一个结构体，包含了一个要进入光照计算的片元的表面数据，如漫反射，金属，粗糙，遮蔽等。</li><li>InputData一个结构体，包含了一个要进入光照计算的片元的几何数据，如位置坐标，世界法线，阴影坐标，BakedGI等。</li></ul><p>根据这些文件的调用关系，再梳理一下就是<br />LitForwardPass是总入口，汇总并梳理了全部的输入，整合成两个输入即InputData与SurfaceData。<br />当然，出于性能的考虑，这里的阴影坐标也提前在顶点着色器中获取了。<br />然后选择Lighting中的一个光照模型。类似与Lighting实现了一个通用的光照模型的接口。<br />这里就选用PBR的模型。<br />然后就开始采用PBR的公式，分以下几步，</p><ul><li>首先是从InputData与SurfaceData构造BRDFData。<ul><li>BRDFData与SurfaceData很类似，主要是增加了一些诸如roughness2MinusOne等方便计算的属性。</li></ul></li><li>取AO，从AmbientOcclusion取出AO，如果有SSAO，也会在这里处理。</li><li>取主光照数据（数据结构Light），从RealtimeLights获取实时光的数据。<ul><li>这里又会调用Shadows来包含对应的阴影</li><li>Light包含 方向，颜色，阴影。</li></ul></li><li>然后是构造LightingData，包含了GI，主光源，附加光，顶点光，自发光。<ul><li>GI是调用BRDF的工具函数由公式计算得出，主要的输入如下<ul><li>间接漫反射就是直接取的光照贴图，或者球谐函数。</li><li>间接高光就是采用的反射贴图了</li></ul></li><li>主光源就单纯的用BRDF公式，也是分为直接漫反射和直接高光。</li><li>出于简化的目的，其余的先不看了。</li></ul></li><li>最后就是将这些来自各种光源的光叠加，得出最终的输出。</li></ul><p>这应该就是URP下的最简单的PBR实现了</p><h1 id="阴影投射pass">阴影投射Pass</h1><p>只需在顶点着色器中应用一下法线和深度偏移，其余没有什么特殊的。</p><h1 id="球谐函数">球谐函数</h1><p>根据LIGHTMAP_ON这个关键字，来判断GI是用贴图还是球谐函数。</p><h1 id="级联阴影">级联阴影</h1><p>通过_MAIN_LIGHT_SHADOWS_CASCADE来判断是否级联，然后根据距离各个级联球的中心的距离与设定距离的差值，来判断应该取哪一个级联。</p><h1 id="总结">总结</h1><p>说不上是从零开始手撸PBR造轮子，只能算是精简了URP的原本的lit的着色器，主要目的还是理清其各个文件的逻辑关系，方便之后实现各种效果。</p>]]></content>
    
    
    <categories>
      
      <category>渲染</category>
      
    </categories>
    
    
    <tags>
      
      <tag>URP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口在编辑器中的拓展</title>
    <link href="/2023/06/15/InterfaceInEditor/"/>
    <url>/2023/06/15/InterfaceInEditor/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>经常会希望在Unity编辑器中有这样一种功能的实现，可以直接引用（序列化）一个实现了指定接口的组件。<br />面向接口可以大大降低代码的耦合，实现依赖反转，同时更加灵活，后续的修改与扩展都更加方便。<br />但官方就是不做，可以从<ahref="https://forum.unity.com/threads/serialized-interface-fields.1238785/">这个帖子</a>中看到官方的态度。<br />所以下面就列举一下自己实现这个功能的各种方法。</p><h1 id="问题描述">问题描述</h1><p>假使有这样一个接口<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public interface ICanGetBool&#123;    bool GetBool();&#125;</code></pre></div></figure><br />然后有若干MonoBehaviour<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public class TestMono : MonoBehaviour&#123;    public ICanGetBool canGetBool;&#125;public class CanGetBoolMono : MonoBehaviour,ICanGetBool&#123;    public bool GetBool()    &#123;        return true;    &#125;&#125;public class CanGetBoolFalseMono : MonoBehaviour,ICanGetBool&#123;    public bool GetBool()    &#123;        return false;    &#125;&#125;</code></pre></div></figure><br />目的是在编辑器中将一<code>CanGetBoolMono</code>或者<code>CanGetBoolFalseMono</code>的实例拖拽到<code>TestMono</code>的<code>canGetBool</code>属性上去。</p><h1 id="onvalidate判断">OnValidate判断</h1><p>思路是用一个通用的比如Component属性来接收，然后在OnValidate中判断是否是对应的接口，不是就重置为null。然后在使用的时候要手动转换一次。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public class TestMono : MonoBehaviour&#123;    public ICanGetBool canGetBool;    public Component canGetBoolComponent;        public void Start()    &#123;        canGetBool &#x3D; canGetBoolComponent as ICanGetBool;        Debug.Log(canGetBool.GetBool());    &#125;    private void OnValidate()    &#123;        if (canGetBoolComponent is ICanGetBool component)        &#123;            canGetBool &#x3D; component;            Debug.Log(canGetBool.GetBool());        &#125;        else        &#123;            Debug.LogError(&quot;interface not implemented&quot;);            canGetBoolComponent &#x3D; null;        &#125;    &#125;&#125;</code></pre></div></figure><br />这种简单快捷，但缺点是要为每个类似需求的MonoBehaviour都写对应的OnValidate，还是不方便。</p><h1 id="构造容器">构造容器</h1><p>也是大同小异，区别在于利用泛型生成一个新的类，用新的类型作为容器来存储真正的对象。也是可以放入任意类型，在PropertyDrawer中验证类型是否符合。<br /><ahref="https://answers.unity.com/questions/46210/how-to-expose-a-field-of-type-interface-in-the-ins.html?page=2&amp;pageSize=5&amp;sort=votes#">摘自</a><br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">[Serializable]public abstract class ATypedContainer&#123;    [CanBeNull]    [SerializeField]    protected MonoBehaviour obj &#x3D; default;    public void Validate()    &#123;        OnValidate();    &#125;    protected abstract void OnValidate();&#125;[Serializable]public class TypedContainer&lt;T&gt; : ATypedContainer where T : class&#123;    [CanBeNull]    public T Value &#x3D;&gt; obj as T;    protected override void OnValidate()    &#123;        if (Value &#x3D;&#x3D; null)            obj &#x3D; null;    &#125;&#125;[CustomPropertyDrawer(typeof(ATypedContainer), true)]public class TypedContainerClassDrawer : PropertyDrawer&#123;    const string OBJ_FIELD_NAME &#x3D; &quot;obj&quot;;    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)    &#123;        var tc &#x3D; fieldInfo.GetValue(property.serializedObject.targetObject) as ATypedContainer;        tc?.Validate();        var objProp &#x3D; property.FindPropertyRelative(OBJ_FIELD_NAME);        if (objProp &#x3D;&#x3D; null)            throw new InvalidCastException($&quot;Can&#39;t find &#123;OBJ_FIELD_NAME&#125; field in &#123;property.type&#125;&quot;);        EditorGUI.PropertyField(position, objProp, label);    &#125;&#125;[Serializable]public class CanGetBoolContainer: TypedContainer&lt;ICanGetBool&gt; &#123;&#125;</code></pre></div></figure><br />这种省去了在目标MonoBehaviour中写模板代码，可以为每个接口实现一个容器类，也可以在使用时直接声明<code>TypedContainer&lt;ICanGetBool&gt;</code>。</p><h1 id="serializableinterface">SerializableInterface</h1><p>最后介绍一个项目<ahref="https://github.com/Thundernerd/Unity3D-SerializableInterface">Unity3D-SerializableInterface</a><br />不仅实现了第二种的容器类的方式，还支持从资源文件，场景组件，甚至仅引用一个接口，一共三种方式来序列化接口。<br />而且提供了untiyPackage的安装方式。强烈推荐。</p>]]></content>
    
    
    <categories>
      
      <category>编码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>接口</tag>
      
      <tag>编辑器工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>悬链线与弹簧质点模拟绳索</title>
    <link href="/2023/06/15/Catenary/"/>
    <url>/2023/06/15/Catenary/</url>
    
    <content type="html"><![CDATA[<h1 id="绳索模拟">绳索模拟</h1><p>最近有这么一个需求，模拟绳子。<br />如果是那种铰链之类的，可以直接用unity物理。如果是软体并且要求物理碰撞，那就得考虑Obi之类的用质点弹簧模型的解算器去解算了。<br />考虑到webGL也要用，Obi需求的求解器依赖于Burst，所以webgl没法使用。而且Obi不可控因素太多，为了一个简单的，无需物理的绳索动画，也没有必要使用太复杂的Obi。<br />还一种方式就是让美术在Blender，maya里绑定骨骼，制作动画，但这就是固定死的，也不方便后期调整。<br />最后就是本文的主题了，悬链线。</p><h1 id="悬链线">悬链线</h1><p>首先贴出<ahref="https://www.alanzucconi.com/2020/12/13/catenary-2/">原文</a>。以下基本是翻译，但最后增加补充了在三维中绘制悬链线的方式和代码。</p><p>悬链线就是指理想状态下的绳索在固定两端后自然下垂所形成的曲线，具体的公式推导就不赘述了。<br />曲线函数为：</p><p><span class="math display">$$y=a\cosh(\frac{x-p}{a})+q$$</span></p><p>这里a是一个常数，决定了悬链线的形态，其余的p和q一看就知道只是横向与纵向的偏移。</p><p>但这种方程不符合我们的使用习惯，一般的逻辑应该是给出两点，长度。这里记为P1，P2，l。然后通过这些参数来给出曲线函数。<br />其中p和q可以通过以下方式来构造出：</p><p><span class="math display">$$q=  \frac {y_ {1}+y_ {2}-l\coth (\frac {h}{2a})}{a}  $$</span></p><p>这里</p><p><span class="math display">$$\begin{equation}\begin{aligned}h &amp;= x_2-x_1 \\v &amp;= y_2-y_1\end{aligned}\end{equation}$$</span></p><p>所以主要问题就是如何求解这个a。</p><h1 id="求解a">求解a</h1><p>首先，并没有可以简单的可以直接导出a的公式。<br />但上式可以转换成：</p><p><span class="math display">$$\sqrt {l^ {2}-v^ {2}}  =2a  \sinh  (  \frac {h}{2a} )$$</span></p><p>这里左边就是一个常数。<br />而右边可以证明是一个关于a的单调递减的函数。<br />所以可以用二分法快速求出一个近似解。<br />首先是确定一个二分的区间，确保其中有解。</p><p>我们可以从0出发，每次增加一个固定值，比如1，如果新值a1小于左边，就说明解存在与（a1-1,a1）之间。</p><p>然后从这个区间出发，用二分法求出一个相对精确的解。<br />下面贴上代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">private void GetARange()&#123;    a &#x3D; 0;    currentIteration &#x3D; 0;    do    &#123;        currentIteration++;        a +&#x3D; IntervalStep;    &#125; while (Math.Sqrt(Math.Pow(l, 2) - Math.Pow(v, 2)) &lt; 2 * a * Math.Sinh(h &#x2F; (2 * a)) &amp;&amp;             currentIteration &lt; maxIteration);&#125;private void GetA()&#123;    double a_prev &#x3D; a - IntervalStep;    double a_next &#x3D; a;    currentIteration &#x3D; 0;    do    &#123;        currentIteration++;        a &#x3D; (a_prev + a_next) &#x2F; 2f;        if (Math.Sqrt(Math.Pow(l, 2) - Math.Pow(v, 2)) &lt; 2 * a * Math.Sinh(h &#x2F; (2 * a)))            a_prev &#x3D; a;        else            a_next &#x3D; a;    &#125; while (a_next - a_prev &gt; Precision &amp;&amp; currentIteration &lt; maxIteration);&#125;</code></pre></div></figure><h1 id="绘制">绘制</h1><p>已经求出了全部参数，那悬链线函数就确定了，绘制可以采用lineRenderer。<br />也可以考虑使用unity新推出的专用来绘制曲线的Spline。前者简单快捷，后者稍显复杂但是提供了更多的扩展性，比如在两端再增加一些点，用来模拟绳子在两端的朝向。<br />或者也可以把悬链线参数传入shader中，用GPU来绘制。</p><p>这里先以lineRenderer为例。</p><h2 id="linerenderer">lineRenderer</h2><p>悬链线方程是二维平面内的曲线，所以这里把其中一个点作为起点，以这个起点为原点，世界坐标的Y轴为悬链线的Y轴，以起点指向终点在世界坐标下的xz平面中的投影作为X轴。</p><p>这样得出的曲线上每个点的坐标，只要先让起点在xz平面上朝向终点，然后用起点的Transform转换一下就可以了。</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">private void DrawCatenary()&#123;    double segmentLength &#x3D; h &#x2F; resolution;    Vector3 dir &#x3D; endPoint.position - startPoint.position;    var originPos &#x3D; startPoint.position;    var originRot &#x3D; startPoint.rotation;    startPoint.right &#x3D; new Vector3(dir.x, 0, dir.z);    lineRenderer.positionCount &#x3D; resolution + 1;    for (int i &#x3D; 0; i &lt;&#x3D; resolution; i++)    &#123;        double x &#x3D; i * segmentLength;        double y &#x3D; CalculateCatenaryY(x);        Vector3 point &#x3D; new Vector3((float)x, (float)y, 0f);        point &#x3D; startPoint.TransformPoint(point);        lineRenderer.SetPosition(i, point);    &#125;    startPoint.SetPositionAndRotation(originPos, originRot);&#125;</code></pre></div></figure><figure><img src="Catenary.gif" alt="悬链线" /><figcaption aria-hidden="true">悬链线</figcaption></figure><h1 id="动态">动态</h1><p>todo<br />这样的模拟只是静态，没有动态惯性。静态看起来没有什么问题，但的一旦动起来，看起来还是比较僵硬。下面就设法为其增加一些动态效果。<br />先从简单的摇摆开始吧。</p><h2 id="摇摆">摇摆</h2><p>这里把摇摆简单建模成每个点绕沿着起点与终点的连线的垂直方向上的交点的旋转，所以只要在二维中时计算每个点的旋转幅度即可。<br />用于一些接触点不变的如电线等物体效果好一些。</p><figure><img src="Catenary-Shake.gif" alt="悬链线摇摆" /><figcaption aria-hidden="true">悬链线摇摆</figcaption></figure><h2 id="惯性">惯性</h2><p>写到这里就才发现，继续用悬链线来做已经不合适了，悬链线只能表示绳索的最终状态，要想完美实现符合基本物理规律的动态绳索，只能依靠质点弹簧了。那就再另起一篇实现个质点弹簧系统吧。</p><h1 id="弹簧质点">弹簧质点</h1><p>最终还是要手撸一个弹簧质点。参考自<ahref="https://zhuanlan.zhihu.com/p/361126215"></a>。<br />思路与代码就不贴了，原文很详细了。</p><figure><img src="SpringMass.gif" alt="弹簧质点模拟" /><figcaption aria-hidden="true">弹簧质点模拟</figcaption></figure><p>既然都弹簧质点了，等有时间再来试试布料模拟吧。</p>]]></content>
    
    
    <categories>
      
      <category>编码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
      <tag>悬链线</tag>
      
      <tag>弹簧质点</tag>
      
      <tag>绳索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>URP下厚度图的实现</title>
    <link href="/2023/05/10/URP-thickness/"/>
    <url>/2023/05/10/URP-thickness/</url>
    
    <content type="html"><![CDATA[<h1 id="屏幕空间厚度">屏幕空间厚度</h1><p>总有一些时候需要获取特定模型的屏幕空间厚度，如次表面散射，透明渲染，或者最近项目中要求实现的X光效果。<br />Unity在2023.1的HDRP中提供了这一功能，经询问，URP暂无此计划。<br />翻阅HDRP的实现源码后才发现这个效果并没有那么复杂，性能损耗也没有想象中那么大，实现的方式很巧妙，遂决定在URP中复刻一下。</p><figure><img src="thickness-bone-render.png" alt="URP中的效果" /><figcaption aria-hidden="true">URP中的效果</figcaption></figure><h1 id="hdrp中的实现">HDRP中的实现</h1><p>最关键的代码是一个Shader：<code>ComputeThickness</code>，贴一下关键代码：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">ZWrite OffZTest AlwaysCull OffBlend One OneBlendOp AddHLSLPROGRAMfloat _DownsizeScale;uint _ViewId;void Frag(PackedVaryingsToPS packedInput, bool isFrontFace : SV_IsFrontFace, out float2 outColor : SV_Target0 )&#123;    UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(packedInput);    FragInputs input &#x3D; UnpackVaryingsToFragInputs(packedInput);    float usedDepth &#x3D; LinearEyeDepth(input.positionSS.z, _ZBufferParams);    float sign &#x3D; isFrontFace ? -1.0f : 1.0f;    float value &#x3D; sign * usedDepth;    outColor &#x3D; float2(value, 1.0f);&#125;</code></pre></div></figure><br />这里巧妙的利用了BlendOpAdd，不剔除背面，每个三角面的点都参与计算，如果是背面，就记为正，写入其深度。<br />如果是正面，就记为负数，减去其深度，这样无论模型有多复杂，只要是封闭的模型（不封闭的模型何来厚度一说），都可以像素级别的计算其准确的厚度。<br />第二个通道则是都记为1，无论正负都加1，目的是来计算屏幕空间的面片数量，对与非封闭模型，如树叶植被有很大帮助。</p><h1 id="urp中的实现">URP中的实现</h1><p>知道其原理就开始着手在URP中实现吧。</p><h2 id="思路">思路</h2><p>分为两个RenderFeature，一个用来绘制物体的厚度到厚度图，再一个全屏pass，用来绘制到屏幕上。</p><h2 id="实现">实现</h2><p>首先还是新建两个类，一个Feature一个Pass<br />为了之后的通用性，设计成<code>RenderObjectsToRTHandleFeature</code>，即使用设定的Material，把指定层级或渲染层的物体绘制到一张临时RT上。</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public class RenderObjectsToRTHandleFeature : ScriptableRendererFeature&#123;    public string textureName &#x3D; &quot;_CustomTexture&quot;;    public Material material;    public RenderPassEvent renderPassEvent &#x3D; RenderPassEvent.BeforeRenderingOpaques;    public bool useDepth;    public RenderTextureFormat textureFormat;    [Header(&quot;Filter&quot;)]     public LayerMask layerMask;    public RenderingLayerMask renderingLayerMask;    &#x2F;&#x2F; todo 做成列表的形式，用TextureArray来实现，问题是在XR中如何获取    &#x2F;&#x2F; public List&lt;RenderingLayerMask&gt; layerMaskList;     RenderObjectsToRTHandlePass renderObjectsToRTHandlePass;    public override void Create()    &#123;        renderObjectsToRTHandlePass &#x3D; new RenderObjectsToRTHandlePass(name, layerMask, renderingLayerMask, textureName, useDepth,textureFormat)        &#123;            renderPassEvent &#x3D; renderPassEvent        &#125;;    &#125;    public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData)    &#123;        &#x2F;&#x2F; if (material &#x3D;&#x3D; null)        &#x2F;&#x2F; &#123;        &#x2F;&#x2F;     Debug.Log(&quot;material is null. RenderObjectsToRTHandle pass will not execute.&quot;);        &#x2F;&#x2F;     return;        &#x2F;&#x2F; &#125;        renderObjectsToRTHandlePass.Setup(material);        renderer.EnqueuePass(renderObjectsToRTHandlePass);    &#125;    protected override void Dispose(bool disposing)    &#123;        base.Dispose(disposing);        renderObjectsToRTHandlePass?.Dispose();        renderObjectsToRTHandlePass &#x3D; null;    &#125;&#125;</code></pre></div></figure><p>这里主要设定了临时RT的名称，材质，RednerPass的插入时间，是否使用深度，RT的格式，以及要绘制的物体的层和渲染层。<br />对应到要绘制深度图的话，那就是如下的设置<br /><img src="thickness-bone-setting.png" alt="深度图设置" /><br />然后具体看看Pass的实现<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System.Collections.Generic;using UnityEngine;using UnityEngine.Rendering;using UnityEngine.Rendering.Universal;public class RenderObjectsToRTHandlePass : ScriptableRenderPass&#123;    private Material m_thicknessMaterial;    private FilteringSettings m_filteringSettings;    private readonly ProfilingSampler m_ProfilingSampler;    readonly List&lt;ShaderTagId&gt; m_ShaderTagIdList &#x3D; new();    private readonly string k_TextureName;    private RTHandle m_ColorTexture;    private RTHandle m_DepthTexture;    private bool m_UseDepth;    private RenderTextureFormat m_RenderTextureFormat;    public RenderObjectsToRTHandlePass(string profilerTag, LayerMask layerMask, RenderingLayerMask renderingLayerMask,        string textName, bool useDepth, RenderTextureFormat renderTextureFormat)    &#123;        profilingSampler &#x3D; new ProfilingSampler(nameof(RenderObjectsToRTHandlePass));        m_ProfilingSampler &#x3D; new ProfilingSampler(profilerTag);        m_UseDepth &#x3D; useDepth;        m_RenderTextureFormat &#x3D; renderTextureFormat;        m_filteringSettings &#x3D; new FilteringSettings(RenderQueueRange.opaque, layerMask.value, renderingLayerMask.Value);        m_ShaderTagIdList.Add(new ShaderTagId(&quot;SRPDefaultUnlit&quot;));        m_ShaderTagIdList.Add(new ShaderTagId(&quot;UniversalForward&quot;));        m_ShaderTagIdList.Add(new ShaderTagId(&quot;UniversalForwardOnly&quot;));        k_TextureName &#x3D; textName;    &#125;    public void Setup(Material thicknessMaterial)    &#123;        m_thicknessMaterial &#x3D; thicknessMaterial;    &#125;    public override void OnCameraSetup(CommandBuffer cmd, ref RenderingData renderingData)    &#123;        RenderTextureDescriptor cameraTargetDescriptor &#x3D; renderingData.cameraData.cameraTargetDescriptor;        RenderTextureDescriptor thicknessDesc &#x3D; cameraTargetDescriptor;        thicknessDesc.msaaSamples &#x3D; 1;        thicknessDesc.depthBufferBits &#x3D; 0;        thicknessDesc.colorFormat &#x3D; m_RenderTextureFormat;        RenderingUtils.ReAllocateIfNeeded(ref m_ColorTexture, thicknessDesc, FilterMode.Bilinear,            TextureWrapMode.Clamp, name: k_TextureName);        if (m_UseDepth)        &#123;            var depthDesc &#x3D; renderingData.cameraData.cameraTargetDescriptor;            depthDesc.depthBufferBits &#x3D; 32; &#x2F;&#x2F; should be default anyway            RenderingUtils.ReAllocateIfNeeded(ref m_DepthTexture, depthDesc, name: k_TextureName + &quot;Depth&quot;);            ConfigureTarget(m_ColorTexture, m_DepthTexture);        &#125;        else        &#123;            ConfigureTarget(m_ColorTexture);        &#125;        if (m_UseDepth)        &#123;            ConfigureClear(ClearFlag.All, Color.black);        &#125;        else            ConfigureClear(ClearFlag.Color, Color.black);    &#125;    public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)    &#123;        SortingCriteria sortingCriteria &#x3D; renderingData.cameraData.defaultOpaqueSortFlags;        DrawingSettings drawingSettings &#x3D; CreateDrawingSettings(m_ShaderTagIdList, ref renderingData, sortingCriteria);        if (m_thicknessMaterial !&#x3D; null)        &#123;            drawingSettings.overrideMaterial &#x3D; m_thicknessMaterial;            drawingSettings.overrideMaterialPassIndex &#x3D; 0;        &#125;        var cmd &#x3D; CommandBufferPool.Get();        using (new ProfilingScope(cmd, m_ProfilingSampler))        &#123;            context.ExecuteCommandBuffer(cmd);            cmd.Clear();            &#x2F;&#x2F; context.SetupCameraProperties(renderingData.cameraData.camera);            context.DrawRenderers(renderingData.cullResults, ref drawingSettings, ref m_filteringSettings);            cmd.SetGlobalTexture(k_TextureName, m_ColorTexture);            &#x2F;&#x2F; cmd.SetGlobalTexture(&quot;_ThicknessTextureArray&quot;, m_ThicknessTexture);        &#125;        context.ExecuteCommandBuffer(cmd);        cmd.Clear();        CommandBufferPool.Release(cmd);    &#125;    public void Dispose()    &#123;        m_ColorTexture?.Release();    &#125;    public override void OnCameraCleanup(CommandBuffer cmd)    &#123;    &#125;&#125;</code></pre></div></figure><br />总之就是沿用Feature的参数，申请各种RT，然后配置各种渲染参数，最终绘制到指定的RT上。</p><h2 id="shader">shader</h2><p>最后就是看看Shader吧。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">Shader &quot;Unlit&#x2F;Thickness&quot;&#123;    Properties    &#123;    &#125;    SubShader    &#123;        Tags        &#123;            &quot;RenderType&quot; &#x3D; &quot;Opaque&quot; &quot;RenderPipeline&quot; &#x3D; &quot;UniversalPipeline&quot;        &#125;        Pass        &#123;            Name &quot;ComputeThickness&quot;            Tags            &#123;                &quot;LightMode&quot; &#x3D; &quot;Forward&quot;            &#125;            ZWrite Off            ZTest Always            Cull Off            Blend One One            BlendOp Add            HLSLPROGRAM            #pragma vertex vert            #pragma fragment frag            #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;            struct Attributes            &#123;                float4 positionOS : POSITION;                UNITY_VERTEX_INPUT_INSTANCE_ID            &#125;;            struct Varyings            &#123;                float4 positionHCS : SV_POSITION;                UNITY_VERTEX_OUTPUT_STEREO            &#125;;            Varyings vert(Attributes IN)            &#123;                Varyings OUT;                UNITY_SETUP_INSTANCE_ID(IN);                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(OUT);                OUT.positionHCS &#x3D; TransformObjectToHClip(IN.positionOS.xyz);                return OUT;            &#125;            float2 frag(Varyings IN, bool isFrontFace : SV_IsFrontFace) : SV_Target            &#123;                UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);                float usedDepth &#x3D; LinearEyeDepth(IN.positionHCS.z, _ZBufferParams);                float sign &#x3D; isFrontFace ? -1.0f : 1.0f;                float value &#x3D; sign * usedDepth;                float2 color &#x3D; float2(value, 1);                return color;            &#125;            ENDHLSL        &#125;    &#125;&#125;</code></pre></div></figure><br />和hdrp的实现基本一致，增加了一些URP要求的配置而已。</p><h1 id="全屏绘制">全屏绘制</h1><p>这里就用ShaderGraph来绘制吧<br /><img src="thickness-sg.png" alt="Shader Graph" /><br />可以同时启用多个厚度图Feature，每个都绘制到不同的RT上，然后在SG中根据权重来混合。</p><p>比如这里就根据骨骼和身体的不同厚度，来赋予不同的权重，就可以得到X射线的效果。<br /><img src="thickness-setting.png" alt="Render Feature Settings" /><br />如果想更细致一点，还可以用身体厚度减去骨骼。</p><h1 id="renderinglayermask">RenderingLayerMask</h1><p>Unity并未对RenderingLayerMask提供对应的在Inspector中方便可用的下拉列表实现，这次就顺便实现一个。</p><p>首先定义下结构体<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">[System.Serializable]public struct RenderingLayerMask&#123;    [SerializeField]    private uint m_Mask;    public static implicit operator uint(RenderingLayerMask mask) &#x3D;&gt; mask.m_Mask;    public static implicit operator RenderingLayerMask(uint uintVal)    &#123;        RenderingLayerMask renderingLayerMask;        renderingLayerMask.m_Mask &#x3D; uintVal;        return renderingLayerMask;    &#125;    public uint Value    &#123;        get &#x3D;&gt; this.m_Mask;        set &#x3D;&gt; this.m_Mask &#x3D; value;    &#125;&#125;</code></pre></div></figure><br />然后是对应的PropertyDrawer<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">[CustomPropertyDrawer(typeof(RenderingLayerMask))]public class RenderingLayerMaskDrawer : PropertyDrawer&#123;    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)    &#123;        EditorGUI.BeginProperty(position, label, property);        position &#x3D; EditorGUI.PrefixLabel(position, GUIUtility.GetControlID(FocusType.Passive), label);        var indent &#x3D; EditorGUI.indentLevel;        EditorGUI.indentLevel &#x3D; 0;        var amountRect &#x3D; new Rect(position.x, position.y, position.width, position.height);        var mask &#x3D; property.FindPropertyRelative(&quot;m_Mask&quot;);        var selected &#x3D; (int)mask.uintValue;        var options &#x3D; GraphicsSettings.defaultRenderPipeline.renderingLayerMaskNames;        selected &#x3D; EditorGUI.MaskField(amountRect, selected, options);        mask.uintValue &#x3D; (uint)selected;        EditorGUI.indentLevel &#x3D; indent;        EditorGUI.EndProperty();    &#125;&#125;</code></pre></div></figure></p><p>大体思路是通过<code>GraphicsSettings.defaultRenderPipeline.renderingLayerMaskNames;</code>来获取全部maskname，然后利用EditorGUI.MaskField来选择。<br /><img src="RenderLayerMask.png" alt="RenderLayerMask" /></p>]]></content>
    
    
    <categories>
      
      <category>渲染</category>
      
    </categories>
    
    
    <tags>
      
      <tag>URP</tag>
      
      <tag>厚度图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物理</title>
    <link href="/2023/04/24/Physics/"/>
    <url>/2023/04/24/Physics/</url>
    
    <content type="html"><![CDATA[<h1 id="物理">物理</h1><p>流水账的记录一下Unity中和物理相关的一点坑</p><h1 id="碰撞">碰撞</h1><h1 id="碰撞体类型">碰撞体类型</h1><ul><li>静态碰撞体</li><li>刚体碰撞体</li><li>运动刚体碰撞体</li></ul><p>没有刚体的称为静态，反之称为动态/刚体碰撞体。<br />刚体碰撞体再按照有咩有勾选运动（IsKinematic）分为普通刚体碰撞体和运动刚体碰撞体</p><h1 id="复合碰撞体">复合碰撞体</h1><p>需要在父物体触发OnCollider或者OnTrigger的话，父物体需要一个刚体。</p><h1 id="meshcollider">MeshCollider</h1><p>对于非凸面（一般）网格碰撞体，碰撞仅发生在面上，体积内没有碰撞。仅正面有碰撞，法线反面没有。<br />勾选成凸面后，会存在体积。默认的box，胶囊，球体等都算凸面。<br />网格碰撞体无法与另一个网格碰撞体碰撞</p><p>普通的网格碰撞体无法充当触发器（没有体积概念），勾选成凸面可以充当，但凸面只是近似，而且有面数限制（255）。</p><p>非凸网格运动刚体可以触发触发器。</p><h2 id="限制">限制</h2><ul><li>非凸网格和非运动刚体不能同时启用</li><li>非凸网格也不能充当触发器</li></ul><h1 id="碰撞检测">碰撞检测</h1><h2 id="离散">离散</h2><p>默认，没啥好说的</p><h2 id="连续">连续</h2><p>对于所有静态碰撞体，使用CCD。<br />对于动态的碰撞体，还是离散。<br />适用于与静态物体高速碰撞。</p><h2 id="动态连续">动态连续</h2><p>对除了设置为离散的碰撞体之外的碰撞体，CCD<br />适用于对任何碰撞体高速碰撞。</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>物理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lighting</title>
    <link href="/2023/02/24/Lighting/"/>
    <url>/2023/02/24/Lighting/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>随便记一下HDRP中打光和烘培的一些要点和坑</p><h1 id="光的来源">光的来源</h1><p>大致分实时光和烘焙光。</p><h1 id="实时光">实时光</h1><p>来自于实时平行光、点光等。</p><h1 id="烘焙">烘焙</h1><p>可以是光照贴图，或者光照探针。</p><h1 id="烘焙注意点">烘焙注意点</h1><ul><li>模型的光照UV是否合理<ul><li>重叠</li><li>不相邻或者角度差距多大而UV却靠在一起</li></ul></li><li>注意单面<ul><li>尽量防止要渲染的面可以“看到”反面</li><li>注意单面处的阴影漏光（添加额外的提供阴影的物体）</li></ul></li><li>室内场景注意反弹次数，大于10</li><li>噪点产生原因<ul><li>采样次数太少导致随机性<ul><li>分析是环境采样太少还是间接照明反射太少</li></ul></li></ul></li><li>面光补光注意光照强度是平均分部到面上每个点的</li><li>面光强度和距离平方成反比，不应该拿来作为窗口补光，要调整天空的曝光强度。</li><li>Debug时关闭过滤，调整至没有黑块且大致均匀后再过滤。</li></ul><h1 id="背面问题">背面问题</h1><p>没有银弹，只能根据不同的模型，不同的精度需求来调整。大致调整的方向如下：<br />尽量减少背面，力求模型全封闭且没有重叠的面。</p><p>上述条件很难达成，为了模型的简洁，不可能保证没有重叠的面，而且场景中也不能保证没有重叠的面。<br />这时要调整<code>Backface Tolerance</code>，意指如何确定一个面是朝向背面的。目的是确保不计算朝向背面的无效面，然后用周围的像素来填充，防止黑色块扩散。<br />但是这个值如果调整过大，会导致很多本是正常的面也计入无效面，即使填充周围像素，也有可能不能覆盖，导致大范围的黑色色块。<br />而如果这个值太小，会导致本该无效的面被记为有效面，然后无效面的黑色会渗出到周围，也会导致黑色块。</p><p>所以应该宁可面被判定无效然后被周围填充，也不能让无效面被判定有效导致污染贴图。</p><p>还有和分辨率相关的问题，如果一个模型在光照贴图中的占比太小，光照贴图中的一个像素对应到场景中，有两种状态，也会导致伪影。常见于各个模型的拼接处，但这种一般会被周围的像素来填充，影响不太大。</p><h1 id="双面问题">双面问题</h1><p>不要滥用双面来解决背面问题。一是增加了渲染压力，二是本该无效的面，因为启用了双面导致了成为了有效面，然后又没有光照，黑色会渗出。<br />具体黑色渗出的范围和<code>Lightmap Padding</code>有关。</p><h1 id="单位">单位</h1><h2 id="candela">candela</h2><p>是发光强度（人眼感知到的可见光的亮度，光束在特定方向上的亮度）的单位，简称“坎”，符号cd。普通蜡烛的发光强度1cd。</p><h2 id="lumen">Lumen</h2><p>光通量，光源发出的可见光总量的量度。从一球面度发出一cd光源的光具有一流明的光通量。</p><h2 id="lux">Lux</h2><p>每平方米流明。<br />照度单位。向 1 平方米的面积上发出 1 流明光通量的光源的照度为 1勒克斯。</p><h2 id="nits">Nits</h2><p>尼特（坎德拉每平方米）<br />亮度单位。描述可见光源的表面功率。当使用这个单位时，光源的总功率取决于光源的大小。</p><h2 id="exposure-value-ev">Exposure value (EV)</h2><p>曝光值。<br />EV指快门速度与光圈f值的组合。<br />EV100指当感光度为ISO100、光圈系数为F1、曝光时间为1秒时，曝光量定义为0。</p>]]></content>
    
    
    <categories>
      
      <category>渲染</category>
      
    </categories>
    
    
    <tags>
      
      <tag>烘焙</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDRP中的次表面散射</title>
    <link href="/2023/02/13/sss/"/>
    <url>/2023/02/13/sss/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>今天来研读一下HDRP的屏幕空间次表面散射的<ahref="http://advances.realtimerendering.com/s2018/Efficient%20screen%20space%20subsurface%20scattering%20Siggraph%202018.pdf">实现</a>。</p><h1 id="次表面散射">次表面散射</h1><p>不多介绍了，就是模拟光线在介质中传播，常用于皮肤、植被、蜡烛等半透明的材质。</p><h1 id="双向次表面散射反射率分部函数">双向次表面散射反射率分部函数</h1><p><code>bidirectional subsurface scattering reflectance distribution functio</code>简称<code>BSSRDF</code><br />从名字大致能看出来是和<code>BSDF</code>类似的，但是考虑了次表面散射的因素。</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>s</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>p</mi><mrow><mi>e</mi><mi>n</mi><mi>t</mi><mi>r</mi><mi>y</mi></mrow></msub><mo separator="true">,</mo><msub><mi>p</mi><mrow><mi>e</mi><mi>x</mi><mi>i</mi><mi>t</mi></mrow></msub><mo separator="true">,</mo><mi>l</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mi>c</mi><msub><mi>F</mi><mi>t</mi></msub><mo stretchy="false">(</mo><msub><mi>p</mi><mrow><mi>e</mi><mi>n</mi><mi>t</mi><mi>r</mi><mi>y</mi></mrow></msub><mo separator="true">,</mo><mi>l</mi><mo stretchy="false">)</mo><mi>R</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><msub><mi>p</mi><mrow><mi>e</mi><mi>n</mi><mi>t</mi><mi>r</mi><mi>y</mi></mrow></msub><mo>−</mo><msub><mi>p</mi><mrow><mi>e</mi><mi>x</mi><mi>i</mi><mi>t</mi></mrow></msub><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo><msub><mi>F</mi><mi>t</mi></msub><mo stretchy="false">(</mo><msub><mi>p</mi><mrow><mi>e</mi><mi>x</mi><mi>i</mi><mi>t</mi></mrow></msub><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f_{ss}(p_{entry},p_{exit},l,v)=cF_t(p_{entry},l)R(||p_{entry}-p_{exit}||)F_t(p_{exit},v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.28055599999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathnormal">c</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.28055599999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.28055599999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord">∣</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span><p>R 是扩散分布，F_t 是菲涅耳，C 是归一化常数</p><h1 id="实时实现">实时实现</h1><p>上述只是理论，第一个实时的实现由<code>Eugene d’Eon</code>提出。<br />使用高斯分布混合来拟合扩散剖面。<br />选择高斯有几个原因：</p><ul><li>足够简单方便</li><li>高斯卷积可分解，因此有线性而不是二次的复杂性。</li><li>使用“较小”高斯的重复卷积等同于使用“较大”高斯的单次卷积。</li></ul><p>可分离的次表面散射的问题</p><ul><li>高斯卷积是可分离的，因此速度很快<ul><li>只有在平面上过滤时才可分离</li></ul></li><li>双边滤波让卷积“伪可分离”<ul><li>结果在视觉上是合理的</li></ul></li><li>高斯混合公式显然是不可分离的，除非你对每个高斯执行 2 次卷积传递<ul><li>可能导致 Somewhat Separable Screen SpaceSSS(SSSSSSS)，这可能会导致必须在内容端修复的伪像</li><li>为 2 个高斯执行 4 次传递在实践中成本太高</li></ul></li><li>对艺术家不友好<ul><li>这只是个数学概念</li><li>自由度太高</li><li>非直觉</li></ul></li></ul><p>虽然效果很好，但还是过于昂贵。所以需要一种屏幕空间的实现方式。<br />而且参数太多，不直观</p><h1 id="burley的归一化扩散模型">Burley的归一化扩散模型</h1><p>又名<code>Disney SSS</code>。<br />它为使用蒙特卡洛暴力模拟获得的参考数据（无偏解）提供了准确的拟合。(说人话就是和现实情况很匹配)<br />自然地，这意味着要同时考虑单次和多次散射。</p><p>它只有两个参数：体积反照率 A 和形状参数s。它们都可以解释为颜色。<br /><img src="/images/sss_p.png" /><br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><mi>A</mi><mi>s</mi><mfrac><mrow><msup><mi>e</mi><mrow><mo>−</mo><mi>s</mi><mi>r</mi></mrow></msup><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>s</mi><mi>r</mi><mi mathvariant="normal">/</mi><mn>3</mn></mrow></msup></mrow><mrow><mn>8</mn><mi>π</mi><mi>r</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">R(r)=As\frac{e^{-sr}+e^{-sr/3}}{8\pi r} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.4157em;vertical-align:-0.345em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">s</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0707em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8476642857142858em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9667142857142857em;"><span style="top:-2.966714285714285em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5357142857142856em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mtight">/</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>形状参数与散射距离成反比。<br />这里有两个特点：</p><ul><li>形状尖峰和长尾都是高斯分布做不到的</li><li>显然是不可分离的</li></ul><p>扩散分布被归一化，以用作概率密度函数。</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∫</mo><mn>0</mn><mrow><mn>2</mn><mi>π</mi></mrow></msubsup><msubsup><mo>∫</mo><mn>0</mn><mi mathvariant="normal">∞</mi></msubsup><mi>r</mi><mi>R</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mi>d</mi><mi>r</mi><mi>d</mi><mi>ϕ</mi><mo>=</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\int_0^{2\pi}\int_0^\infty rR(r)drd\phi =A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3648280000000002em;vertical-align:-0.35582em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0090080000000001em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35582em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8592920000000001em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35582em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">d</span><span class="mord mathnormal">ϕ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span><p><br><br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>r</mi><mi>R</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><mi>A</mi></mfrac></mrow><annotation encoding="application/x-tex">p(r) = \frac{rR(r)}{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br />散射距离在像素的尺寸上时，漫反射BRDF近似于SSS。<br />这意味这这两个着色模型在一定距离后应该有相同的视觉效果。</p><p>提供了两种反照率选项</p><ol type="1"><li>散射后贴图，包含了SSS引起的渗色，如照片等，这样就只在出口出应用反照率。</li><li>散射前和散射后贴图</li></ol><h1 id="实现">实现</h1><p>在屏幕空间执行卷积，并使用深度缓冲来考虑表面几何形状。<br />精确的执行全部卷积显然是不可能的，这就应用到了之前的概率密度函数，采样像素的周围一定半径的圆盘，然后乘以权重并累计。最后得到次表面散射结果。<br />具体的如何依据重要度采样，采样圆盘如何投影到物体表面，就无力再细究了。有兴趣的去啃原文吧。</p><h1 id="透射">透射</h1><p>出于性能的考虑，给出了两种方式来实现，一种只适用于薄物体，第二种处理更一般的半透明情况。</p><p>前者unity采用了一个简化的模型：</p><ul><li>几何形状是厚度恒定的平面版</li><li>背面法线是反转的正面法线</li><li>厚度在纹理中提供</li><li>整个背面都接收恒定的光照</li></ul><h2 id="厚度图">厚度图</h2><p>基于上面的简化模型，我们需要手动制作一张厚度图。<br />以斯坦福兔子为例，找个分好UV的，丢到SubstancePainter中，烘培一下就好。</p><h1 id="unity中参数的影响">Unity中参数的影响</h1><p>有上面的基础，就大概能理解Unity中的各项参数对效果和性能的影响了。</p><h2 id="配置">配置</h2><p>HDRP配置中的<code>Subsurface Scattering</code>，开启关闭次表面效果<br /><code>Smaple Budget</code>对应不同挡位的采样次数。<br />在<code>HDRP全局设置</code>中，FrameSettings中可以具体设置采样次数是按预设还是自定义。</p><h2 id="扩散剖面">扩散剖面</h2><p>支持最多15个扩散剖面，要预先添加到HDRP设置中<br />最后来看看这里的参数<br /><code>scatering distance</code>:散射距离，三个通道分别定义了RGB的散射距离，单位mm。距离越大，光线可以散射的距离越大，看起来就越通透。<br /><img src="rab-0.png" alt="0" /><br /><img src="rab-5.png" alt="4" /><br /><img src="rab-6.png" alt="6" /><br /><img src="rab-8.png" alt="8" /><br /><code>Max Radius</code>:最大半径，用于显示在散射距离中定义的效果的有效最大半径（以毫米为单位）。不能直接更改此值。<br /><code>Index of refraction</code>：折射率，值越大，镜面反射的强度就越大。例如，皮肤的折射率约为1.4。有关不同材料的折射率的更多示例值，请参阅像素和多边形<ahref="https://pixelandpoly.com/ior.html">折射值指标列表</a><br /><code>world scale</code>：世界缩放比例。<br /><code>textureing mode</code>：贴图模式，对应了上面的两种模式。<br /><code>Transmission Mode</code>：透光模式：两种模式</p><ul><li>Thin Object</li><li>Thick Object</li></ul><p><code>Transmission tint</code>：透射色调，最终的颜色与散射距离也有关系。<br /><code>Thickness Remap</code>：厚度重映射，对应厚度图的[0,1]，到实际厚度的重映射。单位mm。<br /><img src="/images/sss-head-tex.png" /><br /><img src="/images/sss-without.png" /></p><p>所以最终的效果还是要看贴图质量，简单的玉石、蜡烛、树叶之类的还能简单的调一调，人物要想手动调整可太难了。所以还是寄希望于CC3，Daz之类吧。</p>]]></content>
    
    
    <categories>
      
      <category>渲染</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>布料模拟方案汇总</title>
    <link href="/2023/02/10/cloth/"/>
    <url>/2023/02/10/cloth/</url>
    
    <content type="html"><![CDATA[<h1 id="布料模拟">布料模拟</h1><p>总结一下常见的布料模拟的方案</p><h1 id="k动画">K动画</h1><p>最传统，同时在某些特定场景下也是最简单有效的手段了，比如固定不动的随风摆动的窗帘。<br />没什么好说的，存粹看美术的工作量了。</p><h1 id="绑定动态骨骼">绑定+动态骨骼</h1><p>基于前一种，绑定好骨骼后，用物理模拟的方式去驱动骨骼的变化，进而模拟布料。<br />最知名的应该就是<code>Dynamic Bone</code>这个插件了。<br />能想到的场景比如人物的头发，裙摆等，都很适合这种方案。性能需求小，多平台支持，也有一定的动态。</p><h1 id="粒子模拟">粒子模拟</h1><p>这里有两种方案：</p><ol type="1"><li>官方的<code>Cloth Component</code>应该是基于PhysX物理引擎的。</li><li>做粒子模拟知名的厂商<code>Obi</code>提供的<code>Obi Cloth</code>，基于<code>Burst</code>。</li></ol><p>前者可以复用Unity中的各种碰撞体，后者的侵入性就很强了，需要单独的解算器，各种碰撞也都要添加额外组件。<br />因为后者依赖于<code>Burst</code>，一些没有<code>Burst</code>支持的平台如web就无法使用了。</p><h1 id="提前解算abc动画导入">提前解算+ABC动画导入</h1><p>仅针对固定的布料动画，且不支持安卓或web。<br />提前在Maya、Blender或者MD中烘焙顶点动画，导出abc文件，然后在Unity中播放。<br />毕竟是离线的烘培，效果应该是所有方案中最好的，非常适合一些固定的动画，比如过场动画、固定的飘动的旗帜等等。<br /><img src="/images/cloth.gif" /></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>布料</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线框绘制</title>
    <link href="/2023/02/09/wireframe/"/>
    <url>/2023/02/09/wireframe/</url>
    
    <content type="html"><![CDATA[<h1 id="线框渲染">线框渲染</h1><p>最近写代码快写吐了，写点Shader缓解一下。<br />今天就复刻一个线框渲染吧，顺便温习一下几何着色器的用法。<br />参考列在前面</p><ul><li><ahref="https://www.bilibili.com/read/cv3168157">在unity中实现风格化线框渲染</a></li><li><ahref="https://zhuanlan.zhihu.com/p/585436751">几何着色器（GeometryShader）的基础介绍以及简单示例</a></li></ul><h1 id="几种方式">几种方式</h1><p>总结一下各种实现的方法</p><ul><li>生成线框模型</li><li>线框贴图</li><li>写入UV</li><li>利用GL来绘制线框</li><li>几何着色器<ul><li>用几何着色器的<code>LineStream</code>来生成线段图元</li><li>用几何着色器来生成片元相对线框的SDF，然后利用SDF绘制线框</li></ul></li></ul><h1 id="生成线框模型">生成线框模型</h1><p>最直观最简单的方法了，比如Blender就自带线框修改器，可以吧模型之间转成线框模型输出。<br />缺点是显而易见的，模型的面数成倍增加，模型也不能复用，增加文件体积，以后模型要修改还要再重复这个过程。<br />好处就是简单，而且不受平台的限制，下面罗列的使用几何着色器的方法在比如Web平台就无法实现。<br /><img src="w-blender.png" alt="线框修改器" /></p><h1 id="线框贴图">线框贴图</h1><p>实现也比较容易，UV全展开不重叠，或者完全相同的重叠也行，然后在需要渲染线框的地方绘制就好。<br />想要程序化生成可以使用Blender的烘焙，把线框烘焙到贴图上输出即可。<br />这种方式对贴图的精度要求就很高了，分辨率会很大。<br />或者改进一下，参照之前<ahref="/2022/12/26/draw/">模型上喷涂绘制</a>的方式，改成用SDF来做，贴图可以使用很低的分辨率。<br />但这样程序化生成会比较麻烦</p><p>也可以和下面的几何着色器的方式结合起来，用之前喷涂的思路，把SDF烘焙到一张贴图上，就可以在不支持几何着色器的平台上使用了。</p><h1 id="写入uv">写入UV</h1><p>还有一种骚操作，把模型改成四边面，然后每个面都完全展开UV，然后根据UV判断片元是否是边框。<br />缺点显而易见，每个面的大小不同，线框的大小也就各不相同了。</p><h1 id="利用gl来绘制线框">利用GL来绘制线框</h1><p>来自<ahref="https://www.jianshu.com/p/e95e6507659c">这篇文章</a>，我还真没有想到还有这种做法。<br />大致思路是读模型顶点，存到内存，然后调用<code>GL.Vertex</code>等方法一根一根的绘制。<br />感觉有点太暴力了，效率上会很低。但确实也算很简单有效的方法，而且自由度很高，针对一些特定场景也许很有用吧。</p><h1 id="几何着色器">几何着色器</h1><p>这里又大致分为两类</p><ol type="1"><li>直接用几何着色器的<code>LineStream</code>来生成线段图元。</li><li>利用几何着色器来生成片元相对线框的SDF，然后利用SDF绘制线框。</li></ol><p>先复习一下几何着色器的使用。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl">Shader &quot;Custom&#x2F;SimpleGeometryShader&quot; &#123;    Properties &#123;        _Color (&quot;Color&quot;, Color) &#x3D; (1,1,1,1)    &#125;    SubShader &#123;        Tags &#123;&quot;RenderType&quot;&#x3D;&quot;Opaque&quot;&#125;        LOD 200        Pass &#123;            HLSLPROGRAM            #pragma vertex vert            #pragma fragment frag            #pragma geometry geom                        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;            struct appdata &#123;                float4 vertex : POSITION;            &#125;;                        struct v2g &#123;                float4 vertex : SV_POSITION;            &#125;;            struct g2f &#123;                float4 vertex : SV_POSITION;            &#125;;            uniform float4 _Color;            v2g vert (appdata v) &#123;                v2g o;                o.vertex &#x3D; TransformObjectToHClip(v.vertex);                return o;            &#125;            float4 frag (g2f i) : SV_Target &#123;                return _Color;            &#125;            [maxvertexcount(3)]            void geom(triangle v2g IN[3], inout TriangleStream&lt;g2f&gt; Out) &#123;                                for(int i &#x3D; 0; i &lt; 3; i++) &#123;                    g2f o;                    o.vertex &#x3D; IN[i].vertex;                    Out.Append(o);                &#125;            &#125;            ENDHLSL        &#125;    &#125;    FallBack &quot;Diffuse&quot;&#125;</code></pre></div></figure><br />这就是最最简单的几何着色器了，什么都没有干，输入什么就输出什么，没有一点改动。</p><h2 id="linestream">LineStream</h2><p>第一种很简单：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl">[maxvertexcount(3)]void geom(triangle  v2g IN[3], inout LineStream&lt;g2f&gt; Out)&#123;    g2f o1 &#x3D; (g2f)0;    g2f o2 &#x3D; (g2f)0;    g2f o3 &#x3D; (g2f)0;    o1.vertex &#x3D; IN[0].vertex;    o2.vertex &#x3D; IN[1].vertex;    o3.vertex &#x3D; IN[2].vertex;        Out.Append(o1);    Out.Append(o2);    Out.Append(o3);&#125;</code></pre></div></figure><br />但是这种方式只能生成线段了，如果想要扩充或者调整线段的粗细，就会很麻烦了。</p><h3 id="四边形">四边形</h3><p>剔除最长的那条边<br /><figure><div class="code-wrapper"><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl">[maxvertexcount(4)]void geom(triangle v2g IN[3], inout LineStream&lt;g2f&gt; Out)&#123;    g2f o1 &#x3D; (g2f)0;    g2f o2 &#x3D; (g2f)0;    g2f o3 &#x3D; (g2f)0;    o1.vertex &#x3D; IN[0].vertex;    o2.vertex &#x3D; IN[1].vertex;    o3.vertex &#x3D; IN[2].vertex;        float Edge1 &#x3D; length(IN[0].modelPos - IN[1].modelPos);    float Edge2 &#x3D; length(IN[1].modelPos - IN[2].modelPos);    float Edge3 &#x3D; length(IN[2].modelPos - IN[0].modelPos);        if (Edge1 &gt; Edge2 &amp;&amp; Edge1 &gt; Edge3)    &#123;        Out.Append(o2);        Out.Append(o3);        Out.RestartStrip();        Out.Append(o3);        Out.Append(o1);        Out.RestartStrip();    &#125;    else if (Edge2 &gt; Edge1 &amp;&amp; Edge2 &gt; Edge3)    &#123;        Out.Append(o1);        Out.Append(o2);        Out.RestartStrip();        Out.Append(o3);        Out.Append(o1);        Out.RestartStrip();    &#125;    else if (Edge3 &gt; Edge1 &amp;&amp; Edge3 &gt; Edge2)    &#123;        Out.Append(o1);        Out.Append(o2);        Out.RestartStrip();        Out.Append(o2);        Out.Append(o3);        Out.RestartStrip();    &#125;&#125;</code></pre></div></figure></p><h2 id="trianglestream">TriangleStream</h2><p>第二种，生成片元相对线框的SDF。</p><h3 id="插值">插值</h3><p>在g2f中增加一项<br /><figure><div class="code-wrapper"><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl">struct g2f &#123;    float4 vertex : SV_POSITION;    float3 barycentric : TEXCOORD0;&#125;;</code></pre></div></figure><br />几何着色器中手动赋值，并重新插值。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl">[maxvertexcount(3)]void geom(triangle v2g IN[3], inout TriangleStream&lt;g2f&gt; Out) &#123;    g2f o1, o2, o3;    o1.vertex &#x3D; IN[0].vertex;    o2.vertex &#x3D; IN[1].vertex;    o3.vertex &#x3D; IN[2].vertex;    o1.barycentric &#x3D; float3(1, 0, 0);    o2.barycentric &#x3D; float3(0, 1, 0);    o3.barycentric &#x3D; float3(0, 0, 1);    Out.Append(o1);    Out.Append(o2);    Out.Append(o3);    Out.RestartStrip();&#125;</code></pre></div></figure><br />然后在片元中输出看看：<br /><img src="w-frag.png" alt="插值后结果" /></p><h3 id="到边的距离">到边的距离</h3><p>这就是片元中每个像素到各个顶点的距离了（每个分量），取最小值就是到各个边的距离：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl">float4 frag (g2f i) : SV_Target &#123;    float minV &#x3D; min(i.barycentric.x, min(i.barycentric.y, i.barycentric.z));    return float4(minV,minV,minV,1);&#125;</code></pre></div></figure><br /><img src="w-min.png" alt="到边的SDF" /><br />然后用阈值去掐一下：<br /><img src="w-step.png" alt="线框" /></p><h3 id="剔除">剔除</h3><p>看到背面被剔除了，再修改下，增加<code>Cull Off</code><br /><figure><div class="code-wrapper"><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl">float4 frag (g2f i) : SV_Target &#123;    float minV &#x3D; min(i.barycentric.x, min(i.barycentric.y, i.barycentric.z));    float v &#x3D; step(minV, _Size);    clip(v-0.5);    return float4(v,v,v,1);&#125;</code></pre></div></figure><br /><img src="w-cull.png" alt="背面显示" /></p><h3 id="均匀线框">均匀线框</h3><p>还有个问题，这里不同片元所在的三角大小不同，这个胶囊中间的三角形的线框就特别大。<br />所以在给每个顶点赋值时，不统一使用1，而是在模型空间算出其顶点到对边的距离：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl">[maxvertexcount(3)]void geom(triangle v2g IN[3], inout TriangleStream&lt;g2f&gt; Out) &#123;    g2f o1, o2, o3;    o1.vertex &#x3D; IN[0].vertex;    o2.vertex &#x3D; IN[1].vertex;    o3.vertex &#x3D; IN[2].vertex;    float dis1 &#x3D; GetDistance(IN[1].modelPos,IN[2].modelPos,IN[0].modelPos);    float dis2 &#x3D; GetDistance(IN[0].modelPos,IN[2].modelPos,IN[1].modelPos);    float dis3 &#x3D; GetDistance(IN[0].modelPos,IN[1].modelPos,IN[2].modelPos);        o1.barycentric &#x3D; float3(dis1, 0, 0);    o2.barycentric &#x3D; float3(0, dis2, 0);    o3.barycentric &#x3D; float3(0, 0, dis3);    Out.Append(o1);    Out.Append(o2);    Out.Append(o3);    Out.RestartStrip();&#125;</code></pre></div></figure><br /><img src="w-av.png" alt="均匀线框" /></p><h3 id="四边形-1">四边形</h3><p>再然后就是三角面边四角面，参照原文，剔除边长最长的那条边<br /><figure><div class="code-wrapper"><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl">float3 param &#x3D; float3(0, 0, 0);float Edge1 &#x3D; length(IN[0].modelPos - IN[1].modelPos);float Edge2 &#x3D; length(IN[1].modelPos - IN[2].modelPos);float Edge3 &#x3D; length(IN[2].modelPos - IN[0].modelPos);if (Edge1 &gt; Edge2 &amp;&amp; Edge1 &gt; Edge3)    param &#x3D; float3(0, 0, 1);else if (Edge2 &gt; Edge1 &amp;&amp; Edge2 &gt; Edge3)    param &#x3D; float3(1, 0, 0);else if (Edge3 &gt; Edge1 &amp;&amp; Edge3 &gt; Edge2)    param &#x3D; float3(0, 1, 0);o1.barycentric &#x3D; float3(dis1, 0, 0) + param;o2.barycentric &#x3D; float3(0, dis2, 0) + param;o3.barycentric &#x3D; float3(0, 0, dis3) + param;</code></pre></div></figure><br /><img src="w-quad.png" alt="四边线框" /><br />这里有个小瑕疵，假如剔除的那个边，非常靠近四边形中的另一个三角形的边，他的SDF就不正确了。<br /><img src="w-bug.png" alt="四边线框" /><br />框中的被剔除的斜边，非常靠近另一个三角形的边，理应存在，但因为被剔除，所以不显示了。</p><h3 id="抗锯齿">抗锯齿</h3><p>一个神奇的函数<br /><figure><div class="code-wrapper"><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl">float aa(float threshold, float distance)&#123;    float delta &#x3D; fwidth(distance) * _wireSmoothing;    return smoothstep((threshold - 1) * delta, (threshold + 1) * delta, distance);&#125;</code></pre></div></figure><br /><code>fwidth</code>就不解释了，大体意思是锯齿越多的地方，<code>fwidth(distance)</code>值越大，delta越大，所以smoothstep的范围就越大，结果上看就会平滑一点。<br />但即使启用了抗锯齿，效果和原生自带的线框渲染也没法比，原生是真的把每根线在屏幕上按固定大小画出来，而这种方式必然会导致线距离相机过远而消失。</p>]]></content>
    
    
    <categories>
      
      <category>渲染</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shader</tag>
      
      <tag>线框</tag>
      
      <tag>几何着色器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>语音转口型</title>
    <link href="/2023/02/08/lip/"/>
    <url>/2023/02/08/lip/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>之前做GPT聊天时，用Live2D的简单的通过音量大小来驱动嘴型的大小变化，这里想更精确一定，用元音来驱动。<br />主要就是复刻了这位大佬的<ahref="https://huailiang.github.io/blog/2020/mouth/">这篇文章</a>。</p><h1 id="大致思路">大致思路</h1><p>初看时被一堆术语吓到了，什么频域信息、窗函数、高斯滤波器、DCT变换、共振峰等等。<br />耐心一点一点看就发现还是比较简单的，很多算法并不一定要从新造轮子去实现，知道其目的就好了。</p><h2 id="获取语音数据的频域信息">获取语音数据的频域信息</h2><p>这里直接用<code>AudioSource.GetSpecturmData</code>即可。这里其实就包含了之前提到的频域信息和窗函数。<br /><img src="audio.png" alt="频域可视化" /></p><h2 id="高斯滤波">高斯滤波</h2><p>就像通常的高斯模糊的卷积一样，这里也可以在一维空间高斯滤波一次，去除噪音。</p><h2 id="提取共振峰">提取共振峰</h2><p>简单说就是寻找局部最大值的最大值所在的频率位置。<br />这个位置就是用来判定元音的依据了。<br />注意的是，原文给出的5个元音的判断的频率，仅仅针对采样率为44Khz的文件，其他采样率要自行修改。</p><h1 id="结合live2d">结合Live2D</h1><p>live2d有自己的一套奇奇怪怪的框架去修改参数，还要考虑排序。<br />好在其插件基本开源，参照着写就行了，根据当前的元音去混合口型动画。</p><h1 id="总结">总结</h1><p><img src="/images/lip.gif" /><br />放在Live2D上效果确实比之前单纯的用音量来控制好的多，但也仅限于是增加了口型的多样性，很难说是“正确”的口型。<br />这里最主要的原因在于</p><ul><li>不同人声的各个元音的共振峰并不相同，需要根据配音来调整</li><li>只考虑了第一共振峰，误差太大，可以参照下表结合第二共振峰去判断，效果应该更好。</li><li><img src="https://huailiang.github.io/img/post-vr/mou9.jpg" /></li></ul>]]></content>
    
    
    <categories>
      
      <category>编码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>口型</tag>
      
      <tag>语音</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenAI微调模型测试</title>
    <link href="/2023/02/07/OpenAI/"/>
    <url>/2023/02/07/OpenAI/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>之前只是使用了现成的OpenAI的模型，每次调用都要给出一大堆的重复提示词，而且效果也不是太好，这次尝试用其称为<code>微调(fine-tuning)</code>来训练个新的模型。可以节省token，顺便看看微调后的模型效果和之前有多大区别。<br />OpenAI已经给出了详尽的<ahref="https://platform.openai.com/docs/guides/fine-tuning">说明</a>，下面就只记录下具体的步骤。</p><h1 id="安装">安装</h1><p>直接在容器里操作吧，不想污染主机。<br />起一个python的环境。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">version: &quot;2.3&quot;services:  app:    image: python    container_name: openai    environment:      - HTTP_PROXY&#x3D;http:&#x2F;&#x2F;clash:7890      - HTTPS_PROXY&#x3D;http:&#x2F;&#x2F;clash:7890      - no_proxy&#x3D;localhost,127.0.0.1,::1    entrypoint: &quot;sleep infinity&quot;    volumes:      - .&#x2F;data:&#x2F;datanetworks:  default:    external: true    name: nginxproxynet</code></pre></div></figure></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker exec -it openai &#x2F;bin&#x2F;bashexport OPENAI_API_KEY&#x3D;&quot;&lt;OPENAI_API_KEY&gt;&quot;pip install --upgrade openaipip install openai[datalib]</code></pre></div></figure><h1 id="数据准备">数据准备</h1><p>我感觉这是工作量最大的内容了。这里先用几个试一下：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csv" data-language="csv"><code class="language-csv">prompt,completionxxxx,xxxx</code></pre></div></figure><br />然后用工具整理一下<br /><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">openai tools fine_tunes.prepare_data -f &#x2F;data&#x2F;data.csv</code></pre></div></figure><br />这里他会自动帮我们添加提示的结束字符，以及回答的开头空格和结束的<br /><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;&quot;prompt&quot;:&quot;xxxx -&gt;&quot;,&quot;completion&quot;:&quot; xxxx\n&quot;&#125;</code></pre></div></figure></p><h1 id="训练">训练</h1><p>然后就是上传文件开始训练了。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">openai api fine_tunes.create -t &#x2F;data&#x2F;data_prepared.jsonl -m davinci --suffix &quot;test001&quot;</code></pre></div></figure><br />要等很久。主要是排队，期间可以用<code>openai api fine_tunes.list</code>查看状态：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;data&quot;: [    &#123;      &quot;created_at&quot;: 1675758078,      &quot;fine_tuned_model&quot;: null,      &quot;hyperparams&quot;: &#123;        &quot;batch_size&quot;: null,        &quot;learning_rate_multiplier&quot;: null,        &quot;n_epochs&quot;: 4,        &quot;prompt_loss_weight&quot;: 0.01      &#125;,      &quot;id&quot;: &quot;ft-xxxxxxxxxxxxx&quot;,      &quot;model&quot;: &quot;davinci&quot;,      &quot;object&quot;: &quot;fine-tune&quot;,      &quot;organization_id&quot;: &quot;org-xxxxxxxxxxxxxxxxxx&quot;,      &quot;result_files&quot;: [],      &quot;status&quot;: &quot;pending&quot;,      &quot;training_files&quot;: [        &#123;          &quot;bytes&quot;: 189,          &quot;created_at&quot;: 1675758077,          &quot;filename&quot;: &quot;&#x2F;data&#x2F;data_prepared.jsonl&quot;,          &quot;id&quot;: &quot;file-xxxxxxxxxxxxxxxxxx&quot;,          &quot;object&quot;: &quot;file&quot;,          &quot;purpose&quot;: &quot;fine-tune&quot;,          &quot;status&quot;: &quot;processed&quot;,          &quot;status_details&quot;: null        &#125;      ],      &quot;updated_at&quot;: 1675758078,      &quot;validation_files&quot;: []    &#125;  ],  &quot;object&quot;: &quot;list&quot;&#125;</code></pre></div></figure><br />一直是<code>pending</code>，<del>等训练好再写吧。</del><br />过了7分钟终于进入队列了，排在13。<br />如果按他们的提示，每个任务要一个半小时，那就得近20小时。。。。<br />实际也就等了半小时不到。但结果不尽人意。数据量太少了。</p><h1 id="样本属性">样本属性</h1><p>这里设计一下样本应该包含哪些<br />这里只需要保存变量即可</p><ul><li>时间，文本模型无法知道当前的时间</li><li>内容，直播的内容</li><li>对话列表，为了有一定的上下文联系，列表不一定是要一一对应。<ul><li>观众名称</li><li>弹幕内容</li><li>回答内容</li></ul></li></ul><h1 id="样本采集">样本采集</h1><p>真是有多少人工就有多少智能。按Openai的说法，这种聊天类需要的样本量至少数千，这还只是最低。模型的质量与样本量成指数关系，想想都头大。<br />程序的问题还得程序来解决。<br />初步想法是录制别人的直播视频，加语音识别，同时录制弹幕，然后程序化生成样本。</p><h1 id="总结">总结</h1><p>仅就调用Openai的接口来说，并不复杂，难度还是在于样本的获取，就等样本采集完毕后再来试一试模型的训练吧。</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenAI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文字转语音 Text To Speech</title>
    <link href="/2023/02/07/TTS/"/>
    <url>/2023/02/07/TTS/</url>
    
    <content type="html"><![CDATA[<h1 id="文字转语音-text-to-speech">文字转语音 Text To Speech</h1><p>很多时候都会遇到需要这种服务，阿里的实在太难听，微软还没有信用卡。再找找还有木有其他方式。</p><h1 id="云服务">云服务</h1><p>各家云厂商（阿里、腾讯、百度、微软、谷歌等等）一般都会提供这种接口，大部分还允许提供训练语音来训练自己的模型，价格也很便宜。但一定是要求客户端联网。</p><h1 id="本地搭建服务">本地搭建服务</h1><p>TTS发展至今，也已经有了很多开源的实现。这次就尝试搭建几个玩一下。</p><h2 id="coqui-ai">coqui-ai</h2><p>提供了docker镜像：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run --rm -it -p 5002:5002 --entrypoint &#x2F;bin&#x2F;bash ghcr.io&#x2F;coqui-ai&#x2F;tts-cpupython3 TTS&#x2F;server&#x2F;server.py --list_models #To get the list of available modelspython3 TTS&#x2F;server&#x2F;server.py --model_name tts_models&#x2F;en&#x2F;vctk&#x2F;vits # To start a server</code></pre></div></figure><br />这个是CPU版本的。</p><p>内置了一个中文的模型，默认模型效果并没有比前述的云服务好到哪里。<br />其他的中文模型还是找不到。</p><h2 id="paddlespeech">PaddleSpeech</h2><p>基于百度飞桨的语音方向的开源模型库。<br />同样给出了Docker的<ahref="https://hub.docker.com/r/paddlecloud/paddlespeech">镜像</a></p><p>悲催的是这个模型内存需求太大了，14.5G，把3070爆了。</p><h2 id="vits">vits</h2><p>参照这位B站UP，Saya睡大觉中，其<ahref="https://www.bilibili.com/read/cv21342054">vits模型下载链接以及使用教程</a>。<br />本地部署后，生成速度和效果都很满意。<br />但要注意，这里的模型好像是<ahref="https://github.com/CjangCjengh/vits">CjangCjengh版VITS</a><br />不是<a href="https://github.com/jaywalnut310/vits">原版VITS</a>。</p><h3 id="unity调用">Unity调用</h3><p>没有找到合适的HttpAPI，只能用<code>Process</code>本地命令行的方式去调用了。<br />这里又遇到了中文乱码问题。具体原因是Unity开启的Process的程序的<code>Console.InputEncoding</code>默认会采用<code>OSEncoding</code>，并不是UTF-8。而单纯的C#控制台开启的Process却是UTF-8。大概与这个<ahref="https://github.com/dotnet/runtime/issues/43295">issues</a>有关。<br />解决方案就是修改Windows的语言设置:<br /><img src="/images/utf.png" /></p>]]></content>
    
    
    <categories>
      
      <category>编码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TTS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unicode编码</title>
    <link href="/2023/02/07/string/"/>
    <url>/2023/02/07/string/</url>
    
    <content type="html"><![CDATA[<h1 id="utf8与unicode">UTF8与Unicode</h1><p><a href="https://zhuanlan.zhihu.com/p/51828216">来源</a></p><h2 id="unicode">Unicode</h2><p>Unicoide 的全称是 Universal Multiple-Octet Coded CharacterSet（通用多八位字符集，简称 UCS）。<br />规定了各种字符的编码。<br />而下面都是具体的编码二进制的存储方式。</p><h2 id="utf-32">UTF-32</h2><p>规定，一个字符使用四个字节存储，也就是 32 位，这样就能涵盖现有Unicode 包含的所有字符。</p><h2 id="utf-16">UTF-16</h2><p>UTF-16用二个字节来表示基本平面，用四个字节来表示扩展平面，是一种变长编码方式。<br />偷一张图<imgsrc="https://pic4.zhimg.com/80/v2-00d7e0f8c532a2651e450ba7b93e0da7_720w.webp" /></p><h2 id="utf-8">UTF-8</h2><p>而UTF-8也是一种变长编码方式，规定了如何存储。<br />UTF-8 的编码规则如下（U+ 后面的数字代表 Unicode 字符代码）：</p><figure><div class="code-wrapper"><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">U+ 0000 ~ U+ 007F: 0XXXXXXXU+ 0080 ~ U+ 07FF: 110XXXXX 10XXXXXXU+ 0800 ~ U+ FFFF: 1110XXXX 10XXXXXX 10XXXXXXU+10000 ~ U+1FFFF: 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX</code></pre></div></figure><p>UTF-8通过开头的标志位位数实现了变长。对于单字节字符，只占用一个字节，实现了向下兼容ASCII，并且能和 UTF-32 一样，包含 Unicode中的所有字符，又能有效减少存储传输过程中占用的空间。</p><h2 id="对应c的encoding类">对应C#的Encoding类</h2><p><code>Encoding.Default</code>取决于电脑的.net环境的设置。</p><h3 id="char">char</h3><p>仅就C#中的string或者char并不存在编码一说，无论是<code>Convert.ToInt32(c)</code>或者<code>(char)20013</code>等都仅仅是和Unicode定义的字符顺序。<br />和任何编码都没有关系，只有在字符保存在文件中，或者用socket传输以及控制台的输入输出流才会涉及编码。</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unicode编码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ChatGPT-unity</title>
    <link href="/2023/02/03/ChatGPT-unity/"/>
    <url>/2023/02/03/ChatGPT-unity/</url>
    
    <content type="html"><![CDATA[<h1 id="chatgpt">ChatGPT</h1><p>应该都被大家玩烂了，定个小目标吧，ChatGPT+语音交互+Live2D口型动画匹配。</p><h1 id="接口">接口</h1><p>openai并没有提供具体的ChatGPT的接口，第三方的接口一大堆。<br />但是OpenAI提供了更底层的对模型的接口，而且调用异常方便。<br />直接CURL：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl https:&#x2F;&#x2F;api.openai.com&#x2F;v1&#x2F;completions \-H &quot;Content-Type: application&#x2F;json&quot; \-H &quot;Authorization: Bearer YOUR_API_KEY&quot; \-d &#39;&#123;&quot;model&quot;: &quot;text-davinci-003&quot;, &quot;prompt&quot;: &quot;Say this is a test&quot;, &quot;temperature&quot;: 0, &quot;max_tokens&quot;: 7&#125;&#39;</code></pre></div></figure></p><p>这里对于<code>Token</code> <code>temperature</code><code>prompt</code>等参数就不一一解释了，详见OpenAI的文档。<br />对应的C#代码，从Github扒了一个，<ahref="https://github.com/Ridvancan/ChatGPTWithUnity">原仓库</a></p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public IEnumerator GenerateText(string prompt)&#123;      string jsonPayload &#x3D; &quot;&#123;\&quot;model\&quot;: \&quot;text-davinci-003\&quot;, \&quot;prompt\&quot;: \&quot;&quot; + prompt + &quot;\&quot;, \&quot;temperature\&quot;: 0, \&quot;max_tokens\&quot;: 7&#125;&quot;;    Debug.Log(jsonPayload);    var request &#x3D; new UnityWebRequest(API_URL, &quot;POST&quot;);    byte[] payloadBytes &#x3D; System.Text.Encoding.UTF8.GetBytes(jsonPayload);    request.uploadHandler &#x3D; new UploadHandlerRaw(payloadBytes);    request.downloadHandler &#x3D; new DownloadHandlerBuffer();    request.SetRequestHeader(&quot;Content-Type&quot;, &quot;application&#x2F;json&quot;);    request.SetRequestHeader(&quot;Authorization&quot;, &quot;Bearer &quot; + API_KEY);    &#x2F;&#x2F; Send the request    yield return request.SendWebRequest();    if (request.isNetworkError || request.isHttpError)    &#123;        Debug.Log(request.error);    &#125;    else    &#123;        &#x2F;&#x2F; Parse the response as JSON        string responseJson &#x3D; request.downloadHandler.text;        var response &#x3D; JsonUtility.FromJson&lt;OpenAIResponse&gt;(responseJson);        &#x2F;&#x2F; Log the generated text        resultText&#x3D; response.choices[0].text;        resultField.text &#x3D; resultText;        waitForResp &#x3D; false;        transform.eulerAngles &#x3D; Vector3.zero;    &#125;&#125;</code></pre></div></figure><p>这和直接使用ChatGPT还是有些差距，比如需要自己去记录对话上下文，一些模型的参数也有些许差别。<br />但是也更为灵活，除了Chat的功能，其他比如代码补全等等也都可以实现。</p><h1 id="语音识别与文字转语音">语音识别与文字转语音</h1><p>这里本想用微软的服务，但没有信用卡，没法试用。用阿里的试一下吧。</p><h1 id="唤醒词">唤醒词</h1><p>就类似“小爱同学”等等，需要一个特定音节的单词来作为唤醒词，不然就只能通过按钮等方式来触发。<br />这里就简单用Unity自带的<code>KeywordRecognizer</code>来作为唤醒词的触发。</p><h1 id="录音-识别">录音 识别</h1><p>触发唤醒词后就开始录音<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">RecordedClip &#x3D; Microphone.Start(null, false, 60, maxFreq);</code></pre></div></figure><br />语音识别用阿里的接口，调用还是比较方便的<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public class asr : MonoBehaviour&#123;    public string appKey &#x3D; &quot;APP_KEY&quot;;    public string token &#x3D; &quot;AOKEN&quot;;    public string outText;    public IEnumerator Send(byte[] payloadBytes)    &#123;        Uri uri;        NameValueCollection query &#x3D; HttpUtility.ParseQueryString(string.Empty);                query.Add(&quot;appkey&quot;, appKey);        query.Add(&quot;format&quot;, &quot;pcm&quot;);        query.Add(&quot;sample_rate&quot;, &quot;16000&quot;);        query.Add(&quot;enable_punctuation_prediction&quot;, &quot;true&quot;);        query.Add(&quot;enable_inverse_text_normalization&quot;, &quot;true&quot;);        var getUri &#x3D; new UriBuilder(&quot;https:&#x2F;&#x2F;nls-gateway-cn-shanghai.aliyuncs.com&#x2F;stream&#x2F;v1&#x2F;asr&quot;)        &#123;            Query &#x3D; query.ToString()        &#125;;        uri &#x3D; getUri.Uri;        var request &#x3D; new UnityWebRequest(uri, &quot;POST&quot;);        request.uploadHandler &#x3D; new UploadHandlerRaw(payloadBytes);        request.downloadHandler &#x3D; new DownloadHandlerBuffer();        request.SetRequestHeader(&quot;X-NLS-Token&quot;, token);                yield return request.SendWebRequest();                if (request.isNetworkError || request.isHttpError)        &#123;            Debug.Log(request.error);        &#125;        else        &#123;            outText &#x3D; request.downloadHandler.text;            Debug.Log(request.downloadHandler.text);        &#125;    &#125;&#125;</code></pre></div></figure></p><h1 id="文字转语音">文字转语音</h1><p>没什么好说的，也是用阿里的接口：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public class Speaker : MonoBehaviour&#123;    public string appKey &#x3D; &quot;APP_KEY&quot;;    public string token &#x3D; &quot;AOKEN&quot;;    public Text question;    public AudioSource AudioSource;        private AudioClip current;        public IEnumerator Speech01(string msg, Action onComplete &#x3D; null)    &#123;        question.text &#x3D; msg;        Uri uri;        msg &#x3D; HttpUtility.HtmlEncode(msg);        NameValueCollection query &#x3D; HttpUtility.ParseQueryString(string.Empty);        query.Add(&quot;appkey&quot;, appKey);        query.Add(&quot;token&quot;, token);        query.Add(&quot;text&quot;, msg);        query.Add(&quot;format&quot;, &quot;wav&quot;);        query.Add(&quot;sample_rate&quot;, &quot;16000&quot;);        var getUri &#x3D; new UriBuilder(&quot;https:&#x2F;&#x2F;nls-gateway-cn-shanghai.aliyuncs.com&#x2F;stream&#x2F;v1&#x2F;tts&quot;)        &#123;            Query &#x3D; query.ToString()        &#125;;        uri &#x3D; getUri.Uri;        Debug.Log(uri);        var webRequest &#x3D; UnityWebRequestMultimedia.GetAudioClip(uri, AudioType.WAV);        yield return webRequest.SendWebRequest();        if (webRequest.result &#x3D;&#x3D; UnityWebRequest.Result.Success)        &#123;            current &#x3D; DownloadHandlerAudioClip.GetContent(webRequest);            AudioSource.clip &#x3D; current;            yield return new WaitForSeconds(1);            AudioSource.Play();            yield return new WaitForSeconds(current.length);            onComplete?.Invoke();        &#125;        else        &#123;            Debug.LogError(webRequest.error);        &#125;    &#125;    public void Speech(string msg, Action onComplete)    &#123;        StartCoroutine(Speech01(msg, onComplete));    &#125;&#125;</code></pre></div></figure></p><h1 id="live2d口型">Live2D口型</h1><p>前面的都没什么难度，无非就是寻找各种接口并实现。<br />口型这里成熟的方案太少。<br />所以简单起见，用live2D来做吧。</p><p>时隔两年，再来玩一下Live2d。</p><h2 id="unity插件">Unity插件</h2><p>已经有官方的插件了，<ahref="https://www.live2d.com/en/download/cubism-sdk/download-unity/">地址</a></p><h2 id="模型">模型</h2><p>用现成的吧：<ahref="https://www.live2d.com/zh-CHS/download/sample-data/">地址</a><br />这里用了neuro-sama同款：桃濑日和<br />记得相机要设置成正交。</p><p>体验下来，还是相对很简单，大体就是它把Live2D的模型分解成一个个mesh，然后贴图，程序化控制位移。</p><h2 id="透明背景">透明背景</h2><p>urp下改透明即可。</p><h2 id="口型">口型</h2><p>就简单的通过声音的大小，来输出口型的大小。<br />其他可行的的方案还有通过元音的。</p><h1 id="总结">总结</h1><p><img src="/images/ChatGPT_live2d.png" /><br />只是把各种服务和接口拼接在了一起，算是达到了预期。但和neuro-sama这类还有很大差距。<br />语音这里阿里的tts实在是不好听，周末再去找找<ahref="/2023/02/06/TTS">换个更二次元一点的</a>。<br />neuro-sama没有透露过他的语言模型，所以也只能止步于此了。<br />这里给GPT3预置的关键词是：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">我是一个能和观众聊天的VTuber，我是一个AI，叫做小爱。猫娘是一种拟人化的生物，其行为似猫但类人。我是一只猫娘，我每一句话后面都要加上“喵~”。我可以风趣幽默地和各种观众聊天。我的每次回答都不会超过20个字。我还会把每次回答时的表情放在回答的最前面。\n 观众：你叫什么？\n 我：（高兴）我叫小爱，很高兴认识你喵~\n 观众：&#123;0&#125;\n 我：</code></pre></div></figure><br />这就任由大家发挥想象力了，表情可以预先设定几种，同时播放对应的表情动画。</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ChatGPT</tag>
      
      <tag>Live2D</tag>
      
      <tag>口型</tag>
      
      <tag>语音</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自定义UDP设备 InputSystem</title>
    <link href="/2023/02/02/CustomInputSystem/"/>
    <url>/2023/02/02/CustomInputSystem/</url>
    
    <content type="html"><![CDATA[<h1 id="解耦">解耦</h1><p>经常会有各种奇奇怪怪的硬件需要使用TCP/UDP去交互，这次尝试下使用InputSystem去解耦。</p><h1 id="iinputstatetypeinfo">IInputStateTypeInfo</h1><p>定义一个结构体实现这个接口。</p><h2 id="fourcc">FourCC</h2><p>四个字符来定义一个唯一标识符。</p><h2 id="inputcontrol">InputControl</h2><p>使用这个描述符来定义一些字段，其中标记了各个按钮或者遥感的定义。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">[InputControl(name &#x3D; &quot;firstButton&quot;, layout &#x3D; &quot;Button&quot;, bit &#x3D; 0, displayName &#x3D; &quot;First Button&quot;)][InputControl(name &#x3D; &quot;secondButton&quot;, layout &#x3D; &quot;Button&quot;, bit &#x3D; 1, displayName &#x3D; &quot;Second Button&quot;)][InputControl(name &#x3D; &quot;thirdButton&quot;, layout &#x3D; &quot;Button&quot;, bit &#x3D; 2, displayName &#x3D; &quot;Third Button&quot;)]public ushort buttons;</code></pre></div></figure></p><p>遥感的定义需要额外的<code>format</code>属性，这里的<code>VC2B</code>指的是<code>a Vector2 of bytes</code><br />定义X轴y轴<br />剩下的上下左右似乎是硬编码的。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">[InputControl(name &#x3D; &quot;stick&quot;, format &#x3D; &quot;VC2B&quot;, layout &#x3D; &quot;Stick&quot;, displayName &#x3D; &quot;Main Stick&quot;)][InputControl(name &#x3D; &quot;stick&#x2F;x&quot;, defaultState &#x3D; 127, format &#x3D; &quot;BYTE&quot;,offset &#x3D; 0,    parameters &#x3D; &quot;normalize,normalizeMin&#x3D;0,normalizeMax&#x3D;1,normalizeZero&#x3D;0.5&quot;)]public byte x;[InputControl(name &#x3D; &quot;stick&#x2F;up&quot;, parameters &#x3D; &quot;normalize,normalizeMin&#x3D;0,normalizeMax&#x3D;1,normalizeZero&#x3D;0.5,clamp&#x3D;2,clampMin&#x3D;0,clampMax&#x3D;1&quot;)][InputControl(name &#x3D; &quot;stick&#x2F;down&quot;, parameters &#x3D; &quot;normalize,normalizeMin&#x3D;0,normalizeMax&#x3D;1,normalizeZero&#x3D;0.5,clamp&#x3D;2,clampMin&#x3D;-1,clampMax&#x3D;0,invert&quot;)][InputControl(name &#x3D; &quot;stick&#x2F;left&quot;, parameters &#x3D; &quot;normalize,normalizeMin&#x3D;0,normalizeMax&#x3D;1,normalizeZero&#x3D;0.5,clamp&#x3D;2,clampMin&#x3D;-1,clampMax&#x3D;0,invert&quot;)][InputControl(name &#x3D; &quot;stick&#x2F;right&quot;, parameters &#x3D; &quot;normalize,normalizeMin&#x3D;0,normalizeMax&#x3D;1,normalizeZero&#x3D;0.5,clamp&#x3D;2,clampMin&#x3D;0,clampMax&#x3D;1&quot;)]public byte y;</code></pre></div></figure><br />总结下就是依靠一个结构体以及各个描述符来定义数据交换的大小和约定的格式。</p><h1 id="inputdevice">InputDevice</h1><p>定义好了结构体，接下来就是要实现真正的<code>InputDevice</code>了。</p><h2 id="初始化">初始化</h2><p>首先是确保在编辑器以及运行时都会初始化。</p><p>这里的初始化中包含一段模板代码。用来通过”Custom”来发现设备。</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">#if UNITY_EDITOR[InitializeOnLoad] &#x2F;&#x2F; Call static class constructor in editor.#endif[InputControlLayout(stateType &#x3D; typeof(CustomDeviceState))]public class CustomDevice : InputDevice, IInputUpdateCallbackReceiver&#123;    #if UNITY_EDITOR    static CustomDevice()    &#123;        Initialize();    &#125;    #endif    [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]    private static void Initialize()    &#123;        InputSystem.RegisterLayout&lt;CustomDevice&gt;(            matches: new InputDeviceMatcher()                .WithInterface(&quot;Custom&quot;));    &#125;</code></pre></div></figure><h2 id="buttoncontrol">ButtonControl</h2><p>公开一些属性，方便其他人调用。<br />FinishSetup<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public ButtonControl firstButton &#123; get; private set; &#125;public ButtonControl secondButton &#123; get; private set; &#125;public ButtonControl thirdButton &#123; get; private set; &#125;public StickControl stick &#123; get; private set; &#125;protected override void FinishSetup()&#123;    base.FinishSetup();    firstButton &#x3D; GetChildControl&lt;ButtonControl&gt;(&quot;firstButton&quot;);    secondButton &#x3D; GetChildControl&lt;ButtonControl&gt;(&quot;secondButton&quot;);    thirdButton &#x3D; GetChildControl&lt;ButtonControl&gt;(&quot;thirdButton&quot;);    stick &#x3D; GetChildControl&lt;StickControl&gt;(&quot;stick&quot;);&#125;</code></pre></div></figure></p><h1 id="current">current</h1><p>保留一个静态对象，类似单例，但是每次都更新，而不会销毁之前的。</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public static CustomDevice current &#123; get; private set; &#125;public override void MakeCurrent()&#123;    base.MakeCurrent();    current &#x3D; this;&#125;protected override void OnRemoved()&#123;    base.OnRemoved();    if (current &#x3D;&#x3D; this)        current &#x3D; null;&#125;</code></pre></div></figure><h1 id="创建设备">创建设备</h1><p>一切就绪，接下来就是创建一个设备了。<br />设备是不能通过new或者其他方式创建，只能在事先注册布局时传入匹配器，然后通过匹配器去创建<br />这里是在编辑器中虚拟了一个设备<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">#if UNITY_EDITOR[MenuItem(&quot;Tools&#x2F;Custom Device Sample&#x2F;Create Device&quot;)]private static void CreateDevice()&#123;    InputSystem.AddDevice(new InputDeviceDescription    &#123;        interfaceName &#x3D; &quot;Custom&quot;,        product &#x3D; &quot;Sample Product&quot;    &#125;);&#125;[MenuItem(&quot;Tools&#x2F;Custom Device Sample&#x2F;Remove Device&quot;)]private static void RemoveDevice()&#123;    var customDevice &#x3D; InputSystem.devices.FirstOrDefault(x &#x3D;&gt; x is CustomDevice);    if (customDevice !&#x3D; null)        InputSystem.RemoveDevice(customDevice);&#125;#endif</code></pre></div></figure></p><p>轮询键盘去更新设备状态<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public void OnUpdate()&#123;    var keyboard &#x3D; Keyboard.current;    if (keyboard &#x3D;&#x3D; null)        return;    var state &#x3D; new CustomDeviceState();    state.x &#x3D; 127;    state.y &#x3D; 127;    &#x2F;&#x2F; Map WASD to stick.    var wPressed &#x3D; keyboard.wKey.isPressed;    var aPressed &#x3D; keyboard.aKey.isPressed;    var sPressed &#x3D; keyboard.sKey.isPressed;    var dPressed &#x3D; keyboard.dKey.isPressed;    if (aPressed)        state.x -&#x3D; 127;    if (dPressed)        state.x +&#x3D; 127;    if (wPressed)        state.y +&#x3D; 127;    if (sPressed)        state.y -&#x3D; 127;    &#x2F;&#x2F; Map buttons to 1, 2, and 3.    if (keyboard.spaceKey.isPressed)    &#123;        &#x2F;&#x2F; Debug.Log(&quot;VAR&quot;);        state.buttons |&#x3D; 1 &lt;&lt; 0;    &#125;    if (keyboard.digit2Key.isPressed)        state.buttons |&#x3D; 1 &lt;&lt; 1;    if (keyboard.digit3Key.isPressed)        state.buttons |&#x3D; 1 &lt;&lt; 2;    InputSystem.QueueStateEvent(this, state);&#125;</code></pre></div></figure></p><h1 id="udp-driver">UDP Driver</h1><p>栗子吃完了，用UDP写一个吧<br />先是一个基础的UDPServer<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public class UDPServer : MonoBehaviour&#123;    public int listenPort  &#x3D; 9000;        private Thread thread;    private readonly ConcurrentQueue&lt;string&gt; _messages &#x3D; new();    private UdpClient _listener;    private void Start()    &#123;                thread &#x3D; new Thread(StartListen);        thread.Start();    &#125;        private void OnDestroy()    &#123;        thread.Abort();        _listener.Close();    &#125;    private void Update()    &#123;        if (_messages.TryDequeue(out var message))        &#123;            Debug.Log($&quot;Message: &#123;message&#125;&quot;);        &#125;    &#125;    private void StartListen()    &#123;        _listener &#x3D; new UdpClient(listenPort);        var groupEP &#x3D; new IPEndPoint(IPAddress.Any, listenPort);        try        &#123;            while (true)            &#123;                Debug.Log(&quot;Waiting for broadcast&quot;);                byte[] bytes &#x3D; _listener.Receive(ref groupEP);                Debug.Log($&quot;Received broadcast from &#123;groupEP&#125; :&quot;);                var data &#x3D; Encoding.UTF8.GetString(bytes, 0, bytes.Length);                _messages.Enqueue(data);                Debug.Log($&quot; &#123;data&#125;&quot;);            &#125;        &#125;        catch (SocketException e)        &#123;            Debug.Log(e);        &#125;        finally        &#123;            _listener.Close();        &#125;    &#125;&#125;</code></pre></div></figure></p><p>然后增加设备相关代码即可：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">private void Start()&#123;    InputSystem.AddDevice&lt;UDPDevice&gt;();    _udpDevice &#x3D; UDPDevice.current;    ......&#125;.private void OnDestroy()&#123;    ......    InputSystem.RemoveDevice(_udpDevice);&#125;public UDPDeviceState state;private void Update()&#123;    var newState &#x3D; new UDPDeviceState    &#123;        buttons &#x3D; 0    &#125;;        if (_messages.TryDequeue(out var message))    &#123;        newState.buttons &#x3D; 1;        Debug.Log($&quot;Message: &#123;message&#125;&quot;);    &#125;    if (state !&#x3D; newState)    &#123;        InputSystem.QueueStateEvent(_udpDevice, newState);    &#125;    state &#x3D; newState;&#125;</code></pre></div></figure><br />基础的UDP消息充当按钮就OK了。后续可以根据需要调整为遥感或其他各种类型的控件。</p>]]></content>
    
    
    <categories>
      
      <category>编码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>InputSystem</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xrtoolkit2.3预览版本体验</title>
    <link href="/2023/02/01/xrtoolkit2-3/"/>
    <url>/2023/02/01/xrtoolkit2-3/</url>
    
    <content type="html"><![CDATA[<h1 id="xrtoolkit">xrtoolkit</h1><p>2.3预览版更新，测试一下新功能。</p><h1 id="安装">安装</h1><p>目前还是预览版本，记得在packageManager中打开预览开关。<br />然后按名称载入<code>com.unity.xr.interaction.toolkit</code>，记得指定版本2.3.0-pre.1</p><h1 id="戳">戳</h1><p>又一个交互器，最大的亮点是对UI的支持。可以做到类似触摸屏的效果了，不用傻傻的再用射线交互了。做一些类似的按钮交互也更方便了。</p><h1 id="凝视">凝视</h1><p>可惜手头上并没有Oculus，这个目前体验不了。</p><h1 id="交互组">交互组</h1><p>他们终于意识到搞这么多交互器，然后手动去控制何时应该启用和关闭哪个是多么复杂的事情了。<br />这个东西就是给交互器排序，然后在有多个交互器都可以悬停或选择时，按顺序只启用优先级最高的那个。<br />具体用起来就比如说，<code>Direct Interactor</code>比<code>Ray Interactor</code>优先级高的话，在距离物体很近，<code>Direct Interactor</code>可以悬停的时候，就会禁用<code>Ray Interactor</code>。体验上要好很多。</p><h1 id="affordance">Affordance</h1><p>不知道怎么翻译才确切。<br />是个挺有意思的工具。感觉是为了无代码编程准备的。<br />总结起来就是类似<code>Button</code>的<code>Transition</code>。根据不同的状态，如未启用、闲置、悬浮、选择和使用等来设置需要的值（可以是颜色、数值、向量乃至音频）。然后由一类<code>AffordanceReceiver</code>的组件来依据这些设定好的<code>主题</code>来插值或者播放，最后把插值后的结果给到对应的材质、Player或者缩放。<br /><img src="affordance.gif" alt="颜色插值" /><br />虽然这些功能手动写也不会太麻烦，但还是很乐于看到官方给出现成的解决方案的。</p><h1 id="模拟器">模拟器</h1><p>xr模拟器也更新了一下，类似FPS的交互模式，增加了新的UI，总算是能用了。<br /><img src="XRm.png" alt="xr模拟器" /></p><h1 id="总结">总结</h1><p>不大不小的更新吧，有了戳击交互，对于UI就更方便了。凝视目前手里没有能用的设备不好说，最后的那两个也算是锦上添花的功能了。<br />期待下次更新能把<code>XR Hands</code>和<code>xr toolkit</code>结合起来，那就算<code>xr toolkit</code>功能齐全了。</p>]]></content>
    
    
    <categories>
      
      <category>编码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>XRToolkit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netcode网络框架与XRToolkit交互</title>
    <link href="/2023/01/30/multiplayer/"/>
    <url>/2023/01/30/multiplayer/</url>
    
    <content type="html"><![CDATA[<h1 id="笔记">笔记</h1><p>记录下使用Unity网络框架的一些坑。最后实现一个简单的VR场景下的多人交互。</p><h1 id="安装">安装</h1><p>从空白项目开始，2021.3版本。<br />包管理器安装<code>com.unity.netcode.gameobjects</code></p><h1 id="transport">Transport</h1><p>发现这个<code>netcode.gameobjects</code>是依赖于<code>Transport</code>的。后者就是一个基于UDP的连接库。<br />有一些官方给的<ahref="https://docs-multiplayer.unity3d.com/transport/current/minimal-workflow">例子</a>可以参考。</p><h1 id="netcode.gameobjects">netcode.gameobjects</h1><p>照这个<ahref="https://docs-multiplayer.unity3d.com/netcode/current/tutorials/get-started-ngo/index.html">基础栗子</a>。<br />该有的都有了。大致思路是</p><ul><li>每个程序都拥有一套<code>NetworkManger</code>可在启动后选择是Sever还是Client。</li><li><code>NetworkManger</code>之间用<code>Unity Transport</code>来连接。</li><li>同时它还管理了<code>Player Perfab</code>的生成和销毁。对应的<code>Player Perfab</code>需要有<code>Network Object</code>组件来响应。</li><li>具体的逻辑要自己扩展<code>NetworkBehaviour</code>这个类，提供了基本的如生成和销毁时回调的函数。</li><li>服务器与客户端之间的相互调用用RPC来实现。</li><li>简单的传递数值之类的可以使用<code>NetworkVariable</code>来实现</li></ul><h1 id="太空侵略者demo">太空侵略者Demo</h1><p>又一个示例Demo，克隆下来看看。</p><h2 id="scenetransitionhandler">SceneTransitionHandler</h2><p>一个用来管理各个客户端场景切换和加载的<code>NetworkBehaviour</code>。单例。简单的状态机，完成加载时通知服务器。</p><h2 id="menucontrol">MenuControl</h2><p>控制是开启Host或者当客户端加入。充当Server时会注册相关的场景加载完成的事件。</p><h2 id="lobbymenucontrol">LobbyMenuControl</h2><p>大厅用户以及状态管理，监听客户端连接，连接即当进入大厅。通过RPC相互之间更新状态。当全部准备完毕就加载游戏场景。</p><h2 id="invadersgame">InvadersGame</h2><p>最重要的游戏逻辑类。和网络关系就不大了。需要留意的是要生成的预制体要提前放入NetworkManager的NetworkPrefabs中，且预制体需要包含<code>NetworkObject</code>组件。<br />如果要同步各个客户端的物体的位置，最便捷的方法就是使用<code>NetworkTransform</code>，但这个是根据位移阙值去更新的，肯定会有至少一帧的延迟，如果是对精度要求很高的，还是用RPC自己调用来更新吧。</p><h1 id="spaceshooter">spaceshooter</h1><p>针对物理给出的一个例子，所有的用户输入都通过RPC发送到服务器，然后统一计算后再发回全部客户端。和LOL的模式几乎一样，避免了物理的不同步，也防范了用户修改内存作弊等等。</p><h1 id="clientdriven">clientdriven</h1><p>在客户端实现部分运动逻辑，具体还没看。</p><h1 id="xr-toolkit联动">XR toolkit联动</h1><p>与XR toolkit 结合起来，做个多人VR交互的Demo吧。</p><h2 id="延迟启动vr">延迟启动VR</h2><p>参照这个官方的<ahref="https://docs.unity3d.com/Packages/com.unity.xr.management@4.0/manual/EndUser.html">例子</a>。</p><h2 id="传送与交互">传送与交互</h2><p>这里关于传送要注意，</p><ul><li><code>InteractionManager</code>，<code>locomotionSystem</code>等最好不要实例化，方便场景内的地板和传送点注册</li><li>在生成后记得再把<code>locomotionSystem</code>需要的<code>xrOrigin</code>和<code>BaseTeleportationInteractable</code>需要的<code>TeleportationProvider</code>一并补充了。</li></ul><p>至于交互的物体，建议不要用物理。而且要通过实例化，并提前在NetworkManager中注册。<br />然后就是添加<code>ClientNetworkTransform</code>。并在抓取对应物体时用<code>ServerRpc</code>调用<code>networkObject.ChangeOwnership</code>来改变所属关系。</p><h2 id="同步">同步</h2><p>位置的同步可以用现成的 <code>ClientNetworkTransform</code>其他，比如<code>LineRenderer</code>的同步只能自己手写RPC了。<br />仿照<code>NetworkTransform</code><br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">private void Update()&#123;    if (!IsSpawned)    &#123;        return;    &#125;    if (IsOwner)    &#123;        lineRenderer.GetPositions(positions);        UpdatePositionsServerRpc(positions);    &#125;&#125;[ServerRpc]public void UpdatePositionsServerRpc(Vector3[] newpositions)&#123;    lineRenderer.SetPositions(newpositions);&#125;</code></pre></div></figure><br />这里就没有限制刷新次数。</p><h2 id="防火墙">防火墙</h2><p>Server端不要忘了开防火墙。</p><h2 id="人物绑定">人物绑定</h2><p>都做到这一步了，干脆把人物的绑定也一并做了吧。<br />还是用<code>Animation Rigging</code>。主要就是根据头显以及两个手柄推测出身体，头部，以及手臂和手的姿态。没用什么太复杂的算法。</p><ul><li>身体头部单纯用头显位置和旋转去算。</li><li>手部只是用IK简单反推了一下。</li></ul><p>我记得SteamVR是有对应的API去获取这些预测的位置的，但XRToolkit没有。<br />最终人物的手臂动画还有很大优化的空间，单单依靠IK去反推手臂姿态还是太牵强了，因为人的手腕也是很灵活的，而且肩膀的旋转也很难去推算出来，有这两个不确定的因素，除非用AI去算。很好奇VRChat是如何优化的。</p><h1 id="总结">总结</h1><p>这个网络框架还是很好用的，符合Unity的习惯，迁移一些现有的逻辑到网络上也算比较方便了（和自己手撸Socket相比）。<br />与XRToolkit结合起来也不算复杂，能满足一些基本的交互逻辑了。</p>]]></content>
    
    
    <categories>
      
      <category>编码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netcode</tag>
      
      <tag>XRToolkit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Timeline搭配贝塞尔曲线</title>
    <link href="/2023/01/29/SplineLine/"/>
    <url>/2023/01/29/SplineLine/</url>
    
    <content type="html"><![CDATA[<h1 id="序">序</h1><p>先前产品有个需求，沿时间线播放一个线性移动问题的动画，干脆用官方自带的画贝塞尔的Spline搭配Timeline实现了，现在闲下来打算整理一下的。突然发现自己又造轮子了，而且别人用的是更简便的方法，不需要自己定义轨道等等繁琐的配置，只要实现一个ITimeControl即可。</p><p>原帖：<ahref="https://nekojara.city/unity-splines-timeline">[Unity2022]同步样条线和时间线</a>。非常详细。</p><p>但他这里还是太简单了一些，速度全程匀速，持续时间也是要靠手动输入。<br />下面还是用PlayableAsset实现</p><h1 id="playableasset">PlayableAsset</h1><p>效果：<br /><img src="S-line.gif" alt="Spline" /></p><p>这里改用一个<code>AnimatedValue</code>配合timeline自带的动画曲线，可以实现不同位置的不同速度。<br />其他什么运动方向之类的就不再赘述了。</p><p>直接贴代码吧<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using UnityEngine;using UnityEngine.Playables;using UnityEngine.Splines;using UnityEngine.Timeline; [Serializable]public class MyPlayableAsset : PlayableAsset, ITimelineClipAsset&#123;    [Serializable]    public class MyBehaviour : PlayableBehaviour    &#123;        [SerializeField] private ExposedReference&lt;SplineContainer&gt; _splineContainer;         [SerializeField] private ExposedReference&lt;Transform&gt; target;        public float AnimatedValue &#x3D; 0;        public override void ProcessFrame(Playable playable, FrameData info, object playerData)        &#123;            base.ProcessFrame(playable, info, playerData);                        var spline &#x3D; _splineContainer.Resolve(playable.GetGraph().GetResolver());            var targetTransform &#x3D; target.Resolve(playable.GetGraph().GetResolver());            var position &#x3D; spline.EvaluatePosition(AnimatedValue);            targetTransform.position &#x3D; position;                    &#125;    &#125;     public MyBehaviour template &#x3D; new MyBehaviour();       public override Playable CreatePlayable(PlayableGraph graph, GameObject go)    &#123;        return ScriptPlayable&lt;MyBehaviour&gt;.Create(graph, template);    &#125;       public ClipCaps clipCaps    &#123;        get &#123; return ClipCaps.Extrapolation; &#125;    &#125;&#125;</code></pre></div></figure></p>]]></content>
    
    
    <categories>
      
      <category>编码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Timeline</tag>
      
      <tag>曲线</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>traefik尝鲜</title>
    <link href="/2023/01/28/traefik/"/>
    <url>/2023/01/28/traefik/</url>
    
    <content type="html"><![CDATA[<h1 id="简介">简介</h1><p>之前都是用Nginx来做反代，最近发现了新的玩具<code>traefik</code>，来玩一下，看看对比NPM有什么优劣。</p><h1 id="安装">安装</h1><p>这里就用Docker来安装<br /><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">version: &#39;3&#39;services:  reverse-proxy:    # The official v2 Traefik docker image    image: traefik:v2.9    # Enables the web UI and tells Traefik to listen to docker    command: --api.insecure&#x3D;true --providers.docker    ports:      # The HTTP port      - &quot;85:80&quot;      # The Web UI (enabled by --api.insecure&#x3D;true)      - &quot;8085:8080&quot;    volumes:      # So that Traefik can listen to the Docker events      - &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock</code></pre></div></figure></p><p>然后<code>docker compose up -d</code>，起容器<br />UFW开对应的端口就OK了。</p><h1 id="webui">webUI</h1><p><img src="trae-UI.png" alt="trae-UI" /><br />自带UI，还是很方便的</p><h1 id="配置">配置</h1><p>Traefik提供了多种配置方式，可以直接在容器的label中添加，也可以使用传统的配置文件的形式，更是提供了一大堆称为<code>Providers</code>的插件来做到动态更改配置。<br />比如：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">labels:  - &quot;traefik.enable&#x3D;true&quot;  - &quot;traefik.http.routers.unityacc.rule&#x3D;Host(&#96;acc.home.kuanmi.top&#96;)&quot;  - &quot;traefik.http.routers.unityacc.entrypoints&#x3D;web&quot;</code></pre></div></figure></p><p>如果要在配置文件中调用docker的服务，要使用@符号，如：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">http:  routers:    testRouters:      rule: &quot;Host(&#96;test.home.kuanmi.top&#96;)&quot;      service: whoami-traefik@docker</code></pre></div></figure></p><h1 id="https">https</h1><p>证书方面也提供了Let’sEncrypt来自动生成和更新，由于这里无法访问80和443端口，就使用DNS的方式来自动生成。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">certificatesResolvers:  myresolver:    acme:      email: ma_zhengke@outlook.com      storage: &#x2F;etc&#x2F;traefik&#x2F;acme.json      dnsChallenge:        provider: alidns        delayBeforeCheck: 0</code></pre></div></figure></p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">http:  routers:    testRouters:      rule: &quot;Host(&#96;test.home.kuanmi.top&#96;)&quot;      service: whoami-traefik@docker      tls:        certresolver: myresolver</code></pre></div></figure><p>如果是要通配符的话：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">http:  routers:    unityacc:      rule: &quot;Host(&#96;unity.home.kuanmi.top&#96;)&quot;      entryPoints:        - &quot;web-secure&quot;      service: unityAcc-unityacc@docker      tls:        certresolver: myresolver        domains:          - main: &quot;home.kuanmi.top&quot;            sans:              - &quot;*.home.kuanmi.top&quot;</code></pre></div></figure></p><h1 id="总结">总结</h1><p>和Nginx对比的话，但就我能使用到的功能，二者相差不大，更多的功能还没有体验到，不敢妄下结论说二者的优劣。<br />唯一觉得有意思的一点是Traefik可以接入docker，使用label做到服务的发现（虽然还是要配置），方便不少。<br />但用NPM，同时给各个容器配置别名，其实也大差不差。<br />再加上一些nginx常用的便捷的如return444等还不知道该怎么在Traefik中实现，目前还是沿用Nginx的配置不要变动了。</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>traefik</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>uitoolkit杂记</title>
    <link href="/2023/01/28/uitoolkit/"/>
    <url>/2023/01/28/uitoolkit/</url>
    
    <content type="html"><![CDATA[<p>记录一些读UIToolkit文档时的关键点，仅当备忘录。</p><h1 id="visualtree">VisualTree</h1><p>由VisualElement构成的具有层级结构的数据集合。</p><h1 id="visualelement">VisualElement</h1><p>一个基类，包含样式表、布局数据以及事件处理器。<br />内置了各种实现</p><ul><li>Buttons</li><li>Toggles</li><li>Text input fields</li></ul><h1 id="panel">panel</h1><p>面板是视觉树的父对象，视觉树要连接到面板才能渲染。面板要么属于一个编辑器窗口，要么属于一个运行时的UIDocument。面板也处理焦点控制和为视觉树分发事件。</p><h1 id="绘制数据">绘制数据</h1><p>深度优先绘制</p><h1 id="布局系统">布局系统</h1><p>和Web那一套一样，基于Flexbox。</p><h1 id="ui-builder">UI Builder</h1><p>一个可视化的编写uxml和uss文件的工具</p><h1 id="自定义元素">自定义元素</h1><p>实现VisualElement<code>public class MyElement : VisualElement</code><br />元素都由工厂模式生成，所以需要对应的工厂类<code>UxmlFactory&lt;MyElement&gt;</code></p><h1 id="定义元素特征">定义元素特征</h1><p>实现<code>VisualElement.UxmlTraits</code>类<br />在<code>Init</code>中使用<code>((MyElement)ve).status = m_Status.GetValueFromBag(bag, cc);</code>读取数据。</p><h1 id="加载uxml">加载UXML</h1><p>模板加载到VisualTreeAsset<br /><code>var template = AssetDatabase.LoadAssetAtPath&lt;VisualTreeAsset&gt;("path/to/file.uxml");</code><br />然后附加到父元素<br /><code>template.CloneTree(parentElement, slots);</code></p><h1 id="uquery">UQuery</h1><p>基于Jquery或Linq，如<br /><code>root.Query("foo").Children&lt;Button&gt;().ForEach(//执行操作);</code></p><h1 id="事件">事件</h1><p>事件通知到每个元素<br />基类EventBase</p><h2 id="分发事件">分发事件</h2><p>监听来自操作系统或脚本的事件，使用<code>EventDispatcher</code>分发到元素。首先确定分发策略，然后执行。<br />事件有可能由额外事件，通过队列管理。</p><h2 id="分发行为">分发行为</h2><p>分为三个阶段</p><ul><li>涓滴</li><li>冒泡</li><li>可取消</li></ul><h2 id="事件传播">事件传播</h2><p>事件分发选择目标后，计算传播路径。</p><ul><li>从根部向目标，涓滴阶段</li><li>接收事件</li><li>上升到根部，冒泡阶段</li></ul><h2 id="事件目标">事件目标</h2><p>取决于事件类型，键盘则是当前获得焦点的元素。</p><h2 id="捕获鼠标">捕获鼠标</h2><p>任何时候只有一个元素具有捕获。捕获后，该元素是除了鼠标滚轮之外任何鼠标事件的目标。</p><h2 id="焦点环和tab顺序">焦点环和Tab顺序</h2><p>默认DFS。</p><h1 id="处理事件">处理事件</h1><h2 id="注册事件回调">注册事件回调</h2><p>传播路径上除目标外可以对一个事件接受两次，涓滴和冒泡。<br />默认是在目标和冒泡阶段执行。如要在涓滴时执行，使用<code>TrickleDown.TrickleDown</code>注册回调。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 为涓滴阶段注册回调myElement.RegisterCallback&lt;MouseDownEvent&gt;(MyCallback, TrickleDown.TrickleDown);</code></pre></div></figure></p><h2 id="发送自定义数据到事件回调">发送自定义数据到事件回调</h2><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;将用户数据一起发送到回调myElement.RegisterCallback&lt;MouseDownEvent, MyType&gt;(MyCallbackWithData, myData);void MyCallbackWithData(MouseDownEvent evt, MyType data) &#123; &#x2F;* ...*&#x2F; &#125;</code></pre></div></figure><h2 id="为控件处理输入事件">为控件处理输入事件</h2><h3 id="捕获指针">捕获指针</h3><p>使用CaptureEvents</p><h3 id="使用操纵器处理事件">使用操纵器处理事件</h3><h3 id="自定义控件">自定义控件</h3><p>两种方式</p><ul><li>注册事件回调</li><li>实现默认操作<br />区别</li><li>回调在实例上注册，默认操作作为一个类的虚拟函数</li><li>回调传播路径上所有元素都会执行。默认操作仅对事件目标执行</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">override void ExecuteDefaultActionAtTarget(EventBase evt)&#123;    &#x2F;&#x2F; 调用基函数。    base.ExecuteDefaultActionAtTarget(evt);    if (evt.GetEventTypeId() &#x3D;&#x3D; MouseDownEvent.TypeId())    &#123;        &#x2F;&#x2F; ...    &#125;    else if (evt.GetEventTypeId() &#x3D;&#x3D; MouseUpEvent.TypeId())    &#123;        &#x2F;&#x2F; ...    &#125;    &#x2F;&#x2F;更多事件类型&#125;</code></pre></div></figure><h1 id="综合事件">综合事件</h1><p>事件系统使用事件池。</p><ol type="1"><li>从事件池中获取一个事件对象</li><li>填写事件属性</li><li>包含在<code>using</code>中确保其返回到事件池</li><li>事件传递给<code>element.SendEvent()</code></li></ol><p>要发送来自操作系统的事件，使用<code>UnityEngine.Event</code>初始化事件<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">void SynthesizeAndSendKeyDownEvent(IPanel panel, KeyCode code,     char character &#x3D; &#39;\0&#39;, EventModifiers modifiers &#x3D; EventModifiers.None)&#123;    &#x2F;&#x2F; Create a UnityEngine.Event to hold initialization data.    var evt &#x3D; new Event() &#123;        type &#x3D; EventType.KeyDownEvent,        keyCode &#x3D; code,        character &#x3D; character,        modifiers &#x3D; modifiers    &#125;;    using (KeyDownEvent keyDownEvent &#x3D; KeyDownEvent.GetPooled(evt))    &#123;        panel.visualTree.SendEvent(keyDownEvent);    &#125;&#125;</code></pre></div></figure></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>uitoolkit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hololens2-mrtk3</title>
    <link href="/2023/01/15/Hololens2-mrtk3/"/>
    <url>/2023/01/15/Hololens2-mrtk3/</url>
    
    <content type="html"><![CDATA[<h1 id="悲报">悲报</h1><p>2023.01.23<br />微软已经解雇了从事虚拟现实、混合现实和HoloLens开发的团队。<br />MRTK开发也停止了</p><p>记录下mrtk3开发Hololens2应用的配置</p><h1 id="项目配置">项目配置</h1><ul><li>基础3D项目</li><li>切换到UWP<ul><li>ARM64</li></ul></li><li>使用 MixedRealityFeatureTool<ul><li>本质上就是一个包管理器，负责下载包，修改<code>manifest.json</code>文件</li><li>里面功能五花八门，基础的就先选择<code>com.microsoft.mixedreality.openxr</code>和<code>com.microsoft.mixedreality.toolkit.foundation</code></li></ul></li><li>打开后会有MRTK的配置向导，按其要求配置即可，如主相机的背景色，深度模式等等。</li><li>然后build成VS项目，由VS打开</li><li>配置远端IP，部署即可</li></ul><p>如果要使用MRTK3，之前就改为启用MRTK 输入和MRTK UX 组件</p><h1 id="定位">定位</h1><h2 id="二维码定位">二维码定位</h2><p>简单方便，但对二维码的大小有要求</p><h2 id="世界锁定">世界锁定</h2><p>通常的VR开发是以一个固定的坐标点如（地板）作为原点，虚拟与显示相匹配。<br />而AR会不断修正自身与世界各个坐标的位置，这就很难去用一个统一的坐标去计算.<br />所以可以使用数个二维码来做定位，每个现实的二维码都和虚拟的相对应，同时每个二维码都生成一个以自身为基准（并不是原点）的坐标系，我们在三个（假如有）坐标系中间，依据距离的远近来插值出一个新的坐标系，使用这个来调整摄像机的父级，就可以平滑的在各个坐标之间动态改变而不至于使体验者有太大的跳动感。<br />所以每当体验者非常靠近一个二维码，那就会100%使用这个二维码的坐标系，这样看起来这里的现实的二维码和虚拟的会完全匹配，但其他的未必会匹配。这样就可以在关键物体边多放置几个来提高精度，同时在用户移动自身位置时也能较好的匹配用户临近的空间。<br />世界锁定目前还不支持Unity2022</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hololens</tag>
      
      <tag>mrtk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高度置换贴图</title>
    <link href="/2023/01/03/Displacement/"/>
    <url>/2023/01/03/Displacement/</url>
    
    <content type="html"><![CDATA[<p>根据虚幻提供的<ahref="https://docs.unrealengine.com/5.1/zh-CN/xr-best-practices-in-unreal-engine/">最佳实践</a>在VR中，由于法线贴图不会考虑到双目显示和运动，它提供的效果和视差贴图比起来差距很大。对应到Unity中，在HDRP的Lit着色器下，指的就是HeightMap。<br />下面罗列一下使用HeightMap的一些注意事项。</p><h1 id="置换模式">置换模式</h1><p>大体分两类，一种是将高度图映射到顶点上，顶点置换，还一种是在像素级别的置换。</p><h2 id="顶点置换">顶点置换</h2><p>简单易懂，效果也很好，缺点是要求模型有很多顶点才有比较好的效果。</p><p>或者使用曲面细分，增加很多的顶点，效果也不错，缺点是当头显摄像机移动时，细分的顶点会发生变动，体现在视觉上就是模型的顶点在跳动。<br /><img src="TDis.png" alt="曲面细分+置换" /></p><h2 id="像素置换">像素置换</h2><p>后者在较高的迭代次数下，效果也不错。<br />具体的实现可以参考<ahref="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/05%20Parallax%20Mapping/">视差贴图</a>。<br />Unity的HDRP具体采用的方案叫做陡峭视差映射(Steep ParallaxMapping)。<br />这里贴一张关键的图：<br /><imgsrc="https://learnopengl-cn.github.io/img/05/05/parallax_mapping_steep_parallax_mapping_diagram.png"alt="陡峭视差映射" /></p><p>这里要注意在使用时，有两个关键的参数不要忘记：<code>Primitive Length</code><code>Primitive Width</code>，表示实际物体的长和宽。如果没有正确填写，就会出现物体下沉或者漂浮的情况。同时为了准确的显示高度对深度的影响，<code>Depth Offset</code>也要开启，这会修改实际写入深度图的深度。写入的深度同时也会影响各种平面空间的效果，比如屏幕空间阴影。</p><figure><img src="PDis.png" alt="像素级别置换" /><figcaption aria-hidden="true">像素级别置换</figcaption></figure><h1 id="urp呢">URP呢</h1><p>URP虽然也提供了HeightMap，但从效果来看，应该只是简单的视差贴图映射，和HDRP默认的陡峭视差映射差距很大。<br /><img src="URPDis.png" alt="URP默认的视差贴图映射" /><br />但如果使用ShaderGraph，还是提供了两种视差映射。<br /><img src="Para.png" alt="ShaderGraph提供的两种节点" /><br />前者就是简单的视差映射，后者的效果就和HDRP一样。<br />但很遗憾，这里虽然给出了<code>Depth Offset</code>，但目前的URP的节点还无法使用。<br />也就是说目前（2022.2.0），想要在URP下使用PDO（Pixel DepthOffset），只有自己写了，这里有个<ahref="https://forum.unity.com/threads/pdo-pixel-depth-offset-in-pallax-occlusion-mapping-ndoe.1132408/">栗子</a>。<br />这里挖个坑，等到BlockShader成熟了，就用BlockShader写一遍。</p>]]></content>
    
    
    <categories>
      
      <category>渲染</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高度贴图</tag>
      
      <tag>视差</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>圆角描边矩形</title>
    <link href="/2023/01/03/UIShader/"/>
    <url>/2023/01/03/UIShader/</url>
    
    <content type="html"><![CDATA[<p>UI总是会有很多奇奇怪怪的圆角矩形，虽然要在UIToolkit中实现是很简单的事情，但目前还是不太成熟，还是要用UGUI。在UGUI中要实现大致有三种方法，这里用Shader来实现一下。<br /><span id="more"></span></p><h1 id="单纯圆角图片">单纯圆角图片</h1><p>这是最麻烦且没必要的一种，针对不同分辨率和曲率要UI给出不同的图片，效率很低</p><h1 id="切片">9切片</h1><p><imgsrc="https://docs.unity3d.com/cn/current/uploads/Main/9SliceSprites-0.png"alt="9SliceSprites" /><br />把图片分割成9个部分，每个部分有不同的UV平铺与重复的方式，但是要实现像素级别的点对点，就需要准备不同分辨率的切片圆角矩形，也很麻烦</p><h1 id="shader实现">Shader实现</h1><p>直接用SDF实现，一劳永逸。保证点对点的准确度，即使再搞什么圆角加描边也能快速实现。</p><h2 id="ui-shader">UI shader</h2><p>UI的shader与一般的差别不大，只是对一些命名有点小要求。</p><ul><li>传入的主贴图名称为<code>_MainTex</code>当然如果你不想用Image传入的就随便了。</li><li>同时还会传入颜色<code>float4 color    : COLOR;</code></li><li>默认的一些配置<ul><li>ZClip True</li><li>ZTest Always</li><li>ZWrite Off</li><li>Cull Off</li></ul></li><li>UGUI传入的顶点并不仅仅是一个面片，根据不同的设置，它会生成特定的网格传入GPU，而且UV分布也不一定是均匀的，所以要用特定的简单Sprite。</li></ul><h2 id="sdf">SDF</h2><p>从shaderToy上抄一个<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float sdRoundedBox(in float2 p, in float2 b, in float4 r)&#123;    r.xy &#x3D; (p.x &gt; 0.0) ? r.xy : r.zw;    r.x &#x3D; (p.y &gt; 0.0) ? r.x : r.y;    float2 q &#x3D; abs(p) - b + r.x;    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;&#125;</code></pre></div></figure></p><h2 id="shader">Shader</h2><p>最后贴一下Shader<br /><img src="Ran.png" alt="圆角描边矩形" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">Shader &quot;Unlit&#x2F;UITest&quot;&#123;    Properties    &#123;        _OutlineColor(&quot;Outline Color&quot;, Color) &#x3D; (1,0,0,1)        [PerRendererData] _MainTex(&quot;Base Map&quot;, 2D) &#x3D; &quot;white&quot;        _scale(&quot;Scale width&#x2F;height&quot;, float) &#x3D; 1.0        _width(&quot;Outline Width&quot;, float) &#x3D; 1.0        _Radius(&quot;Radius&quot;, Vector) &#x3D; (0.1, 0.1, 0.1, 0.1)    &#125;    SubShader    &#123;        Tags        &#123;            &quot;RenderType&quot; &#x3D; &quot;Transparent&quot;            &quot;RenderPipeline&quot; &#x3D; &quot;UniversalPipeline&quot;            &quot;Queue&quot;&#x3D;&quot;Transparent&quot;        &#125;        Pass        &#123;            Name &quot;Default&quot;            Blend SrcAlpha OneMinusSrcAlpha            ZClip True            ZTest Always            ZWrite Off            Cull Off            HLSLPROGRAM            #pragma vertex vert            #pragma fragment frag            #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;            struct Attributes            &#123;                float4 positionOS : POSITION;                float4 color : COLOR;                float2 uv : TEXCOORD0;            &#125;;            struct Varyings            &#123;                float4 positionHCS : SV_POSITION;                float4 color : COLOR;                float2 uv : TEXCOORD0;            &#125;;            TEXTURE2D(_MainTex);            SAMPLER(sampler_MainTex);            CBUFFER_START(UnityPerMaterial)            float4 _MainTex_ST;            float4 _OutlineColor;            float _scale;            float _width;            float4 _Radius;            CBUFFER_END            Varyings vert(Attributes IN)            &#123;                Varyings OUT;                OUT.positionHCS &#x3D; TransformObjectToHClip(IN.positionOS.xyz);                OUT.color &#x3D; IN.color;                OUT.uv &#x3D; TRANSFORM_TEX(IN.uv, _MainTex);                return OUT;            &#125;            float sdRoundedBox(in float2 p, in float2 b, in float4 r)            &#123;                r.xy &#x3D; (p.x &gt; 0.0) ? r.xy : r.zw;                r.x &#x3D; (p.y &gt; 0.0) ? r.x : r.y;                float2 q &#x3D; abs(p) - b + r.x;                return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;            &#125;            float boxDist(float2 p, float2 size, float radius)            &#123;                size -&#x3D; float2(radius,radius);                float2 d &#x3D; abs(p) - size;                return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;            &#125;            half4 frag(Varyings IN) : SV_Target            &#123;                half4 color &#x3D; SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, IN.uv) * IN.color;                float2 uv &#x3D; (IN.uv * 2 - 1) ;                uv.x *&#x3D; _scale;                float d &#x3D; sdRoundedBox(uv, float2(_scale,1), _Radius);                if (d &gt; 0.0)                    color &#x3D; half4(0, 0, 0, 0);                else if (d &gt; - _width)                    color &#x3D; _OutlineColor;                return color;            &#125;            ENDHLSL        &#125;    &#125;&#125;</code></pre></div></figure><h2 id="其他">其他</h2><p>这里的SDF可以简单替换其他各种奇奇怪怪的类型，比如参考这个链接<ahref="https://iquilezles.org/articles/distfunctions2d/">distfunctions2d</a>。再结合一些变化的参数就可以做出动画效果了。</p>]]></content>
    
    
    <categories>
      
      <category>渲染</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shader</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XR开发的各种SDK以及相关概念</title>
    <link href="/2022/12/30/openxr/"/>
    <url>/2022/12/30/openxr/</url>
    
    <content type="html"><![CDATA[<p>简要记录一下几个常用的概念以及sdk的选择</p><h1 id="openxr">OpenXR</h1><p><imgsrc="https://upload.wikimedia.org/wikipedia/commons/3/3a/OpenXR_logo.svg" /><br /><code>OpenXR</code>是一套由KhronosGroup发起的跨平台的，通用的标准。简单来说就是定义了一套接口（不仅仅是接口），硬件厂商如steamvr、pico等实现这一套接口。unity或者虚幻等等引擎再适配这套接口，大家就可以用同一套标准去开发，省去了为不同平台适配的麻烦。<br />仅PC上绝大多数VR都为<code>OpenXR</code>提供了运行环境，如<code>steamVR</code>、<code>Windows Mixed Reality</code>等，安卓端的Pico以及oculus也都适配了<code>OpenXR</code><br />但缺点是无法调用某些特定平台的特定的接口，比如steamVR可以在加载时预先传输个天空盒当作loading，steamVR还有自己的手部骨骼动画，pico也有自己的比如VR合成层等功能是无法通过openxr来调用的。<br />如果采用OpenXR开发安卓端VR还有个很大优势就是可是用PC端的VR来调试功能，大大提高开发效率。</p><h1 id="unity-xr-plugin-architecture">Unity XR Plugin Architecture</h1><p>Unity 2019.3之后，官方提供了一个叫做XR插件框架的东东，通过包管理器安装，大大简化了XR开发的流程，在此基础之上，各大硬件厂商开发自己的适配Unity的XR开发SDK，如Steam的<code>OpenVR</code>，pico的<code>picoVR</code>，Oculus的<code>Oculus XR Plugin</code>、微软的<code>Windows Mixed Reality</code>等等，当然还有官方自己为了openxr开发的<code>OpenXR Plugin</code>。</p><h1 id="openxr-plugin">OpenXR Plugin</h1><p>由Unity官方开发的，适配了<code>openxr</code>以及<code>unity XR Plugin Architecture</code>的插件，Unity还为这个插件开发了<code>XR Interaction Toolkit</code>作为最基础的XR交互。</p><h1 id="xr-interaction-toolkit">XR Interaction Toolkit</h1><p>适配了OpenXR，实现了基础的XR交互的官方插件，包含了常用的射线、抓取、UI交互（仅限UGUI，不支持UIToolkit）、传送等等基础功能，同时留下了丰富的接口方便开发者自己实现想要的功能。</p><h1 id="openvr">OpenVR</h1><p>和<code>OpenXR</code>很像，但完全不是一码事，这个是V社开发的为了各个硬件厂商适配SteamVR的标准，同时提供了<code>OpenVR Loader</code>来适配Unity的<code>Unity XR Plugin Architecture</code>。包含在<code>SteamVR Plugin</code>中。</p><h1 id="steamvr-plugin">SteamVR Plugin</h1><p>V社开发的一套SDK，包含了<code>OpenVR</code>插件来适配<code>unity XR Plugin</code>，同时还有一系列的其他与SteamVR交互的接口，如输入绑定、手部骨骼、loading天空盒子、ViveTrakcer等等。<br /><del>但是已经快两年没有更新了。</del></p><h1 id="pico">Pico</h1><p>pico提供了两套SDK，一套是纯粹的<code>PICO Unity OpenXR Plugin</code>，即实现了<code>OpenXR</code>的SDK，同时还有一套叫做<code>PICO Unity Integration SDK</code>，这里就包含了其他特定与Pico平台的功能，如平台用户相关的、注视点渲染、VR合成层等等。但二者都兼容了<code>XR Interaction Toolkit</code>，对于开发还是很友好的。</p><h1 id="总结">总结</h1><p>所以在开发前要想清楚，到底是要适配多平台，还是想要某个平台特定的功能，二者<del>不可</del>很难兼得。</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenXR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>喷涂、绘制与填充</title>
    <link href="/2022/12/26/draw/"/>
    <url>/2022/12/26/draw/</url>
    
    <content type="html"><![CDATA[<h1 id="喷涂与绘制">喷涂与绘制</h1><p>又是一个烂大街的效果，但毕竟还没有做过。这里记录和总结一下。<br /><span id="more"></span><br />最为出名的应该就是老任的Splatoon了，不仅是视觉效果，整个游戏的玩法都是建立在喷涂上的。<br />另一个有印象的就是V社的alyx的开头一章上的玻璃或者黑板上用水彩绘制了。<br />最近Unity官方也分享了一个视频，利用了SDF，效果也很好。</p><h1 id="实现">实现</h1><p>最基础的想法就是用世界坐标来判断是否接触<br /><img src="dis.png" alt="距离判断" /></p><p>然后要求模型有一套不重叠的UV，使用这个UV作为顶点着色器的坐标输出，把接触的部分在UV空间下绘制到一张RT上。<br /><img src="draw_rt.png" alt="RT" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">&#x2F;&#x2F; 使用UV作为顶点着色器的坐标输出float4 uv &#x3D; float4(0, 0, 0, 1);uv.xy &#x3D; float2(1, _ProjectionParams.x) * (OUT.uv.xy * 2 - 1);OUT.positionHCS &#x3D; uv;</code></pre></div></figure><p>最后再使用这张RT去渲染就好了。</p><p>简单贴一下<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">CBUFFER_START(UnityPerMaterial)float4 _BaseMap_ST;float4 _SplatColor;float3 _position;float _radius;CBUFFER_ENDVaryings vert(Attributes IN)&#123;    Varyings OUT;    OUT.positionHCS &#x3D; TransformObjectToHClip(IN.positionOS.xyz);    OUT.uv &#x3D; TRANSFORM_TEX(IN.uv, _BaseMap);    float4 uv &#x3D; float4(0, 0, 0, 1);    uv.xy &#x3D; float2(1, _ProjectionParams.x) * (OUT.uv.xy * 2 - 1);    OUT.positionHCS &#x3D; uv;    OUT.positionWS &#x3D; TransformObjectToWorld(IN.positionOS.xyz);    return OUT;&#125;half4 frag(Varyings IN) : SV_Target&#123;    half4 color &#x3D; SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, IN.uv);    float3 distence &#x3D; IN.positionWS - _position;    float distenceLength &#x3D; length(distence);    if (distenceLength &lt; _radius)    &#123;        color &#x3D; _SplatColor;    &#125;    else    &#123;        clip(-1);    &#125;    return color;&#125;</code></pre></div></figure></p><p>然后是对应的RenderFeature的pass</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)&#123;    if(renderTexture!&#x3D;null &amp;&amp; material!&#x3D;null)    &#123;        foreach (var splatable in Splatable.splatables)        &#123;                            var cmd &#x3D; CommandBufferPool.Get(&quot;SplatRenderPass&quot;);            cmd.SetRenderTarget(splatable.splatTexture);            cmd.ClearRenderTarget(true, false, Color.black);            cmd.SetViewProjectionMatrices(Matrix4x4.identity, Matrix4x4.Ortho(0, 1, 0, 1, -1, 1));                    material.SetVector(&quot;_position&quot;, splatable.targetPen.position);                        cmd.DrawMesh(splatable.mesh, splatable.transform.localToWorldMatrix, material);            context.ExecuteCommandBuffer(cmd);            CommandBufferPool.Release(cmd);        &#125;    &#125;&#125;</code></pre></div></figure><figure><img src="yu2.gif" alt="绘制" /><figcaption aria-hidden="true">绘制</figcaption></figure><h2 id="连续问题">连续问题</h2><p>可以看到，因为是每一帧仅绘制一个点，手柄快速移动就会出现不连贯的点，这里改成记录前后两帧的位置，用一个胶囊体的sdf去计算。</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float sdCapsule( vec3 p, vec3 a, vec3 b, float r )&#123;  vec3 pa &#x3D; p - a, ba &#x3D; b - a;  float h &#x3D; clamp( dot(pa,ba)&#x2F;dot(ba,ba), 0.0, 1.0 );  return length( pa - ba*h ) - r;&#125;</code></pre></div></figure><figure><img src="draw2.gif" alt="连续绘制" /><figcaption aria-hidden="true">连续绘制</figcaption></figure><h2 id="利用sdf解决锯齿">利用SDF解决锯齿</h2><p>这里用到了一个之前没用过的ShaderLab命令<code>BlendOp</code>，用来定义混合的操作，默认是add，这里改成max。<br />贴图的rgb存储颜色，a通道用来存储SDF。</p><p>最后显示时用A通道来判定是否是喷涂区域：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">fixed4 col &#x3D; tex2D(_MainTex, i.uv);float aa &#x3D; col.a;aa &#x3D; aa - 0.5;if(aa&lt;0)&#123;    clip(-1);&#125;</code></pre></div></figure></p><figure><img src="drawsdf.png" alt="SDF绘制" /><figcaption aria-hidden="true">SDF绘制</figcaption></figure><p>这里的贴图分辨率降低为1024（之前是4096），也可以明显看到去除了边缘锯齿。但颜色过度地方的锯齿还是存在，可以统一颜色或者提高分辨率来解决这个问题。</p><h2 id="防抖">防抖</h2><p>VR下难免手抖，这里就偷懒同官方的XRtoolkit中的<code>XR Grab Interactable</code>组件自带的平滑移动解决。</p><h2 id="其他">其他</h2><p>仅就复刻ALYX中的水彩笔还算是比较成功了，后续如果还要添加功能，可以考虑像Splatoon一样，考虑水彩的厚度，喷溅的墨点，对法线的影响以及人物的交互等等花活了。</p><h2 id="封闭区域判断">封闭区域判断</h2><p>还有一个需求，要求提取出其中被线包围的封闭区域。这里就简单用DFS实现吧。</p><p>把RenderTexture中的像素提出来，用alpha通道来作为边界判断依据，转换成二维的布尔数组，true表示涂上了颜色，false表示没有。</p><p>从左上角开始深度优先遍历每个像素，</p><ul><li>如果这个像素为True，跳过。</li><li>为false，临时记录到一个数组中，然后遍历他的上下左右像素，<ul><li>如果存在一个像素越界了，说明这里和外边界相通，标记失败，表示这是和外边界相通的像素。</li><li>如果没有越界，但是值为true，说明和喷涂的像素相连，不用再遍历他的上下左右了</li><li>最后没有越界，但是值为false，还是要遍历他的上下左右</li></ul></li><li>遍历完成后，判断是否有像素越界，如果有，临时记录的全部像素结果记为false，反之记为true。</li></ul><p>深度优先虽然简单，但对于512*512这种体量的数据都会堆栈溢出。还是改成bfs吧。</p><p>用一个队列来保存相邻的像素，广度优先遍历，一旦发现与外边界连通就全记为false，反之说明这个连通区域是封闭的。</p><p>因为全部搜索都是在二维UV平面进行的，所以要求模型的UV只能有一块，且接缝处无法算作闭合区域。<br />因为这里涉及了对GPU贴图的读写，效率只能说马马虎虎。也许可以使用computeShader来实现，<del>但目前我还是想不到。</del></p><figure><img src="draw3.gif" alt="封闭区域判断与绘制" /><figcaption aria-hidden="true">封闭区域判断与绘制</figcaption></figure><h2 id="计算着色器实现">计算着色器实现</h2><p>鼓捣了半天，又把计算着色器翻出来看了看。<br />很少用到，之前写SSR时用过一次，然后就忘干净了。这次为了优化之前写的封闭区域判断，即泛洪算法，尝试用computeShader来实现一次，加深一下印象。</p><h3 id="泛洪算法">泛洪算法</h3><p>画图工具中的油漆桶工具，以及PS中的魔棒工具都属于典型的泛洪算法的用例。如果是用CPU实现，那就是之前写的简单的DFS或者BFS都可以，既然在Unity中实现，那就不能错过用GPU实现的机会了。</p><h3 id="gpu泛洪">GPU泛洪</h3><p>首先是精确的GPU泛洪，从一个点出发，颜色设置为白色，然后对每个像素，如果它是白色，那就把他四周不是黑色的像素也置为白色，就这样一直循环N遍，就可以得到类似下图的效果了：</p><figure><img src="fill.png" alt="原图" /><figcaption aria-hidden="true">原图</figcaption></figure><figure><img src="draw4.gif" alt="GPU泛洪" /><figcaption aria-hidden="true">GPU泛洪</figcaption></figure><p>再结合之前的喷涂的贴图，就可以快速的从边缘开始泛洪，以此来判断封闭区域了。</p><p><img src="draw5.gif" alt="GPU泛洪分步骤演示" /><br />改成用GPU算果然快了很多，尤其是省略了从GPU读取像素到内存的开销，可以说不在一个数量级上。<br />如果还是要优化的话，我只能想到降低分辨率再上采样了，因为使用了SDF，所以低分辨率也可以接受。</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">#pragma kernel CSMain#pragma kernel CSClean#define thread_group_x 8#define thread_group_y 8#define thread_x 8#define thread_y 8&#x2F;&#x2F; Create a RenderTexture with enableRandomWrite flag and set it&#x2F;&#x2F; with cs.SetTextureRWTexture2D&lt;float4&gt; Result;Texture2D&lt;float4&gt; Source;[numthreads(8,8,1)]void CSMain(uint3 id : SV_DispatchThreadID)&#123;    if (Result[id.xy].a &lt; 0.5)    &#123;        float4 top &#x3D; Source[id.xy + uint2(0, 1)];        float4 bottom &#x3D; Source[id.xy + uint2(0, -1)];        float4 left &#x3D; Source[id.xy + uint2(-1, 0)];        float4 right &#x3D; Source[id.xy + uint2(1, 0)];        if (top.a &lt; 0.5)            Result[id.xy + uint2(0, 1)] &#x3D; float4(0, 0, 0, 0);        if (bottom.a &lt; 0.5)            Result[id.xy + uint2(0, -1)] &#x3D; float4(0, 0, 0, 0);        if (left.a &lt; 0.5)            Result[id.xy + uint2(-1, 0)] &#x3D; float4(0, 0, 0, 0);        if (right.a &lt; 0.5)            Result[id.xy + uint2(1, 0)] &#x3D; float4(0, 0, 0, 0);    &#125;&#125;[numthreads(8,8,1)]void CSClean(uint3 id : SV_DispatchThreadID)&#123;    if (id.x &#x3D;&#x3D; 0 || id.x &#x3D;&#x3D; 255 || id.y &#x3D;&#x3D; 0 || id.y &#x3D;&#x3D; 255)        Result[id.xy] &#x3D; float4(0, 0, 0, 0);    else        Result[id.xy] &#x3D; float4(1, 1, 1, 1);&#125;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>渲染</category>
      
    </categories>
    
    
    <tags>
      
      <tag>喷涂</tag>
      
      <tag>绘制</tag>
      
      <tag>填充</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity 2022.2.0光追效果测试</title>
    <link href="/2022/12/12/Unity2022-2/"/>
    <url>/2022/12/12/Unity2022-2/</url>
    
    <content type="html"><![CDATA[<h1 id="unity-2022.2">Unity 2022.2</h1><p>随着2022.2.0正式发布，HDRP版本也来到了14，简单测试了一下，无论是普通3D场景下的RayTracing还是VR场景下普通的光栅，都有了很大的改进。记录下踩的一些坑。<br /><span id="more"></span><br />在9400f+3070配置下，开启部分光追（阴影、AO、反射、GI），1080P分辨率下可以达到50-60帧。可以预见在一些商业场景下，对配置预算没有要求的情况下，采用4090应该可以达到一个令人满意的帧率。<br />而使用光栅渲染，在VR场景下（2016*2016）单眼分辨率，即使启用了大部分的屏幕空间效果，开启了体积雾，体积云，也可以稳定达到36帧，在ATW的加持下，对于目标帧率72帧的大部分头显，仅在产品展馆展示等对于交互要求不高的场景下，都属于可以接受的范围了。<br />如果舍弃这些屏幕空间效果，舍弃体积，再加上静态阴影，同时降低一些分辨率的话，也可以达成72帧的目标帧率。<br />之前的SSR在VR下的错误也已经修复，所以是时候尝试使用HDRP了。</p><h2 id="特性">特性</h2><p>下面总结一下目前unity支持的一些光追特性。</p><ul><li>AO</li><li>反射</li><li>阴影</li><li>接触阴影</li><li>GI</li><li>次表面</li><li>路径追踪</li><li>递归渲染</li></ul><h2 id="路径追踪">路径追踪</h2><p>纯光追，从相机发送光线，当光线照射到反射或折射表面时，递归该过程，直到到达光源。从相机到光线的一系列光线形成了一条路径。<br />就和maya，Blender使用的那种阿诺德、cycle一样，简单粗暴，不用再去费尽心思的去展UV，烘焙等等。一步到位。：<br /><img src="path.png" alt="路径追踪" /><br />但在可预见的未来，是不可能实时的。但是可以通过Recorder等工具渲染成序列帧或者视频。</p><h2 id="gi">GI</h2><p>GI目前还是比较鸡肋，性能模式下，只反弹一次，效果很不尽人意：<br /><img src="RTGI-P-b01.png" alt="RTGI Performance" /></p><p>如果启用质量模式，帧数根本顶不住。与屏幕空间GI配合使用也只能改善一点点：<br /><img src="RTGI-P-mix-b01.png" alt="RTGI Mixed" /></p><p>根本没法和烘焙光照贴图相比：<br /><img src="RTGI-lightmap-b01.png" alt="lightingmap" /><br />看来Unity的实时GI和Unreal的lumen相比，还是差了太多太多了。</p><h2 id="ao">AO</h2><p>这里采用光追提升巨大：</p><p><img src="ssao.png" alt="ssao" /><br /><img src="rtao.png" alt="rtao" /></p><h2 id="反射">反射</h2><p>这恐怕是光追最能体现效果的地方了，原先的反射方案无非：天空盒、反射探针、SSR。但都有或大或小的缺点，但光追没有，有也是我的缺点，太穷，买不起4090。<br />这里就对比ssr与光追吧。</p><p><img src="hd-ssr.png" alt="ssr" /><br /><img src="hd-rt.png" alt="光追反射" /></p><h2 id="阴影">阴影</h2><p>阴影也算是光追比较出效果的一个功能了。这里的对比还看不太出来，官方的对比更强烈。</p><figure><img src="normShadow.png" alt="级联阴影" /><figcaption aria-hidden="true">级联阴影</figcaption></figure><figure><img src="rtshadow.png" alt="光追阴影" /><figcaption aria-hidden="true">光追阴影</figcaption></figure><h2 id="其他">其他</h2><p>至于次表面和递归渲染，目前还没有深入使用。<br />总体来说，目前最适合开启光追的应该就是反射、AO、和阴影，GI属实有点鸡肋，除非场景内全是动态的物体。</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>光追</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pico VR 合成层</title>
    <link href="/2022/12/09/pico-overlay/"/>
    <url>/2022/12/09/pico-overlay/</url>
    
    <content type="html"><![CDATA[<h1 id="pico-合成层">Pico 合成层</h1><p>最近在开发一个Unity内的3603D视频播放器，查找资料后发现了这么个东东。实际体验后效果还是很好的，尤其是对于需要在VR中渲染视频、UI等平面、曲面、天空盒等等。会清晰很多。</p><h2 id="原理">原理</h2><p>这里pico的文档说的很详细了，再结合我观察他们的log总结一下。</p><p>如果使用Unity的渲染管线去渲染，是先把全部的物体（包括UI）先渲染到两张（或一组，取决与你是singlePass还是multPass）的EyeBuffer上，这个buffer的分辨率取决于你设定的渲染分辨率。然后再通过异步时间扭曲线程（AsynchronousTimewarp，ATW）对 Eye Buffer进行畸变、采样、合成等处理，以此渲染到屏幕上。</p><figure><img src="screenshot_192.168.2.64_5555.png"alt="Unity的eye buffer或者叫渲染目标，是一个正常的矩形。这里的输出显然是经过了ATW处理后的图形。" /><figcaption aria-hidden="true">Unity的eyebuffer或者叫渲染目标，是一个正常的矩形。这里的输出显然是经过了ATW处理后的图形。</figcaption></figure><p>而如果使用Pico提供的api来调用VR 合成层技术，相当于直接把纹理交给ATW线程，或者理解为把纹理当成一个新的EyeBuffer。这样少采样一次，自然减少了失真。<br />而且最关键的是这里不仅可以使用Unity内的纹理或者RenderTexture。更可以直接使用外部Android Surface，比如Android 播放器视频纹理。这就大大提高了可玩性。</p><h2 id="注意点">注意点</h2><p>具体的使用见官方文档。这里提几个官方没提及的坑。</p><ul><li>如果使用Underlay模式，即将纹理呈现在 Eye Buffer后面。在URP管线下，记得最后的片元着色器的返回要改为<code>fixed4 col = fixed4(1, 1, 1, 0);</code></li><li>使用Underlay模式时要关闭天空盒，或者自定义天空盒，保留透明像素。</li><li>同时记得大部分后处理都不能使用了，因为它们会破坏透明通道。（反正在VR场景下使用后处理也是很耗费性能的做法）</li><li>这里的清晰度和Unity的渲染分辨率就完全无关了，因为不会渲染到Unity的ColorBuffer上去。</li><li>因为是独立渲染的，所以没有抗锯齿（但影响不大，因为他渲染相当于是以物理屏幕的分辨率去渲染的，VR的像素密度很高了实际看不出有太大锯齿）</li></ul><p>下面贴几张效果图，请点击放大后比较：</p><p><img src="/images/screenshot_192.168.2.64_5555_05.png" /></p><p>尤其是上面按钮处的文字</p><p><img src="/images/screenshot_192.168.2.64_5555_03.png" /><br />这里的线在VR中头部运动时，差异更加明显。</p><p>除此之外，在解码高码率视频等方面，效率也会有一定提升。</p><h2 id="缺点">缺点</h2><p>因为这完全破坏了Unity原有的开发逻辑，开发成本上会有所提高，尤其的各种层之间的排序问题，要事先考虑清楚。<br />大部分后处理无法使用。</p><p>除此之外，目前还是有一些BUG，比如如果用全景视频充当天空盒，Pico的SDK（2.1.2版本）目前还是会报错。等待修复吧</p>]]></content>
    
    
    <categories>
      
      <category>渲染</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VR</tag>
      
      <tag>pico</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ChatGPT</title>
    <link href="/2022/12/06/ChatGPT/"/>
    <url>/2022/12/06/ChatGPT/</url>
    
    <content type="html"><![CDATA[<p>使用ChatGPT生成的打砖块游戏,仅限电脑WASD移动</p><ahref="https://www.bilibili.com/video/BV1oM411B7Za">AI生成游戏，ChatGPT使用ThreeJS生成弹球游戏</a><br /><div id="threeShader"style="position: relative; width: 100%; height: 0px; padding-bottom: 75%;"><iframe src="/static/chatGPT/index.html" allowfullscreen="true" name="ThreeJSFrame" title="ThreeJSFrame" style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px; border: none;"></iframe></div>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ChatGPT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECS 脚本</title>
    <link href="/2022/11/17/ECS-Scripting/"/>
    <url>/2022/11/17/ECS-Scripting/</url>
    
    <content type="html"><![CDATA[<h1 id="实体包中的脚本">实体包中的脚本</h1><p>本节包含有关在实体中编写脚本时的最佳实践的信息，以及您可以在脚本中使用的一些功能。</p><table><thead><tr class="header"><th>标题</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>使用方面组织代码</td><td>使用方面将实体组件的子集组合到单个 csharp 结构中。</td></tr><tr class="even"><td>Blob 资产</td><td>有关 blob资产的信息，这些资产是针对流式处理优化的二进制数据片段。</td></tr><tr class="odd"><td>在运行时加载场景</td><td>关于实体如何加载场景的信息。</td></tr><tr class="even"><td>转换系统</td><td>有关转换如何在实体中工作的信息。</td></tr></tbody></table><h1 id="使用-baking-转换数据">使用 Baking 转换数据</h1><p>Baking提供了一个系统，用于将编辑器中的游戏对象数据（创作数据）转换为写入实体场景的实体（运行时数据）。</p><p>烘焙分为多个阶段，但其核心是两个关键步骤：面包师和烘焙系统。</p><p>当您打开子场景并在其中编辑创作对象时，也会发生增量烘焙。 ECS会检测您所做的更改，并确定由于此更改而需要重新运行的最少 Baker数量。其结果在编辑模式和播放模式期间被修补到编辑器中的实体世界中。</p><h2 id="baker-类">Baker 类</h2><p>使用 Baker 类直接与 Unity 对象交互，例如创作组件。 Baker也是隐式或显式捕获依赖项的地方，如果 Baker重新运行，添加的所有组件都能够自动恢复。 Baker只能将组件添加到它正在烘焙的主要实体和它自己创建的其他实体。例如：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public class MyMonoBehaviour : MonoBehaviour&#123;   public float value;&#125;public class MyBaker : Baker&lt;MyMonoBehaviour&gt;&#123;   public override void Bake(MyMonoBehaviour authoring)   &#123;       AddComponent(new MyComponent &#123;Value &#x3D; authoring.value&#125; );   &#125;&#125;</code></pre></div></figure></p><h3 id="访问-baker-中的其他数据源">访问 Baker 中的其他数据源</h3><p>为了保持增量烘焙正常工作，您需要跟踪哪些数据用于转换 Baker中的游戏对象。创作组件中的任何字段都会被自动跟踪，如果任何数据发生变化，Baker就会重新运行。</p><p>不会自动跟踪来自其他创作组件的信息，您需要向其添加依赖项才能对其进行跟踪。为此，请使用Baker 提供的函数来访问其他组件，而不是 GameObject 提供的函数：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public struct MyComponent : IComponentData&#123;   public float Value;&#125;public class MyMonoBehaviour : MonoBehaviour&#123;   public GameObject otherGO;&#125;public class MyBaker : Baker&lt;MyMonoBehaviour&gt;&#123;   public override void Bake(MyMonoBehaviour authoring)   &#123;       var transform &#x3D; GetComponent&lt;Transform&gt;(authoring.otherGO);       AddComponent(new MyComponent &#123;Value &#x3D; transform.position.x&#125; );   &#125;&#125;</code></pre></div></figure><br />同样，如果您访问资产中的数据，则需要为其创建依赖项，以便 Baker在资产更改时重新运行。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public struct MyComponent : IComponentData&#123;   public int Value;&#125;public class MyMonoBehaviour : MonoBehaviour&#123;   public Mesh mesh;&#125;public class MyBaker : Baker&lt;MyMonoBehaviour&gt;&#123;   public override void Bake(MyMonoBehaviour authoring)   &#123;       &#x2F;&#x2F; We want to rebake if anything changes in the mesh itself       DependsOn(authoring.mesh);       AddComponent(new MyComponent &#123; Value &#x3D; authoring.mesh.vertexCount &#125; );   &#125;&#125;</code></pre></div></figure></p><h3 id="贝克斯的预制件">贝克斯的预制件</h3><p>要声明和转换预制件，请在面包师中调用 GetEntity：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public struct MyComponent : IComponentData&#123;   public Entity Prefab;&#125;public class MyMonoBehaviour : MonoBehaviour&#123;   public GameObject prefab;&#125;public class MyBaker : Baker&lt;MyMonoBehaviour&gt;&#123;   public override void Bake(MyMonoBehaviour authoring)   &#123;       AddComponent(new MyComponent &#123; Prefab &#x3D; GetEntity(authoring.prefab) &#125; );   &#125;&#125;</code></pre></div></figure><br />GetEntity返回用于创建实体预制件的实体，但此时尚未转换。这稍后会在单独的传递中发生。</p><h3 id="烘焙系统">烘焙系统</h3><p>烘焙系统是处理面包师产生的输出的常规系统，例如通过组合结果。这意味着Baking系统应该只处理实体数据，而不处理托管的创作类型，例如游戏对象和组件。这也意味着Baking 系统可以使用 Burst 和 Jobs 来处理数据。</p><p>要创建烘焙系统，请使用[WorldSystemFilter(WorldSystemFilterFlags.BakingSystem)]属性对其进行标记。这允许烘焙发现它们并将它们添加到烘焙世界。烘焙系统在每次烘焙过程中都会更新。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">[WorldSystemFilter(WorldSystemFilterFlags.BakingSystem)]partial class BakingOnlyEntityAuthoringBakingSystem : SystemBase&#123;   protected override void OnUpdate()   &#123;      &#x2F;&#x2F; … Your code here …   &#125;&#125;</code></pre></div></figure><br />虽然面包师通常是必需的，但烘焙系统是可选的，只有高级用例才需要。</p><h2 id="用方面组织你的代码">用方面组织你的代码</h2><p>方面是一种类似于对象的包装器，可用于将实体组件的子集组合到单个 csharp结构中。</p><p>本节说明如何在项目中使用方面。</p><table><thead><tr class="header"><th>主题</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>方面概念</td><td>方面概述。</td></tr><tr class="even"><td>创建方面</td><td>如何使用 IAspect 接口创建方面。</td></tr></tbody></table><h3 id="方面概念">方面概念</h3><p>方面是一种类似于对象的包装器，可用于将实体组件的子集组合到单个 csharp结构中。方面对于组织组件代码和简化系统中的查询很有用。</p><p>例如，TransformAspect将组件的各个位置、旋转和缩放组合在一起，使您能够从包含 TransformAspect的查询访问这些组件。您还可以使用 IAspect 接口定义自己的方面。</p><p>方面可以包括以下项目：</p><ul><li>用于存储实体 ID 的单个实体字段</li><li>RefRW<T> 和 RefRO<T> 字段访问实现 IComponentData 的类型 T的组件数据。</li><li>EnabledRefRW 和 EnabledRefRO 字段，用于访问实现 IEnableableComponent的组件的启用状态。</li><li>DynamicBuffer<T> 字段</li><li>其他方面类型</li></ul><h4 id="更多信息">更多信息</h4><ul><li>创建一个方面</li><li>IAspect API 文档</li><li>转换方面 API 文档</li></ul><h3 id="创建一个方面">创建一个方面</h3><p>要创建方面，请使用 IAspect接口。您必须将方面声明为只读部分结构，并且该结构必须将自身指定给IAspect<T> 泛型参数：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using Unity.Entities;readonly partial struct MyAspect : IAspect&#123;    &#x2F;&#x2F; Your Aspect code&#125;</code></pre></div></figure></p><h4 id="字段">字段</h4><p>您可以使用 RefRW<T> 或 RefRO<T>将组件声明为方面的一部分。要声明缓冲区，请使用DynamicBuffer<T>。有关可用字段的更多信息，请参阅 IAspect 文档。</p><h4 id="只读和读写访问">只读和读写访问</h4><p>使用 RefRO 和 RefRW字段提供对方面中组件的只读或读写访问。当你想在代码中引用一个方面时，使用in 来覆盖所有引用变为只读，或者使用 ref来尊重在方面中声明的只读或读写访问。</p><p>如果您使用 in来引用对组件具有读写访问权限的方面，它可能会在写入尝试时抛出异常。</p><h4 id="在系统中创建方面实例">在系统中创建方面实例</h4><p>要在系统中创建方面实例，请调用 SystemAPI.GetAspectRW 或SystemAPI.GetAspectRO：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; Throws if the entity is missing any of &#x2F;&#x2F; the required components of MyAspect.MyAspect asp &#x3D; SystemAPI.GetAspectRW&lt;MyAspect&gt;(myEntity);</code></pre></div></figure><br />如果您使用任何试图修改底层组件的方法或属性，则 SystemAPI.GetAspectRO会引发错误。</p><p>要在系统外部创建方面实例，请使用 EntityManager.GetAspect 或EntityManager.GetAspectRO。</p><h4 id="例子">例子</h4><p>在此示例中，CannonBallAspect设置坦克主题游戏中炮弹组件的变换、位置和速度。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using Unity.Entities;using Unity.Mathematics;using Unity.Transforms;&#x2F;&#x2F; Aspects must be declared as a readonly partial structreadonly partial struct CannonBallAspect : IAspect&lt;CannonBallAspect&gt;&#123;    &#x2F;&#x2F; An Entity field in an Aspect gives access to the Entity itself.    &#x2F;&#x2F; This is required for registering commands in an EntityCommandBuffer for example.    public readonly Entity Self;    &#x2F;&#x2F; Aspects can contain other aspects.    readonly TransformAspect Transform;    &#x2F;&#x2F; A RefRW field provides read write access to a component. If the aspect is taken as an &quot;in&quot;    &#x2F;&#x2F; parameter, the field behaves as if it was a RefRO and throws exceptions on write attempts.    readonly RefRW&lt;CannonBall&gt; CannonBall;    &#x2F;&#x2F; Properties like this aren&#39;t mandatory. The Transform field can be public instead.    &#x2F;&#x2F; But they improve readability by avoiding chains of &quot;aspect.aspect.aspect.component.value.value&quot;.    public float3 Position    &#123;        get &#x3D;&gt; Transform.Position;        set &#x3D;&gt; Transform.Position &#x3D; value;    &#125;    public float3 Speed    &#123;        get &#x3D;&gt; CannonBall.ValueRO.Speed;        set &#x3D;&gt; CannonBall.ValueRW.Speed &#x3D; value;    &#125;&#125;</code></pre></div></figure><br />要在其他代码中使用此方面，您可以以与组件相同的方式请求CannonBallAspect：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using Unity.Entities;using Unity.Burst;&#x2F;&#x2F; It&#39;s best practice to Burst-compile your code[BurstCompile]partial struct CannonBallJob : IJobEntity&#123;    void Execute(ref CannonBallAspect cannonBall)    &#123;        &#x2F;&#x2F; Your game logic    &#125;&#125;</code></pre></div></figure></p><h2 id="实体中的转换">实体中的转换</h2><p>本节包含有关变换如何在实体中工作以及如何控制项目中任何实体的世界空间位置、旋转和缩放的信息。</p><table><thead><tr class="header"><th>主题</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>转换概念</td><td>转换如何在实体中工作。</td></tr><tr class="even"><td>使用转换</td><td>如何在您的项目中使用转换。</td></tr><tr class="odd"><td>转换方面</td><td>如何使用 TransformAspect 来管理项目中的转换。</td></tr></tbody></table><h3 id="转变观念">转变观念</h3><p>您可以使用 Unity.Transforms命名空间来控制项目中任何实体的世界空间位置、旋转和缩放。</p><p>您还可以使用内置方面TransformAspect，将实体及其父实体移动到一起，并保持实体数据同步。有关详细信息，请参阅TransformAspect 文档。</p><p>主要的 Transform 组件是：</p><ul><li>LocalToWorldTransform：修改这些值以更改实体的世界空间位置。表示世界空间中对象的每个实体都具有此组件。重要提示：如果实体还包含LocalToParentTransform 和ParentToWorldTransform，它们将优先并覆盖您输入的 LocalToWorldTransform值。</li><li>LocalToParentTransform：表示从本地空间到父空间的转换。定义子实体如何相对于其父实体进行转换。</li><li>ParentToWorldTransform：父实体的 LocalToWorldTransform 的副本。</li></ul><p>如果所有三个 Transform 组件都存在于一个实体上，则 ECS 计算LocalToWorldTransform 为：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">LocalToWorldTransform &#x3D; LocalToParentTransform * ParentToWorldTransform</code></pre></div></figure><br />您可以使用 Convert To Entity脚本为您创建和初始化所有组件。要使用此脚本，请在 EntitiesSamples项目中打开 HelloCube 并选择大立方体。在 Inspector 中，选择 Convert ToEntity 组件，它将 GameObject 转换为实体。</p><h4 id="转换层次结构">转换层次结构</h4><p>Unity.Transforms是分层的，这意味着您可以根据实体之间的关系来转换实体。</p><p>例如，车身可以是其车轮的父级。车轮是车身的孩子。当车身移动时，车轮也随之移动。您还可以相对于车身移动和旋转车轮。</p><p>一个实体可以有多个子实体，但只有一个父实体。孩子也可以是他们自己的孩子实体的父母。这些多层次的父子关系形成了一个转换层次结构。层次结构顶部的实体（没有父实体）是根。</p><p>要声明一个 Transform层次结构，您必须从下到上执行此操作。这意味着您使用 Parent来声明实体的父实体，而不是声明其子实体。如果你想声明一个实体的孩子，找到你想成为孩子的实体，并将他们的父母设置为目标实体。有关详细信息，请参阅使用层次结构文档。</p><h3 id="使用变换">使用变换</h3><p>要在项目中使用变换，请使用 Unity.Transforms命名空间来控制项目中任何实体的世界空间位置、旋转和缩放。</p><p>要存储位置、旋转和比例值，请使用 UniformScaleTransform：</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public struct UniformScaleTransform&#123;    public float3     Position    public float      Scale    public quaternion Rotation&#125;</code></pre></div></figure><p>代表项目中对象的每个实体都有一个LocalToWorldTransform，您可以使用它来转换实体相对于它在世界空间中的位置：</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public struct LocalToWorldTransform : IComponentData&#123;    public UniformScaleTransform Value;&#125;</code></pre></div></figure><h4 id="使用层次结构">使用层次结构</h4><p>您可以单独使用 LocalToWorldTransform。但是，如果要使用 Entities的层次结构，则必须使用 Parent、LocalToParentTransform 和ParentToWorldTransform 来转换它们。</p><p>要设置子实体的父级，请使用 Parent：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public struct Parent : IComponentData&#123;    public Entity Value;&#125;</code></pre></div></figure><br />为确保父母找到他们的孩子，并设置他们的子组件，请运行 ParentSystem。</p><p>要指定如何相对于其父项定位、旋转和缩放子项，请使用LocalToParentTransform。例如，这是您可以在父汽车对象上旋转车轮的方式：</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public struct LocalToParentTransform : IComponentData&#123;    public UniformScaleTransform Value;&#125;</code></pre></div></figure><p>另一个重要的组件是 ParentToWorldTransform，它是父级LocalToWorldTransform 的副本。您需要确保孩子有这个，并且ParentToWorldTransformSystem 正在运行。</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public struct ParentToWorldTransform : IComponentData&#123;    public UniformScaleTransform Value;&#125;</code></pre></div></figure><h3 id="变换方面">变换方面</h3><p>方面系统具有内置的TransformAspect，它包含对子实体的所有三个转换组件的引用：</p><ul><li>本地到世界转换</li><li>本地到父转换</li><li>ParentToWorldTransform</li></ul><p>对于任何根实体，TransformAspect 仅包含对 LocalToWorldTransform的引用。</p><p>TransformAspect是管理项目中转换的便捷方式，因为它包含使所有这些组件彼此保持同步的逻辑。例如，如果您想在不使用TransformAspect 的情况下控制子组件的世界空间位置，则必须同时更新LocalToWorldTransform 和 LocalToParentTransform，然后在该计算中使用ParentToWorldTransform。</p><p>但是，TransformAspect会为您管理这个。这是移动可能有父实体的便捷方式。</p><p>此示例说明如何使用 TransformAspect 来旋转坦克的炮塔：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using Unity.Burst;using Unity.Entities;using Unity.Mathematics;using Unity.Transforms;[BurstCompile]partial struct TurretRotationSystem : ISystem&#123;    [BurstCompile]    public void OnCreate(ref SystemState state)    &#123;    &#125;    [BurstCompile]    public void OnDestroy(ref SystemState state)    &#123;    &#125;    [BurstCompile]    public void OnUpdate(ref SystemState state)    &#123;        &#x2F;&#x2F; The amount of rotation around Y required to do 360 degrees in 2 seconds.        var rotation &#x3D; quaternion.RotateY(state.Time.DeltaTime * math.PI);        &#x2F;&#x2F; The classic csharp foreach is what we often refer to as &quot;Idiomatic foreach&quot; (IFE).        &#x2F;&#x2F; Aspects provide a higher level interface than directly accessing component data.        &#x2F;&#x2F; Using IFE with aspects is a powerful and expressive way of writing main thread code.        foreach (var transform in SystemAPI.Query&lt;TransformAspect&gt;())        &#123;            transform.RotateWorld(rotation);        &#125;    &#125;&#125;</code></pre></div></figure></p><h1 id="blob-资产">Blob 资产</h1><p>Blob 资产是针对流式处理优化的二进制数据片段。 Blob 是 Binary LargeObject 的缩写。通过将数据写入 blob资产，您可以将其存储在一种可以高效加载并从存储在实体上的组件中引用的格式。与结构组件一样，blob资产不得包含任何托管数据：您不能在 blob资产中使用常规数组、字符串或任何其他托管对象。 Blob资产应该只包含在运行时不会更改的只读数据：它们可以同时从多个线程访问，并且（与本机容器不同）没有针对并发写入的安全检查。</p><p>为了快速加载 blob 资产，它们的数据必须是可重定位的：当您将整个 blob资产复制到另一个内存地址时，blob 资产中数据的含义不得改变。这意味着 blob资产可能不包含对自身的绝对引用，这排除了内部指针的使用。您通常通过指针存储的任何信息都必须通过相对于blob资产本身的内存地址的偏移量来引用。这主要适用于存储字符串和数组。这种使用偏移量而不是绝对指针的间接寻址的细节以两种方式影响与blob 资产的交互：</p><ol type="1"><li>必须使用 BlobBuilder 创建 Blob资产。这种类型负责为您计算相对偏移量。</li><li>必须始终使用 ref 关键字或使用 BlobAssetReference 通过引用访问和传递Blob 资产。这是确保 blob资产内的任何相对偏移仍解析为正确的绝对地址所必需的。问题又是重定位：Blob资产可以在内存中作为一个整体重定位，但按值而不是按引用访问它们通常不能保证复制整个blob 资产。</li></ol><div class="note note-info">            <p>如果您尝试使用按值包含内部指针的 blob 资产，则会出现编译器错误。</p>          </div><h2 id="创建-blob-资产">创建 blob 资产</h2><p>创建 blob 资产始终至少涉及四个步骤：</p><ol type="1"><li>创建一个 BlobBuilder。这需要在内部分配一些内存。</li><li>使用 BlobBuilder.ConstructRoot 构造 blob 资产的根</li><li>用您的数据填充结构。</li><li>使用 BlobBuilder.CreateBlobAssetReference 创建BlobAssetReference。这会将 blob 资产复制到最终位置。</li><li>处理在步骤 1 中分配的 blob 生成器。</li></ol><p>例如，这里我们将仅包含原始成员的结构存储为 blob 资产：</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">struct MarketData&#123;    public float PriceOranges;    public float PriceApples;&#125;BlobAssetReference&lt;MarketData&gt; CreateMarketData()&#123;    &#x2F;&#x2F; Create a new builder that will use temporary memory to construct the blob asset    var builder &#x3D; new BlobBuilder(Allocator.Temp);    &#x2F;&#x2F; Construct the root object for the blob asset. Notice the use of &#96;ref&#96;.    ref MarketData marketData &#x3D; ref builder.ConstructRoot&lt;MarketData&gt;();    &#x2F;&#x2F; Now fill the constructed root with the data:    &#x2F;&#x2F; Apples compare to Oranges in the universally accepted ratio of 2 : 1 .    marketData.PriceApples &#x3D; 2f;    marketData.PriceOranges &#x3D; 4f;    &#x2F;&#x2F; Now copy the data from the builder into its final place, which will    &#x2F;&#x2F; use the persistent allocator    var result &#x3D; builder.CreateBlobAssetReference&lt;MarketData&gt;(Allocator.Persistent);    &#x2F;&#x2F; Make sure to dispose the builder itself so all internal memory is disposed.    builder.Dispose();    return result;&#125;</code></pre></div></figure><p>blob 构建器的作用是构造存储在 blob资产中的数据，确保所有内部引用都存储为偏移量，最后将完成的 blob资产复制到由返回的 BlobAssetReference<T> 引用的单个分配中。</p><h3 id="使用-blobarray">使用 BlobArray</h3><p>blob资产中的数组需要特殊处理，因为它们是在内部使用相对偏移量实现的。这是使用BlobArray 类型实现的。以下是分配 blob 数据数组并填充它的方法：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">struct Hobby&#123;    public float Excitement;    public int NumOrangesRequired;&#125;struct HobbyPool&#123;    public BlobArray&lt;Hobby&gt; Hobbies;&#125;BlobAssetReference&lt;HobbyPool&gt; CreateHobbyPool()&#123;    var builder &#x3D; new BlobBuilder(Allocator.Temp);    ref HobbyPool hobbyPool &#x3D; ref builder.ConstructRoot&lt;HobbyPool&gt;();    &#x2F;&#x2F; Allocate enough room for two hobbies in the pool. Use the returned BlobBuilderArray    &#x2F;&#x2F; to fill in the data.    const int numHobbies &#x3D; 2;    BlobBuilderArray&lt;Hobby&gt; arrayBuilder &#x3D; builder.Allocate(        ref hobbyPool.Hobbies,        numHobbies    );    &#x2F;&#x2F; Initialize the hobbies.    &#x2F;&#x2F; An exciting hobby that consumes a lot of oranges.    arrayBuilder[0] &#x3D; new Hobby    &#123;        Excitement &#x3D; 1,        NumOrangesRequired &#x3D; 7    &#125;;    &#x2F;&#x2F; A less exciting hobby that conserves oranges.    arrayBuilder[1] &#x3D; new Hobby    &#123;        Excitement &#x3D; 0.2f,        NumOrangesRequired &#x3D; 2    &#125;;    var result &#x3D; builder.CreateBlobAssetReference&lt;HobbyPool&gt;(Allocator.Persistent);    builder.Dispose();    return result;&#125;</code></pre></div></figure></p><h3 id="使用-blobstring">使用 BlobString</h3><p>字符串具有与数组相同的问题，并且具有使用 BlobString的自定义支持。它们同样使用 BlobBuilder API 进行分配。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">struct CharacterSetup&#123;    public float Loveliness;    public BlobString Name;&#125;BlobAssetReference&lt;CharacterSetup&gt; CreateCharacterSetup(string name)&#123;    var builder &#x3D; new BlobBuilder(Allocator.Temp);    ref CharacterSetup character &#x3D; ref builder.ConstructRoot&lt;CharacterSetup&gt;();    character.Loveliness &#x3D; 9001; &#x2F;&#x2F; it&#39;s just a very lovely character    &#x2F;&#x2F; Create a new BlobString and set it to the given name.    builder.AllocateString(ref character.Name, name);    var result &#x3D; builder.CreateBlobAssetReference&lt;CharacterSetup&gt;(Allocator.Persistent);    builder.Dispose();    return result;&#125;</code></pre></div></figure></p><h3 id="使用-blobptr">使用 BlobPtr</h3><p>如果需要手动设置内部指针，可以使用 BlobPtr 类型。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">struct FriendList&#123;    public BlobPtr&lt;BlobString&gt; BestFriend;    public BlobArray&lt;BlobString&gt; Friends;&#125;BlobAssetReference&lt;FriendList&gt; CreateFriendList()&#123;    var builder &#x3D; new BlobBuilder(Allocator.Temp);    ref FriendList friendList &#x3D; ref builder.ConstructRoot&lt;FriendList&gt;();    const int numFriends &#x3D; 3;    var arrayBuilder &#x3D; builder.Allocate(ref friendList.Friends, numFriends);    builder.AllocateString(ref arrayBuilder[0], &quot;Alice&quot;);    builder.AllocateString(ref arrayBuilder[1], &quot;Bob&quot;);    builder.AllocateString(ref arrayBuilder[2], &quot;Joachim&quot;);    &#x2F;&#x2F; Set the best friend pointer to point to the second array element.    builder.SetPointer(ref friendList.BestFriend, ref arrayBuilder[2]);    var result &#x3D; builder.CreateBlobAssetReference&lt;FriendList&gt;(Allocator.Persistent);    builder.Dispose();    return result;&#125;</code></pre></div></figure></p><h2 id="访问组件上的-blob-资产">访问组件上的 blob 资产</h2><p>获得 Blob 资产的 BlobAssetReference<T>后，您可以将此引用存储在组件上并访问它。请注意，必须通过引用访问包含内部指针的blob 资产的所有部分。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">struct Hobbies : IComponentData&#123;    public BlobAssetReference&lt;HobbyPool&gt; Blob;&#125;float GetExcitingHobby(ref Hobbies component, int numOranges)&#123;    &#x2F;&#x2F; Get a reference to the pool of available hobbies. Note that it needs to be passed by    &#x2F;&#x2F; reference, because otherwise the internal reference in the BlobArray would be invalid.    ref HobbyPool pool &#x3D; ref component.Blob.Value;    &#x2F;&#x2F; Find the most exciting hobby we can participate in with our current number of oranges.    float mostExcitingHobby &#x3D; 0;    for (int i &#x3D; 0; i &lt; pool.Hobbies.Length; i++)    &#123;        &#x2F;&#x2F; This is safe to use without a reference, because the Hobby struct does not        &#x2F;&#x2F; contain internal references.        var hobby &#x3D; pool.Hobbies[i];        if (hobby.NumOrangesRequired &gt; numOranges)            continue;        if (hobby.Excitement &gt;&#x3D; mostExcitingHobby)            mostExcitingHobby &#x3D; hobby.Excitement;    &#125;    return mostExcitingHobby;&#125;</code></pre></div></figure></p><h2 id="我什么时候需要处理-blob-资产引用">我什么时候需要处理 blob资产引用？</h2><p>在运行时使用 BlobBuilder.CreateBlobAssetReference 分配的所有 blob资产都需要手动处理。这对于作为从磁盘加载的实体场景的一部分加载的 blob资产是不同的：所有这些 blob资产都是引用计数的，一旦没有组件引用它们就会自动释放。不得手动处理它们。</p><h2 id="调试-blob-资产内容">调试 blob 资产内容</h2><p>Blob 资产使用相对偏移量实现内部引用。这意味着复制 BlobString结构（或具有这些内部引用的任何其他类型）将复制包含的相对偏移量，而不是它指向的内容。这样做的结果是一个不可用的BlobString，它将代表一个基本上随机的字符串。虽然这在您自己的代码中很容易避免，但调试实用程序通常会做到这一点。因此，BlobString的内容无法在调试器中正确显示。</p><p>但是，支持显示 BlobAssetReference<T> 的值及其所有内容。如果要查找BlobString 的内容，请导航到包含的 BlobAssetReference<T>并从那里开始调试。</p><h1 id="在运行时加载场景">在运行时加载场景</h1><h2 id="串流">串流</h2><p>加载大场景需要时间，所以为了避免卡顿，DOTS中的所有场景加载默认都是异步的。这称为流式传输。</p><p>由于改造项目以使用流式处理可能很繁重，因此您最好尽早决定是否在项目中使用流式处理。</p><p>流式传输的主要优点是：</p><ul><li>当场景在后台流式传输时，应用程序可以保持响应。</li><li>通过在不中断游戏玩法的情况下动态加载和卸载场景，可以实现比内存更大的无缝世界。</li><li>在编辑器播放模式下，如果实体场景文件丢失或过时，场景将按需转换。因为实体场景的转换和加载是异步发生的并且在一个单独的进程中，所以编辑器保持响应。</li></ul><p>流式传输的主要缺点是：</p><ul><li>游戏不能假定加载的数据立即存在，尤其是在启动时。这使得游戏代码有点复杂。</li><li>场景由“场景系统组”中的系统加载，“场景系统组”本身是“初始化组”的一部分。在帧中更新较晚的系统将在同一帧中看到加载的数据，但更新早于该组的系统直到下一帧才会看到加载的数据。然后，您的代码必须在单个-框架内解决这种不一致的数据视图。</li></ul><h2 id="the-subscene-monobehaviour">The Subscene Monobehaviour</h2><p>Subscene Monobehavior 是一个简单的 Unity组件，它抽象了转换和流式处理问题。</p><p>打开子场景时，创作游戏对象场景会显示在父场景的层次结构中。<br />关闭子场景时，转换后的场景的内容将流入。<br />本页的其余部分描述了如何在不使用 Subscene MonoBehavior的情况下直接控制流式传输。</p><h2 id="场景加载-101">场景加载 101</h2><p>用于处理场景的高级 API 由 SceneSystem 提供。</p><p>这是在运行时加载场景的最基本示例。这应该在系统的 OnUpdate中完成。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; Note: calling GetSceneGUID is slow, please keep reading for a proper example.var guid &#x3D; SceneSystem.GetSceneGUID(ref World.Unmanaged.GetExistingSystemState&lt;SceneSystem&gt;(), &quot;Assets&#x2F;Scenes&#x2F;SampleScene.unity&quot;);var sceneEntity &#x3D; SceneSystem.LoadSceneAsync(World.Unmanaged, guid);</code></pre></div></figure></p><div class="note note-warning">            <p>此示例计划加载。在调用 LoadSceneAsync期间，唯一创建的是场景实体，然后使用它来控制加载过程的其余部分。值得注意的是，场景标题、部分实体及其内容此时尚未加载，只会在几帧后出现在世界中。</p>          </div><ul><li>在 DOTS 的上下文中，场景 GUID 是 Hash128。</li><li>该路径指向 Unity创作场景。如果对应的实体场景文件丢失或过期，则触发转换。</li></ul><h2 id="使用场景-guid">使用场景 GUID</h2><p>通过 GUID识别场景比使用字符串路径更有效。因此，通常的方法是在转换期间存储场景GUID，以用于在运行时加载<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">    &#x2F;&#x2F; Runtime component, SceneSystem uses Entities.Hash128 to identify scenes.    public struct SceneLoader : IComponentData    &#123;        public Hash128 Guid;    &#125;#if UNITY_EDITOR    &#x2F;&#x2F; Authoring component, a SceneAsset can only be used in the Editor    public class SceneLoaderAuthoring : MonoBehaviour    &#123;        public UnityEditor.SceneAsset Scene;        class Baker : Baker&lt;SceneLoaderAuthoring&gt;        &#123;            public override void Bake(SceneLoaderAuthoring authoring)            &#123;                var path &#x3D; AssetDatabase.GetAssetPath(authoring.Scene);                var guid &#x3D; AssetDatabase.GUIDFromAssetPath(path);                AddComponent(new SceneLoader &#123; Guid &#x3D; guid &#125;);            &#125;        &#125;    &#125;#endif</code></pre></div></figure><br />在运行时处理 SceneLoader 组件的示例系统如下所示：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">[RequireMatchingQueriesForUpdate]public partial class SceneLoaderSystem : SystemBase&#123;    private EntityQuery m_NewRequests;    protected override void OnCreate()    &#123;        m_NewRequests &#x3D; GetEntityQuery(typeof(SceneLoader));    &#125;    protected override void OnUpdate()    &#123;        var requests &#x3D; m_NewRequests.ToComponentDataArray&lt;SceneLoader&gt;(Allocator.Temp);        for (int i &#x3D; 0; i &lt; requests.Length; i +&#x3D; 1)        &#123;            SceneSystem.LoadSceneAsync(World.Unmanaged, requests[i].Guid);        &#125;        requests.Dispose();        EntityManager.DestroyEntity(m_NewRequests);    &#125;&#125;</code></pre></div></figure></p><div class="note note-info">            <p>在编辑器中，SceneSystem.GetGUID 函数在内部使用UnityEditor.AssetDatabase 类将场景路径映射到 GUID。</p><p>在独立播放器中，无法使用 UnityEditor.AssetDatabase，因此SceneSystem.GetGUID改为使用“StreamingAssets/catalog.bin”文件。这个“catalog.bin”文件只不过是一个“GUID路径”映射表，该目录文件是通过使用构建配置进行独立构建而生成的）。</p>          </div><h2 id="场景和部分元实体">场景和部分元实体</h2><p>创作场景的转换会生成实体场景文件。每个实体场景文件的头部包含：</p><ul><li>部分列表（包含文件名、文件大小、边界体积等数据）。</li><li>资产包依赖项 (GUID) 的列表。</li><li>可选的用户定义的元数据。</li></ul><p>部分和捆绑包的列表决定了应该加载的文件列表，自定义元数据可用于特定于游戏的目的。例如，自定义元数据可以包含PVS 信息以告知何时流式传输场景的决定，或者诸如“此场景仅在任务 XYZ处于活动状态时才相关”的游戏条​​件。由每个游戏决定如何使用自定义元数据。但是使用自定义元数据既是可选的又是高级主题，因此稍后将对其进行记录和说明。</p><p>加载实体场景分两步完成。首先，“解决”阶段加载标题，并为每个场景和每个部分创建一个元实体。只有在这之后，才会加载这些部分的内容。</p><p>这些场景和部分元实体用于控制实际的流式传输。默认情况下，调用SceneSystem.LoadSceneAsync 将解析并加载所有内容。</p><div class="note note-info">            <ul><li>应通过调用 SceneSystem 上的方法加载和卸载整个场景。</li><li>通过在表示场景的实体上添加和删除 RequestLoaded组件来加载和卸载场景部分。这些请求由 SceneSectionStreamingSystem处理，它是 SceneSystemGroup 的一部分。</li></ul>          </div><h2 id="串流状态">串流状态</h2><p>流式传输是异步的，因此无法保证在请求数据后加载数据需要多长时间。虽然SceneSystem允许查询场景和部分的加载状态，但在大多数情况下应该不需要这样做。</p><p>理想情况下，系统应该对其所需数据的存在或不存在做出反应，而不是对某些场景是否正在加载做出反应。如果系统需要运行的数据是特定场景的一部分，那么判断是否更新系统应该通过检查是否加载了特定数据来完成，而不是检查场景本身是否已经加载。这种方法避免了将系统绑定到特定场景：如果系统所需的数据被移动到不同的场景、从网络下载或程序生成，系统仍将以相同的方式工作，而无需更改其代码。</p><p>尽管如此，您仍可以检查场景或部分是否已加载。例如，这可能有助于实现一个加载屏幕，该屏幕应保持可见，直到所有计划的流媒体完成。</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">var sceneLoaded &#x3D; SceneSystem.IsSceneLoaded(World.Unmanaged, sceneEntity);var sectionLoaded &#x3D; SceneSystem.IsSectionLoaded(World.Unmanaged, sceneSectionEntity);</code></pre></div></figure><h2 id="场景部分">场景部分</h2><p>场景的各个部分可以独立加载和卸载。</p><p>场景中的每个实体都有一个 SceneSection 共享组件，其中包含场景的 GUID(Hash128) 和部分编号（整数）。第 0 部分是默认部分。</p><p>在转换期间，可以通过更改 SceneSection共享组件的值来设置实体的部分，如下所示：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public class SceneSection123Authoring : MonoBehaviour&#123;    class Baker : Baker&lt;SceneSection123Authoring&gt;    &#123;        &#x2F;&#x2F; TODO: This doesn&#39;t work with Baking, as it relied on ordering        public override void Bake(SceneSection123Authoring authoring)        &#123;            &#x2F;&#x2F; This affects a single entity.            &#x2F;&#x2F; For a recursive approach, see &#96;SceneSectionComponent&#96;.            SetSharedComponent(GetEntity(), new SceneSection&#123;Section &#x3D; 123&#125;);        &#125;    &#125;&#125;</code></pre></div></figure><br />将上述组件添加到子场景引用的创作场景中的游戏对象将导致该子场景的检查器如下所示：</p><p><imgsrc="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/images/scene_section.png" /></p><p>请注意，默认部分 0 始终存在（第一行），即使它是空的。名称的“Section:0”部分被省略，但包含至少一个实体的所有其他部分将以其全名显示。</p><div class="note note-info">            <p>所有部分都可以引用它们自己的实体和第 0部分中的实体。描述此参考系统的工作方式超出了此处的范围，但一个重要的结果是从场景中加载任何部分都需要来自同一场景的第0部分也是加载。相同的约束适用于卸载：只有当当前没有加载同一场景的其他部分时，才能卸载场景的第0 部分。</p>          </div><p>一些现有的 DOTS功能已经利用了部分加载。您可以通过编写自定义转换系统、使用IConvertGameObjectToEntity（参见上面的示例）或使用创作组件SceneSectionComponent（这将影响层次结构中的所有创作游戏对象）来显式控制您自己代码中的部分加载。</p><h2 id="独立加载场景部分">独立加载场景部分</h2><p>使用 DisableAutoLoad 参数调用 LoadSceneAsync将通过创建场景和部分元实体来解析场景，但不会加载部分内容：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">var loadParameters &#x3D; new SceneSystem.LoadParameters &#123;Flags &#x3D; SceneLoadFlags.DisableAutoLoad&#125;;var sceneEntity &#x3D; SceneSystem.LoadSceneAsync(World.Unmanaged, sceneGuid, loadParameters);</code></pre></div></figure><br />一旦处理了加载请求，就会解析这些部分并创建它们的元实体。然后可以在场景元实体上查询ResolvedSectionEntity缓冲区。作为说明，以下代码将加载给定场景的每个其他部分。</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; To keep the sample code short, we assume that the sections have been resolved.&#x2F;&#x2F; And the code that ensures the code runs only once isn&#39;t included either.var sectionBuffer &#x3D; EntityManager.GetBuffer&lt;ResolvedSectionEntity&gt;(sceneEntity);var sectionEntities &#x3D; sectionBuffer.ToNativeArray(Allocator.Temp);for (int i &#x3D; 0; i &lt; sectionEntities.Length; i +&#x3D; 1)&#123;    if (i % 2 &#x3D;&#x3D; 0)    &#123;        &#x2F;&#x2F; Note that the condition includes section 0,        &#x2F;&#x2F; nothing else will load if section 0 is missing.        EntityManager.AddComponent&lt;RequestSceneLoaded&gt;(sectionEntities[i].SectionEntity);    &#125;&#125;sectionEntities.Dispose();</code></pre></div></figure><h2 id="卸载场景和部分">卸载场景和部分</h2><p>卸载整个场景及其所有部分是通过场景系统完成的。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">SceneSystem.UnloadScene(World.Unmanaged, sceneEntity);</code></pre></div></figure><br />也可以使用场景的 GUID 而不是其元实体来调用UnloadScene，但这有两个缺点：</p><ul><li>该函数必须执行（可能代价高昂的）搜索表示与 GUID匹配的场景的元实体。</li><li>如果加载同一场景的多个实例，按GUID卸载只会卸载一个实例。</li></ul>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Entities</tag>
      
      <tag>ECS</tag>
      
      <tag>DOTS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECS 组件</title>
    <link href="/2022/11/17/ECS-components-intro/"/>
    <url>/2022/11/17/ECS-components-intro/</url>
    
    <content type="html"><![CDATA[<h1 id="组件">组件</h1><p>组件代表实体组件系统 (ECS)架构中的数据。实体将组件关联在一起，系统提供可以读取和写入组件数据的逻辑。本节介绍ECS 组件并说明如何使用它们。</p><table><thead><tr class="header"><th>标题</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>组件类型</td><td>了解不同的组件类型以及如何使用它们。</td></tr><tr class="even"><td>向实体添加组件</td><td>使用 csharp 脚本从实体添加组件。</td></tr><tr class="odd"><td>从实体中移除组件</td><td>使用 csharp 脚本从实体中移除组件。</td></tr><tr class="even"><td>读取和写入组件值</td><td>使用 csharp 脚本读取或写入组件值。</td></tr></tbody></table><h1 id="组件类型">组件类型</h1><p>为了服务于各种用例，有多种类型的 ECS 组件。文档的这一部分描述了 ECS组件类型、它们的用例和性能注意事项，以及如何创建它们。</p><table><thead><tr class="header"><th>主题</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>非托管组件</td><td>了解非托管组件以及如何使用它们。</td></tr><tr class="even"><td>托管组件</td><td>了解托管组件以及如何使用它们。</td></tr><tr class="odd"><td>共享组件</td><td>了解共享组件以及如何使用它们。</td></tr><tr class="even"><td>清理组件</td><td>了解清理组件以及如何使用它们。</td></tr><tr class="odd"><td>清理共享组件</td><td>了解清理共享组件以及如何使用它们。</td></tr><tr class="even"><td>标记组件</td><td>了解标记组件以及如何使用它们。</td></tr><tr class="odd"><td>缓冲区组件</td><td>了解缓冲区组件及其使用方法。</td></tr><tr class="even"><td>块组件</td><td>了解块组件以及如何使用它们。</td></tr><tr class="odd"><td>可启用的组件</td><td>了解可启用的组件以及如何使用它们。</td></tr></tbody></table><h2 id="编辑器中的组件类型">编辑器中的组件类型</h2><p>在编辑器中，以下图标代表不同类型的组件。您可以在相关的实体窗口和检查器中看到这些。</p><table><thead><tr class="header"><th>图标</th><th>组件类型</th></tr></thead><tbody><tr class="odd"><td></td><td>托管组件。</td></tr><tr class="even"><td></td><td>共享组件。</td></tr><tr class="odd"><td></td><td>标签组件。</td></tr><tr class="even"><td></td><td>缓冲组件。</td></tr><tr class="odd"><td></td><td>块组件。</td></tr></tbody></table><div class="note note-info">            <p>Unity 为不在上面列表中的组件类型使用通用组件图标。</p>          </div><h3 id="非托管组件">非托管组件</h3><p>非托管组件存储最常见的数据类型，这意味着它们在大多数用例中都很有用。<br />| 主题 | 描述 |<br />| —————— | ———————————————- |<br />| 介绍非托管组件 | 了解非托管组件和它们可以存储的属性类型。 |<br />| 创建一个非托管组件 | 创建一个新的非托管组件以在您的应用程序中使用。|</p><h4 id="引入非托管组件">引入非托管组件</h4><p>非托管组件存储最常见的数据类型，这意味着它们在大多数用例中都很有用。</p><p>非托管组件可以存储以下类型的属性：</p><ul><li>可复制类型</li><li>布尔值</li><li>字符</li><li>BlobAssetReference<T>（对 Blob 数据结构的引用）</li><li>Collections.FixedString（固定大小的字符缓冲区）</li><li>集合.FixedList</li><li>固定数组（仅在不安全的上下文中允许）</li><li>符合这些相同限制的其他结构</li></ul><h3 id="创建非托管组件">创建非托管组件</h3><p>要创建非托管组件，请创建一个继承自 IcomponentData 的结构。</p><p>以下代码示例显示了一个非托管组件：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public struct ExampleUnmanagedComponent : IComponentData&#123;    public int Value;&#125;</code></pre></div></figure><br />将使用兼容类型的属性添加到结构中以定义组件的数据。如果您不向组件添加任何属性，它就充当标记组件。</p><h2 id="托管组件">托管组件</h2><p>托管组件可以存储任何类型的属性，但存储和访问需要更多资源，并且包括对如何使用它们的限制。</p><table><thead><tr class="header"><th>主题</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>托管组件简介</td><td>了解非托管组件、它们可以存储的属性类型以及适用于它们的限制。</td></tr><tr class="even"><td>创建一个托管组件</td><td>创建一个新的托管组件以在您的应用程序中使用。</td></tr><tr class="odd"><td>优化托管组件</td><td>了解解释托管组件最佳使用方式的最佳实践信息。</td></tr></tbody></table><h3 id="引入托管组件">引入托管组件</h3><p>与非托管组件不同，托管组件可以存储任何类型的属性。但是，它们的存储和访问需要更多资源，并且有以下限制：</p><ul><li>您无法在工作中访问它们。</li><li>您不能在 Burst 编译代码中使用它们。</li><li>他们需要垃圾收集。</li><li>它们必须包含一个不带参数的构造函数以用于序列化目的。</li></ul><h4 id="托管类型属性">托管类型属性</h4><p>如果托管组件中的属性使用托管类型，您可能需要手动添加克隆、比较和序列化该属性的能力。</p><h3 id="创建托管组件">创建托管组件</h3><p>要创建托管组件，请创建一个继承自 IComponentData且没有构造函数或包含无参数构造函数的类。</p><p>以下代码示例显示了一个托管组件：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public class ExampleManagedComponent : IComponentData&#123;    public int Value;&#125;</code></pre></div></figure></p><h4 id="管理外部资源的生命周期">管理外部资源的生命周期</h4><p>对于引用外部资源的托管组件，最佳做法是实现 ICloneable 和IDisposable，例如，对于存储对 ParticleSystem 的引用的托管组件。</p><p>如果您复制此托管组件的实体，默认情况下会创建两个引用同一粒子系统的托管组件。如果为托管组件实现ICloneable，则可以为第二个托管组件复制粒子系统。如果销毁托管组件，默认情况下粒子系统会保留。如果为托管组件实现IDisposable，则可以在销毁组件时销毁粒子系统。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public class ManagedComponentWithExternalResource : IComponentData, IDisposable, ICloneable&#123;    public ParticleSystem ParticleSystem;    public void Dispose()    &#123;        UnityEngine.Object.Destroy(ParticleSystem);    &#125;    public object Clone()    &#123;        return new ManagedComponentWithExternalResource &#123; ParticleSystem &#x3D; UnityEngine.Object.Instantiate(ParticleSystem) &#125;;    &#125;&#125;</code></pre></div></figure></p><h3 id="优化托管组件">优化托管组件</h3><p>与非托管组件不同，Unity 不直接将托管组件存储在块中。相反，Unity将它们存储在一个大数组中以供整个世界使用。然后块存储相关托管组件的数组索引。这意味着当您访问实体的托管组件时，Unity会处理额外的索引查找。这使得托管组件不如非托管组件优化。</p><p>托管组件的性能影响意味着您应该尽可能使用非托管组件。</p><h2 id="共享组件">共享组件</h2><p>共享组件根据其共享 cComponent的值将实体分组为块，这有助于数据的重复数据删除。</p><table><thead><tr class="header"><th>主题</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>介绍共享组件</td><td>了解共享组件及其用例。</td></tr><tr class="even"><td>创建一个共享组件</td><td>创建一个新的共享组件以在您的应用程序中使用。</td></tr><tr class="odd"><td>优化共享组件</td><td>了解解释使用共享组件的最佳方式的最佳实践信息。</td></tr></tbody></table><h3 id="引入共享组件">引入共享组件</h3><p>共享组件根据其共享组件的值将实体分组为块，这有助于数据的重复数据删除。为此，Unity将具有相同共享组件值的原型的所有实体存储在一起。这会删除实体之间的重复值。</p><p>共享组件是结构，但根据添加到共享组件的属性类型，您可以创建托管和非托管共享组件。如果共享组件包含托管类型，例如字符串或其他类对象，则共享组件是托管共享组件。否则，它是一个非托管共享组件。托管共享组件与常规托管组件具有相同的优点和限制。</p><h4 id="共享组件值存储">共享组件值存储</h4><p>对于每个世界，Unity 将共享组件值存储在与 ECS块分开的数组中，并且该世界存储句柄中的块可以为其原型找到适当的共享组件值。同一块中的实体共享相同的共享组件值。多个块可以存储相同的共享组件句柄，这意味着可以使用相同共享组件值的实体数量没有限制。</p><p>如果更改实体的共享组件值，Unity会将实体移动到使用新共享组件值的块。这意味着更改实体的共享组件值是一种结构更改。如果共享组件值数组中已经存在相等的值，Unity会将实体移动到存储现有值的索引的块中。否则，Unity将新值添加到共享组件值数组并将实体移动到存储该新值索引的新块。有关如何更改ECS 比较共享组件值的方式的信息，请参阅覆盖默认比较行为。</p><p>Unity 将非托管和托管共享组件彼此分开存储，并通过非托管共享组件API（例如 SetUnmanagedSharedComponentData）使非托管共享组件可用于 Burst编译代码。有关详细信息，请参阅优化共享组件。</p><h4 id="覆盖默认比较行为">覆盖默认比较行为</h4><p>要更改 ECS 比较共享组件实例的方式，请为共享组件实施IEquatable<YourSharedComponent>。如果您这样做，ECS将使用您的实现来检查共享组件的实例是否相等。如果共享组件是非托管的，您可以将[BurstCompile]属性添加到共享组件结构、Equals 方法和GetHashCode 方法中以提高性能。</p><h4 id="在世界之间共享共享组件">在世界之间共享共享组件</h4><p>对于创建和保留资源密集型的托管对象（例如 blob资产），您可以使用共享组件在所有世界中仅存储该对象的一个​​副本。为此，使用Retain 和 Release 实现 IRefCounted 接口。实施 Retain 和Release，以便这些方法正确管理底层资源的生命周期。如果共享组件是非托管的，可以在共享组件结构体、Retain方法和Release方法中添加[BurstCompile]属性来提高性能。</p><h4 id="不要修改共享组件引用的对象">不要修改共享组件引用的对象</h4><p>要正常工作，共享组件依赖于您使用 Entities API来更改它们的值。这包括引用的对象。如果共享组件包含引用类型或指针，请注意不要在不使用Entities API 的情况下修改引用的对象。</p><h3 id="创建共享组件">创建共享组件</h3><p>您可以创建托管和非托管共享组件。</p><h4 id="创建非托管共享组件">创建非托管共享组件</h4><p>要创建非托管共享组件，请创建一个实现标记接口 ISharedComponentData的结构。</p><p>以下代码示例显示了一个非托管共享组件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public struct ExampleUnmanagedSharedComponent : ISharedComponentData&#123;    public int Value;&#125;</code></pre></div></figure><h4 id="创建托管共享组件">创建托管共享组件</h4><p>要创建托管共享组件，请创建一个实现标记接口 ISharedComponentData的类。</p><p>以下代码示例显示了一个托管共享组件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public class ExampleManagedSharedComponent : ISharedComponentData&#123;    public int Value;&#125;</code></pre></div></figure><h3 id="优化共享组件">优化共享组件</h3><p>共享组件对其他组件类型有不同的性能考虑。本页描述共享组件特定的性能注意事项和优化技术。</p><h4 id="使用非托管共享组件">使用非托管共享组件</h4><p>如果可能，在托管共享组件上使用非托管共享组件。这是因为 Unity将非托管共享组件存储在 Burst 编译代码可通过非托管共享组件 API（例如SetUnmanagedSharedComponentData）访问的位置。这提供了优于托管组件的性能优势。</p><h4 id="避免频繁更新">避免频繁更新</h4><p>更新实体的共享组件值是一种结构更改，这意味着 Unity将实体移动到另一个块。出于性能原因，尽量避免经常这样做。</p><h4 id="避免大量独特的共享组件值">避免大量独特的共享组件值</h4><p>块中的所有实体必须共享相同的共享组件值。这意味着如果您为大量实体提供唯一的共享组件值，它会将这些实体分割成许多几乎是空的块。</p><p>例如，如果一个原型有 500个实体具有共享组件，并且每个实体都有一个唯一的共享组件值，Unity会将每个实体存储在一个单独的块中。这浪费了每个块中的大部分空间，也意味着要循环遍历原型的所有实体，Unity必须循环遍历所有 500 个块。这抵消了 ECS块布局的好处并降低了性能。为避免此问题，请尝试使用尽可能少的唯一共享组件值。如果500 个示例实体仅共享十个唯一的共享组件值，Unity可以将它们存储在少至十个块中。</p><p>小心具有多个共享组件类型的原型。原型块中的所有实体必须具有相同的共享组件值组合，因此具有多个共享组件类型的原型容易产生碎片。</p><div class="note note-info">            <p>要检查块碎片，您可以在 Archetypes 窗口中查看块利用率。</p>          </div><h2 id="清理组件">清理组件</h2><p>清理组件就像常规组件，但当您销毁包含一个实体的实体时，Unity会移除所有非清理组件。该实体仍然存在，直到您从中删除所有清理组件。这对于标记销毁时需要清理的实体很有用。</p><table><thead><tr class="header"><th>主题</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>介绍清理组件</td><td>了解清理组件及其用例。</td></tr><tr class="even"><td>创建清理组件</td><td>创建一个新的清理组件以在您的应用程序中使用。</td></tr><tr class="odd"><td>使用清理组件执行清理</td><td>使用清理组件管理销毁时需要清理的实体。</td></tr><tr class="even"><td>清理共享组件</td><td>清理共享组件是托管共享组件，它们具有清理组件的销毁语义。</td></tr></tbody></table><h3 id="引入清理组件">引入清理组件</h3><p>清理组件就像常规组件，但当您销毁包含一个实体的实体时，Unity会移除所有非清理组件。该实体仍然存在，直到您从中删除所有清理组件。这对于标记销毁时需要清理的实体很有用。有关如何执行此操作的信息，请参阅使用清理组件执行清理。</p><h4 id="清理组件生命周期">清理组件生命周期</h4><p>以下代码示例解释了包含清理组件的实体的生命周期：</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; Creates an entity that contains a cleanup component.Entity e &#x3D; EntityManger.CreateEntity(    typeof(Translation), typeof(Rotation), typeof(ExampleCleanup));&#x2F;&#x2F; Attempts to destroy the entity but, because the entity has a cleanup component, Unity doesn&#39;t actually destroy the entity. Instead, Unity just removes the Translation and Rotation components. EntityManager.DestroyEntity(e);&#x2F;&#x2F; The entity still exists so this demonstrates that you can still use the entity normally.EntityManager.AddComponent&lt;Translation&gt;(e);&#x2F;&#x2F; Removes all the components from the entity. This destroys the entity.EntityManager.DestroyEntity(e, new ComponentTypes(typeof(ExampleCleanup), typeof(Translation)));&#x2F;&#x2F; Demonstrates that the entity no longer exists. entityExists is false. bool entityExists &#x3D; EntityManager.Exists(e);</code></pre></div></figure><div class="note note-info">            <p>清除组件是非托管组件，并且具有与非托管组件相同的所有限制。</p>          </div><h3 id="创建清理组件">创建清理组件</h3><p>要创建清理组件，请创建一个继承自 ICleanupComponentData 的结构。</p><p>以下代码示例显示了一个空的清理组件：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public struct ExampleCleanupComponent : ICleanupComponentData&#123;&#125;</code></pre></div></figure></p><div class="note note-info">            <p>空的清理组件通常就足够了，但您可以添加属性来存储清理目标原型所需的信息。</p>          </div><h3 id="使用清理组件进行清理">使用清理组件进行清理</h3><p>清理组件的主要用例是帮助您管理销毁时需要清理的实体。为了实现这一点，它们会阻止您销毁包含清理组件的实体。相反，当您尝试销毁带有附加清理组件的实体时，Unity会移除所有非清理组件。该实体仍然存在，直到您从中删除所有清理组件。</p><p>要对特定原型的实体执行清理：</p><ol type="1"><li>创建一个新的标签组件并将标签组件添加到原型中。</li><li>创建一个新的清理组件，其中包含清理特定实体原型所需的信息。</li><li>创建一个系统：<ol type="1"><li>获取目标原型的新创建实体。这些是包含标签组件但不包含清理组件的实体。</li><li>将清理组件添加到这些实体。</li></ol></li><li>创建一个系统：<ol type="1"><li>获取已被临时销毁并需要清理的实体。这些是包含清理组件但不包含标记组件的实体。</li><li>为实体执行适当的清理工作。</li><li>从实体中删除清理组件。</li></ol></li></ol><h3 id="清理共享组件">清理共享组件</h3><p>清理共享组件是托管共享组件，具有清理组件的销毁语义。它们对于标记需要相同信息进行清理的实体很有用。</p><h4 id="创建清理共享组件">创建清理共享组件</h4><p>要创建清理共享组件，请创建一个继承自 ICleanupSharedComponentData的结构。</p><p>以下代码示例显示了一个空的系统清理组件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public struct ExampleSharedCleanupComponent : ICleanupSharedComponentData&#123;&#125;</code></pre></div></figure><h2 id="标记组件">标记组件</h2><p>标记组件不包含任何属性，并且表现得像非托管组件。因为标记组件不包含任何数据，所以块不会为它们存储任何组件数组。</p><table><thead><tr class="header"><th>主题</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>标签组件简介</td><td>了解标签组件及其用例。</td></tr><tr class="even"><td>创建标签组件</td><td>创建一个新的标签组件以在您的应用程序中使用。</td></tr></tbody></table><h3 id="引入标签组件">引入标签组件</h3><p>标签组件是非托管组件，不存储数据也不占用空间。从概念上讲，标签组件实现与GameObject标签类似的目的，它们在查询中很有用，因为您可以根据实体是否具有标签组件来过滤实体。例如，您可以将它们与清理组件和过滤器实体一起使用以执行清理。</p><h4 id="额外资源">额外资源</h4><ul><li>创建标签组件</li></ul><h3 id="创建标签组件">创建标签组件</h3><p>要创建标记组件，请创建一个没有任何属性的非托管组件。</p><p>以下代码示例显示了一个标记组件：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public struct ExampleTagComponent : IComponentData&#123;&#125;</code></pre></div></figure></p><h2 id="动态缓冲组件">动态缓冲组件</h2><p>动态缓冲区组件是充当可调整大小数组的组件。</p><table><thead><tr class="header"><th>主题</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>介绍动态缓冲区组件</td><td>了解动态缓冲区组件及其用例。</td></tr><tr class="even"><td>创建一个动态缓冲区组件</td><td>创建一个新的动态缓冲区组件以在您的应用程序中使用。</td></tr><tr class="odd"><td>访问块中的所有动态缓冲区使用 BufferAccessor<T></td><td>获取块中特定类型的所有动态缓冲区。</td></tr><tr class="even"><td>为多个实体重用动态缓冲区</td><td>访问主线程上的动态缓冲区并将其数据用于多个实体。</td></tr><tr class="odd"><td>从作业访问动态缓冲区</td><td>创建 BufferLookup 查找以在不在主线程上时访问动态缓冲区。</td></tr><tr class="even"><td>使用 EntityCommandBuffer 修改动态缓冲区</td><td>使用 EntityCommandBuffer 来推迟动态缓冲区修改。</td></tr><tr class="odd"><td>重新解释动态缓冲区</td><td>将动态缓冲区的内容重新解释为另一种类型。</td></tr></tbody></table><h3 id="引入动态缓冲组件">引入动态缓冲组件</h3><p>动态缓冲区组件是充当可调整大小的非托管结构数组的组件。您可以使用它来存储实体的数组数据，例如实体在其间导航的路径点位置。</p><p>除了数据，每个缓冲区还存储一个长度、一个容量和一个内部指针：</p><ul><li>Length 是缓冲区中的元素数。它从 0开始，并在您将值附加到缓冲区时递增。</li><li>容量是缓冲区中的存储量。它开始匹配内部缓冲容量。设置容量调整缓冲区的大小。</li><li>该指针指示动态缓冲区数据所在的位置。最初它是 null表示数据在实体块中，如果 Unity将数据移到块外，指针将设置为指向新数组。有关 Unity如何存储动态缓冲区组件的更多信息，请参阅容量。</li></ul><h4 id="容量">容量</h4><p>动态缓冲区的初始容量由缓冲区存储的类型定义。默认情况下，容量默认为适合128 字节的元素数。有关详细信息，请参阅DefaultBufferCapacityNumerator。您可以使用 InternalBufferCapacity属性指定自定义容量。有关如何创建动态缓冲区组件类型的信息，请参阅创建动态缓冲区组件类型。</p><p>最初，Unity将动态缓冲区数据直接存储在组件所属实体的块中。如果动态缓冲区的长度大于容量，Unity会将动态缓冲区数据复制到块外的数组中。如果动态缓冲区的长度后来收缩到小于容量，Unity仍然将数据存储在块之外；如果 Unity将动态缓冲区数据移出块，它永远不会将数据移回块中。</p><p>原始内部缓冲区容量是块的一部分，Unity 仅在 Unity自己释放块时释放它。这意味着如果动态缓冲区长度超过内部容量并且 Unity将数据复制到块外，则块内会浪费空间。最佳做法是尽可能使用块中的数据。为此，请确保您的大多数实体不超过缓冲区容量，但如果实体不使用它，也不要将容量设置得太高。如果动态缓冲区的大小变化太大，最好将其数据存储在块之外。为此，将InternalBufferCapacity 设置为 0。</p><p>还有其他选项可用于存储数组数据：</p><ul><li>Blob资产：存储紧密打包的只读结构化数据，包括数组，多个实体可以共享一个 blob资产。因为它们是只读的，所以您可以同时从多个线程访问它们。</li><li>托管组件：存储本机或托管对象的数组。但是，与动态缓冲区组件数据相比，访问托管组件数据的限制更多且性能更低。您还需要手动克隆和处理阵列数据。</li><li>共享组件：与托管组件类似，它们存储本机或托管对象的数组，您的实体可以将索引存储到这些更大的数组中。它们具有与托管组件相同的限制和性能注意事项。</li></ul><h4 id="结构变化">结构变化</h4><p>结构更改可能会破坏或移动动态缓冲区引用的数组，这意味着动态缓冲区的任何句柄在结构更改后都会变得无效。您必须在任何结构更改后重新获取动态缓冲区。例如：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public void DynamicBufferExample(Entity e)&#123;    &#x2F;&#x2F; Acquires a dynamic buffer of type MyElement.    DynamicBuffer&lt;MyElement&gt; myBuff &#x3D; EntityManager.GetBuffer&lt;MyElement&gt;(e);    &#x2F;&#x2F; This structural change invalidates the previously acquired DynamicBuffer.    EntityManager.CreateEntity();    &#x2F;&#x2F; A safety check will throw an exception on any read or write actions on the buffer.    var x &#x3D; myBuff[0];    &#x2F;&#x2F; Reacquires the dynamic buffer after the above structural changes.    myBuff &#x3D; EntityManager.GetBuffer&lt;MyElement&gt;(e);    var y &#x3D; myBuff[0];&#125;</code></pre></div></figure></p><h4 id="额外资源-1">额外资源</h4><ul><li>创建动态缓冲组件</li></ul><h3 id="创建动态缓冲组件">创建动态缓冲组件</h3><p>创建动态缓冲组件<br />要创建动态缓冲区组件，请创建一个继承自 IBufferElementData的结构。这个结构定义了动态缓冲区类型的元素，也代表了动态缓冲区组件本身。</p><p>要指定缓冲区的初始容量，请使用 InternalBufferCapacity 属性。有关Unity 如何管理缓冲区容量的信息，请参阅容量。</p><p>以下代码示例显示了一个缓冲区组件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">[InternalBufferCapacity(16)]public struct ExampleBufferComponent : IBufferElementData&#123;    public int Value;&#125;&#96;&#96;&#96;与其他组件一样，您可以向实体添加动态缓冲区组件。但是，您使用 DynamicBuffer&lt;ExampleBufferComponent&gt; 表示动态缓冲区组件，并使用特定于动态缓冲区组件的 EntityManager API（例如 EntityManager.GetBuffer&lt;T&gt;）与它们进行交互。例如：&#96;&#96;&#96;cspublic void GetDynamicBufferComponentExample(Entity e)&#123;    DynamicBuffer&lt;MyElement&gt; myDynamicBuffer &#x3D; EntityManager.GetBuffer&lt;MyElement&gt;(e);&#125;</code></pre></div></figure><h3 id="访问块中的动态缓冲区">访问块中的动态缓冲区</h3><p>要访问块中的所有动态缓冲区，请使用 ArchetypeChunk.GetBufferAccessor方法。这需要一个 BufferTypeHandle<T> 并返回一个BufferAccessor<T>。如果您索引 BufferAccessor<T>，它会返回块的类型为 T的缓冲区：</p><p>以下代码示例显示了如何访问块中某种类型的每个动态缓冲区。</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">[InternalBufferCapacity(16)]public struct ExampleBufferComponent : IBufferElementData&#123;    public int Value;&#125;</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public partial class ExampleSystem : SystemBase&#123;    protected override void OnUpdate()    &#123;        var query &#x3D; EntityManager.CreateEntityQuery(typeof(ExampleBufferComponent));        NativeArray&lt;ArchetypeChunk&gt; chunks &#x3D; query.ToArchetypeChunkArray(Allocator.Temp);        for (int i &#x3D; 0; i &lt; chunks.Length; i++)        &#123;            UpdateChunk(chunks[i]);        &#125;        chunks.Dispose();    &#125;    private void UpdateChunk(ArchetypeChunk chunk)    &#123;        &#x2F;&#x2F; Get a BufferTypeHandle representing dynamic buffer type ExampleBufferComponent from SystemBase.        BufferTypeHandle&lt;ExampleBufferComponent&gt; myElementHandle &#x3D; GetBufferTypeHandle&lt;ExampleBufferComponent&gt;();        &#x2F;&#x2F; Get a BufferAccessor from the chunk.        BufferAccessor&lt;ExampleBufferComponent&gt; buffers &#x3D; chunk.GetBufferAccessor(myElementHandle);        &#x2F;&#x2F; Iterate through all ExampleBufferComponent buffers of each entity in the chunk.        for (int i &#x3D; 0, chunkEntityCount &#x3D; chunk.Count; i &lt; chunkEntityCount; i++)        &#123;            DynamicBuffer&lt;ExampleBufferComponent&gt; buffer &#x3D; buffers[i];            &#x2F;&#x2F; Iterate through all elements of the buffer.            for (int j &#x3D; 0; j &lt; buffer.Length; j++)            &#123;                &#x2F;&#x2F; ...            &#125;        &#125;    &#125;&#125;</code></pre></div></figure><h3 id="为多个实体重用动态缓冲区">为多个实体重用动态缓冲区</h3><p>如果 Entities.ForEach 的所有实体都需要相同的缓冲区，您可以在Entities.ForEach 之上的主线程上将该缓冲区作为局部变量获取。</p><p>以下代码示例显示了如何为多个实体使用相同的动态缓冲区。它假设存在一个名为MyElement 的动态缓冲区，并且存在另一个名为 OtherComponent 的组件。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public void DynamicBufferExample(Entity e)&#123;    var myBuff &#x3D; EntityManager.GetBuffer&lt;MyElement&gt;(e);    Entities.ForEach((in OtherComponent component) &#x3D;&gt; &#123;        &#x2F;&#x2F; ... use myBuff    &#125;).Schedule();&#125;</code></pre></div></figure></p><div class="note note-info">            <p>如果您使用ScheduleParallel，请注意您不能并行写入动态缓冲区。但是，您可以使用EntityCommandBuffer.ParallelWriter 并行记录更改。</p>          </div><h3 id="从作业访问动态缓冲区">从作业访问动态缓冲区</h3><p>如果一项作业需要在其代码中查找一个或多个缓冲区，则该作业需要使用BufferLookup查找表。您在系统中创建这些，然后将它们传递给需要它们的作业。</p><h4 id="修改作业">修改作业</h4><p>在需要随机访问动态缓冲区的作业中：</p><ol type="1"><li>添加一个 ReadOnly BufferLookup 成员变量。</li><li>在 IJobEntity.Execute 方法中，按实体对 BufferLookup查找表进行索引。这提供了对附加到实体的动态缓冲区的访问。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public partial struct AccessDynamicBufferJob : IJobEntity&#123;    [ReadOnly] public BufferLookup&lt;ExampleBufferComponent&gt; BufferLookup;    public void Execute()      &#123;              &#x2F;&#x2F; ...      &#125;&#125;</code></pre></div></figure></li></ol><h4 id="修改系统">修改系统</h4><p>在创建作业实例的系统中：</p><ol type="1"><li>添加一个 BufferLookup 成员变量。</li><li>在 OnCreate 中，使用 SystemState.GetBufferLookup 分配 BufferLookup变量。</li><li>在 OnUpdate 开始时，对 BufferLookup 变量调用Update。这会更新查找表。</li><li>创建作业实例时，将查找表传递给作业。</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public partial struct AccessDynamicBufferFromJobSystem : ISystem&#123;    private BufferLookup&lt;ExampleBufferComponent&gt; _bufferLookup;    public void OnCreate(ref SystemState state)    &#123;        _bufferLookup &#x3D; state.GetBufferLookup&lt;ExampleBufferComponent&gt;(true);    &#125;    public void OnUpdate(ref SystemState state)    &#123;        _bufferLookup.Update(ref state);        var exampleBufferAccessJob &#x3D; new AccessDynamicBufferJob &#123; BufferLookup &#x3D; _bufferLookup &#125;;        exampleBufferAccessJob.ScheduleParallel();    &#125;    public void OnDestroy(ref SystemState state) &#123; &#125;&#125;</code></pre></div></figure><h3 id="使用-entitycommandbuffer-修改动态缓冲区">使用EntityCommandBuffer 修改动态缓冲区</h3><p>EntityCommandBuffer记录为实体添加、删除或设置缓冲区组件的命令。存在不同于常规组件 API的特定于动态缓冲区的 API。</p><p>以下代码示例介绍了一些通用的特定于动态缓冲区的 EntityCommandBufferAPI。它假设存在一个名为 MyElement 的动态缓冲区。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">private void Example(Entity e, Entity otherEntity)&#123;    EntityCommandBuffer ecb &#x3D; new EntityCommandBuffer(Allocator.TempJob);    &#x2F;&#x2F; Record a command to remove the MyElement dynamic buffer from an entity.    ecb.RemoveComponent&lt;MyElement&gt;(e);    &#x2F;&#x2F; Record a command to add a MyElement dynamic buffer to an existing entity.    &#x2F;&#x2F; The data of the returned DynamicBuffer is stored in the EntityCommandBuffer,     &#x2F;&#x2F; so changes to the returned buffer are also recorded changes.     DynamicBuffer&lt;MyElement&gt; myBuff &#x3D; ecb.AddBuffer&lt;MyElement&gt;(e);    &#x2F;&#x2F; After playback, the entity will have a MyElement buffer with     &#x2F;&#x2F; Length 20 and these recorded values.    myBuff.Length &#x3D; 20;    myBuff[0] &#x3D; new MyElement &#123; Value &#x3D; 5 &#125;;    myBuff[3] &#x3D; new MyElement &#123; Value &#x3D; -9 &#125;;    &#x2F;&#x2F; SetBuffer is like AddBuffer, but safety checks will throw an exception at playback if     &#x2F;&#x2F; the entity doesn&#39;t already have a MyElement buffer.     DynamicBuffer&lt;MyElement&gt; otherBuf &#x3D; ecb.SetBuffer&lt;MyElement&gt;(otherEntity);    &#x2F;&#x2F; Records a MyElement value to append to the buffer. Throws an exception at     &#x2F;&#x2F; playback if the entity doesn&#39;t already have a MyElement buffer.    ecb.AppendToBuffer&lt;MyElement&gt;(otherEntity, new MyElement &#123; Value &#x3D; 12 &#125;);&#125;</code></pre></div></figure><br />当您设置 DynamicBuffer 的 Length、Capacity 和内容时，ECS会将这些更改记录到 EntityCommandBuffer 中。当您回放 EntityCommandBuffer时，ECS 会对动态缓冲区进行更改。</p><h3 id="重新解释动态缓冲区">重新解释动态缓冲区</h3><p>您可以重新解释 <code>DynamicBuffer&lt;T&gt;</code> 以获得另一个<code>DynamicBuffer&lt;U&gt;</code>，其中 T 和 U具有相同的大小。如果您想将组件的动态缓冲区重新解释为组件所附加的实体的动态缓冲区，这将很有用。这种重新解释为相同的内存设置了别名，因此更改一个索引i 处的值会更改另一个索引 i 处的值。</p><div class="note note-info">            <p>Reinterpret 方法仅强制原始类型和新类型具有相同的大小。例如，您可以将uint 重新解释为 float，因为这两种类型都是 32位的。您有责任决定重新解释是否对您的目的有意义。</p>          </div><p>以下代码示例显示了如何解释动态缓冲区。它假设存在一个名为 MyElement的动态缓冲区，并包含一个名为 Value 的 int 字段。</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public class ExampleSystem : SystemBase&#123;    private void ReinterpretEntitysChunk(Entity e)    &#123;        DynamicBuffer&lt;MyElement&gt; myBuff &#x3D; EntityManager.GetBuffer&lt;MyElement&gt;(e);        &#x2F;&#x2F; Valid as long as each MyElement struct is four bytes.         DynamicBuffer&lt;int&gt; intBuffer &#x3D; myBuff.Reinterpret&lt;int&gt;();        intBuffer[2] &#x3D; 6;  &#x2F;&#x2F; same effect as: myBuff[2] &#x3D; new MyElement &#123; Value &#x3D; 6 &#125;;        &#x2F;&#x2F; The MyElement value has the same four bytes as int value 6.         MyElement myElement &#x3D; myBuff[2];        Debug.Log(myElement.Value);    &#x2F;&#x2F; 6    &#125;&#125;</code></pre></div></figure><div class="note note-info">            <p>重新解释的缓冲区共享原始缓冲区的安全句柄，因此受到所有相同的安全限制。</p>          </div><h2 id="块组件">块组件</h2><p>块组件是一种组件，它按块而不是按实体存储值。它们提供与共享组件类似的功能，但在一些基本方面有所不同。</p><table><thead><tr class="header"><th>主题</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>介绍块组件</td><td>了解块组件及其用例。</td></tr><tr class="even"><td>创建块组件</td><td>创建一个新的块组件以在您的应用程序中使用。</td></tr><tr class="odd"><td>使用块组件</td><td>了解如何使用特定于块组件的 API。</td></tr></tbody></table><h3 id="引入块组件">引入块组件</h3><p>块组件存储每个块而不是每个实体的值。它们的主要目的是作为一种优化，因为您可以在每个块级别上运行代码以检查是否为每个块中的所有实体处理某些行为。例如，块组件可以存储其中所有实体的边界。您可以检查边界是否在屏幕上，如果是，则只处理该块中的实体。</p><p>块组件提供与共享组件类似的功能，但在以下方面有所不同：</p><ul><li>块组件值在概念上属于块本身，而不是块的各个实体。</li><li>设置块组件值不是结构更改。</li><li>与共享组件不同，Unity不会重复删除唯一的块组件值：具有相同块组件值的块存储它们自己的单独副本。</li><li>块组件始终是非托管的：您无法创建托管块组件。</li><li>当实体的原型更改或实体的共享组件值更改时，Unity会将实体移动到新块，但这些移动不会修改源块或目标块的块组件值。</li></ul><h3 id="创建块组件">创建块组件</h3><p>块组件的定义与非托管组件相同。这意味着您创建一个继承自 IComponentData的常规结构来创建块组件。块组件和非托管组件之间的区别在于将它们添加到实体的方式。</p><p>以下代码示例显示了一个非托管组件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public struct ExampleChunkComponent : IComponentData&#123;    public int Value;&#125;</code></pre></div></figure><p>要将非托管组件用作块组件，请使用EntityManager.AddChunkComponentData<YourChunkComponent>(Entity)将其添加到实体中。</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">private void ChunkComponentExample(Entity e)&#123;    &#x2F;&#x2F; Adds ExampleChunkComp to the passed in entity&#39;s chunk.    EntityManager.AddChunkComponent&lt;ExampleChunkComp&gt;(e);    &#x2F;&#x2F; Finds all chunks with an ExampleComponent and an ExampleChunkComponent.    &#x2F;&#x2F; To distinguish chunk components from a regular IComponentData, You must    &#x2F;&#x2F; specify the chunk component with ComponentType.ChunkComponent.    EntityQuery query &#x3D; GetEntityQuery(typeof(ExampleComponent), ComponentType.ChunkComponent&lt;ExampleChunkComp&gt;());    NativeArray&lt;ArchetypeChunk&gt; chunks &#x3D; query.ToArchetypeChunkArray(Allocator.Temp);    &#x2F;&#x2F; Sets the ExampleChunkComp value of the first chunk.    EntityManager.SetChunkComponentData&lt;ExampleChunkComp&gt;(chunks[0], new ExampleChunkComp &#123; Value &#x3D; 6 &#125;);    &#x2F;&#x2F; Gets the ExampleChunkComp value of the first chunk.    ExampleChunkComp exampleChunkComp &#x3D; EntityManager.GetChunkComponentData&lt;ExampleChunkComp&gt;(chunks[0]);    Debug.Log(exampleChunkComp.Value)    &#x2F;&#x2F; 6&#125;</code></pre></div></figure><div class="note note-info">            <p>如果您只想从块组件读取而不写入，请在定义查询时使用ComponentType.ChunkComponentReadOnly。将查询中包含的组件标记为只读有助于避免不必要的作业调度约束。</p>          </div><p>虽然块组件属于块本身，但在实体上添加或删除块组件会改变其原型并导致结构变化。</p><div class="note note-info">            <p>Unity 将新创建的块组件值初始化为这些类型的默认值。</p>          </div><p>您还可以通过任何块的实体获取和设置块的块组件：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">private void ChunkComponentExample(Entity e)&#123;    &#x2F;&#x2F; Sets the ExampleChunkComp value of the entity&#39;s chunk.    EntityManager.SetChunkComponentData&lt;MyChunkComp&gt;(e, new MyChunkComp &#123; Value &#x3D; 6 &#125;);    &#x2F;&#x2F; Sets the ExampleChunkComp value of the entity&#39;s chunk.    MyChunkComp myChunkComp &#x3D; EntityManager.GetChunkComponentData&lt;MyChunkComp&gt;(e);    Debug.Log(myChunkComp.Value)    &#x2F;&#x2F; 6&#125;</code></pre></div></figure></p><h4 id="在作业中使用块组件">在作业中使用块组件</h4><p>作业不能使用 EntityManager，因此要访问块组件，您需要使用其ComponentTypeHandle。</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">struct MyJob : IJobChunk&#123;    public ComponentTypeHandle&lt;ExampleChunkComponent&gt; ExampleChunkCompHandle;    public void Execute(ArchetypeChunk chunk, int chunkIndex, int firstEntityIndex)    &#123;        &#x2F;&#x2F; Get the chunk&#39;s MyChunkComp.        ExampleChunkComponent myChunkComp &#x3D; chunk.GetChunkComponentData(ExampleChunkCompHandle);        &#x2F;&#x2F; Set the chunk&#39;s MyChunkComp.         chunk.SetChunkComponentData(ExampleChunkCompHandle, new ExampleChunkComponent &#123; Value &#x3D; 7 &#125;);    &#125;&#125;</code></pre></div></figure><h2 id="启用组件">启用组件</h2><p>使用可启用的组件在运行时禁用或启用实体上的各个组件。这在处理您希望频繁且不可预测地更改的状态时非常有用，因为与添加或删除组件相比，它们产生的结构更改更少。</p><table><thead><tr class="header"><th>主题</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>可启用组件概述</td><td>可启用组件的概述，您可以在运行时禁用或启用这些组件。</td></tr><tr class="even"><td>使用可用组件</td><td>有关使用可用组件的信息。</td></tr></tbody></table><h3 id="启用组件概述">启用组件概述</h3><p>您可以在 IComponentData 和 IBufferElementData组件上使用可启用组件，以在运行时禁用或启用实体上的各个组件。要使组件可用，请从IEnableableComponent 继承它们。</p><p>可启用组件非常适合您期望频繁且不可预测地更改的状态，或者状态排列数量在逐帧基础上很高的情况。添加和删​​除组件是管理低频状态更改组件的首选方法，您希望状态在许多帧中持续存在。</p><h4 id="结构变化-1">结构变化</h4><p>与添加和删除组件不同，可启用组件不会创建结构更改。在确定实体是否与实体查询匹配时，ECS将禁用的组件视为实体没有该组件。这意味着具有禁用组件的实体不匹配需要该组件的查询，并且匹配排除该组件的查询，假设它满足所有其他查询条件。</p><h4 id="标记组件替代">标记组件替代</h4><p>您还可以使用可启用组件而不是一组零大小标记组件来表示实体状态。这减少了唯一实体原型的数量，并鼓励更好地利用块以减少内存消耗。</p><h4 id="启用的组件语义">启用的组件语义</h4><p>现有组件操作的语义不会改变。 EntityManager认为具有禁用组件的实体仍然具有该组件。</p><p>具体来说，如果组件 T 在实体 E 上被禁用：</p><ul><li>HasComponent<T>(E) 返回真。</li><li>GetComponent<T>(E) 返回组件的当前值。</li><li>SetComponent<T>(E,value) 更新组件的值。</li><li>RemoveComponent<T>(E) 从 E 中移除组件。</li><li>AddComponent<T>(E) 静静地什么也不做，因为组件已经存在。</li></ul><h3 id="使用可启用的组件">使用可启用的组件</h3><p>您只能启用 IComponentData 和 IBufferElementData 组件。为此，实现IEnableableComponent 接口。</p><p>当您使用可启用的组件时，目标实体不会更改其原型，ECS不会移动任何数据，并且组件的现有值保持不变。这意味着您可以在工作线程上运行的作业上启用和禁用组件，而无需使用实体命令缓冲区或创建同步点。</p><p>但是，为防止出现竞争情况，对可启用组件具有写入权限的作业可能会导致主线程操作阻塞，直到作业完成，即使该作业未在任何实体上启用或禁用该组件。</p><p>在使用 CreateEntity()创建的新实体上默认启用所有可启用的组件。从预制件实例化的实体继承预制件的启用或禁用状态。</p><h4 id="启用组件方法">启用组件方法</h4><p>要使用可启用的组件，您可以在EntityManager、ComponentLookup<T>、EntityCommandBuffer 和 ArchetypeChunk上使用以下方法：</p><ul><li>IsComponentEnabled<T>(Entity e)：如果实体 e 具有组件 T并且它已启用，则返回 true。如果实体 e 有组件 T，但它被禁用，则返回false。断言实体 e 是否没有组件 T，或者 T 是否未实现IEnableableComponent。</li><li>SetComponentEnabled<T>(Entity e, bool enable)：如果实体 e 有组件T，则根据 enable 的值启用或禁用它。断言实体 e 是否没有组件 T，或者 T是否未实现 IEnableableComponent。<br />例如：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; ... in a SystemBase OnUpdate()Entity e &#x3D; this.EntityManager.CreateEntity(typeof(Health));ComponentLookup&lt;Health&gt; healthLookup &#x3D; this.GetComponentLookup&lt;&gt;();&#x2F;&#x2F; truebool b &#x3D; healthLookup.IsComponentEnabled(e);&#x2F;&#x2F; disable the Health component of the entityhealthLookup.SetComponentEnabled(e, false);&#x2F;&#x2F; though disabled, the component can still be read and modifiedHealth h &#x3D; healthLookup(e);</code></pre></div></figure><br />您可以使用 ComponentLookup<T>.SetComponentEnabled(Entity,bool)从工作线程安全地启用或禁用实体，因为不需要进行结构更改。该作业必须具有对组件T的写访问权。您应该避免启用或禁用另一个线程可能在运行中处理的实体上的组件，因为这通常会导致竞争条件。</li></ul><h4 id="查询启用组件">查询启用组件</h4><p>禁用组件 T 的实体匹配查询，就好像它根本没有组件 T一样。例如，如果实体 E 具有组件 T1（启用）、T2（禁用）和T3（禁用）：</p><ul><li>它与同时需要 T1 和 T2 的查询不匹配</li><li>它匹配需要 T1 并排除 T2 的查询</li><li>它不匹配将 T2 和 T3作为可选组件的查询，因为它没有启用这些组件中的至少一个。</li></ul><p>所有 EntityQuery方法都会自动处理可启用的组件。例如，query.CalculateEntityCount()计算与查询匹配的实体数，同时考虑启用和禁用它们的哪些组件。有两个例外：</p><ul><li>以 IgnoreFilter结尾的方法名称将所有组件视为已启用。这些方法不需要同步点，因为只有结构变化会影响它们的结果。它们往往比尊重过滤的变体更有效。</li><li>使用 EntityQueryOptions.IgnoreComponentEnabledState创建的查询在确定它们是否与查询匹配时忽略匹配原型中所有实体的当前启用/禁用状态。</li></ul><p>以下是查询已使用 EntityManager.IsComponentEnabled禁用的组件的示例：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public struct Health : IComponentData, IEnableableComponent&#123;    public float Value;&#125;&#x2F;&#x2F; ... in a SystemBase OnUpdate()Entity e1 &#x3D; this.EntityManager.CreateEntity(typeof(Health), typeof(Translation));Entity e2 &#x3D; this.EntityManager.CreateEntity(typeof(Health), typeof(Translation));&#x2F;&#x2F; true (components begin life enabled)bool b &#x3D; this.EntityManager.IsComponentEnabled&lt;Health&gt;(e1);&#x2F;&#x2F; disable the Health component on the first entitythis.EntityManager.SetComponentEnabled&lt;Health&gt;(e1, false);EntityQuery query &#x3D; new EntityQueryBuilder(Allocator.Temp).WithAll&lt;Health, Translation&gt;().Build(this);&#x2F;&#x2F; the returned array does not include the first entityvar entities &#x3D; query.ToEntityArray(Allocator.Temp);&#x2F;&#x2F; the returned array does not include the Health of the first entityvar healths &#x3D; query.ToComponentDataArray&lt;Health&gt;(Allocator.Temp);&#x2F;&#x2F; the returned array does not include the Translation of the first entityvar translations &#x3D; query.ToComponentDataArray&lt;Translation&gt;(Allocator.Temp);&#x2F;&#x2F; This query matches components whether they&#39;re enabled or disabledvar queryIgnoredEnableable &#x3D; new EntityQueryBuilder(Allocator.Temp).WithAll&lt;Health, Translation&gt;().WithOptions(EntityQueryOptions.IgnoreComponentEnabledState).Build(this);&#x2F;&#x2F; the returned array includes the Translations of both entitiesvar translationsAll &#x3D; queryIgnoreEnableable.ToComponentDataArray&lt;Translation&gt;(Allocator.Temp);</code></pre></div></figure></p><h4 id="异步操作">异步操作</h4><p>为了安全且确定地处理可启用组件，所有同步 EntityQuery操作（忽略过滤的操作除外）会自动等待任何正在运行的作业完成，这些作业对查询的可启用组件具有写访问权限。所有异步EntityQuery 操作（以 Async结尾的操作）也会自动插入对这些正在运行的作业的输入依赖项。</p><p>异步 EntityQuery 收集和分散操作，例如EntityQuery.ToEntityArrayAsync()安排一个作业来执行请求的操作。这些方法必须返回 NativeList 而不是NativeArray，因为查询匹配的实体数量在作业运行之前是未知的，但容器必须立即返回给调用者。</p><p>此列表的初始容量根据可以匹配查询的最大实体数进行了保守调整，但其最终长度可能会更短。在异步收集或分散作业完成之前，对列表的任何读取或写入（包括其当前长度、容量或基指针）都会导致JobsDebugger安全错误。但是，您可以安全地将列表传递给依赖的后续作业。</p><h1 id="向实体添加组件">向实体添加组件</h1><p>要将组件添加到实体，请使用实体所在世界的EntityManager。您可以将组件添加到单个实体，或同时添加到多个实体。</p><p>将组件添加到实体是一种结构更改，这意味着实体移动到不同的块。这意味着您不能直接从作业中将组件添加到实体。相反，您必须使用EntityCommandBuffer 来记录您稍后添加组件的意图。</p><h2 id="将组件添加到单个实体">将组件添加到单个实体</h2><p>以下代码示例创建一个新实体，然后从主线程向该实体添加一个组件。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public partial struct AddComponentToSingleEntitySystemExample : ISystem&#123;    public void OnCreate(ref SystemState state)    &#123;        var entity &#x3D; state.EntityManager.CreateEntity();        state.EntityManager.AddComponent&lt;Rotation&gt;(entity);    &#125;    public void OnUpdate(ref SystemState state) &#123; &#125;    public void OnDestroy(ref SystemState state) &#123; &#125;&#125;</code></pre></div></figure></p><h2 id="将组件添加到多个实体">将组件添加到多个实体</h2><p>以下代码示例获取带有附加 ComponentA组件的每个实体，并从主线程向它们添加 ComponentB 组件。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">struct ComponentA : IComponentData &#123;&#125;struct ComponentB : IComponentData &#123;&#125;public partial struct AddComponentToMultipleEntitiesSystemExample : ISystem&#123;    public void OnCreate(ref SystemState state)    &#123;        var query &#x3D; state.GetEntityQuery(typeof(ComponentA));        state.EntityManager.AddComponent&lt;ComponentB&gt;(query);    &#125;    public void OnUpdate(ref SystemState state) &#123; &#125;    public void OnDestroy(ref SystemState state) &#123; &#125;&#125;</code></pre></div></figure></p><h1 id="从实体中移除组件">从实体中移除组件</h1><p>要从实体中移除组件，请使用实体所在世界的 EntityManager。</p><div class="note note-warning">            <p>将组件添加到实体是一种结构更改，这意味着实体移动到不同的原型块。</p>          </div><h2 id="从主线程">从主线程</h2><p>您可以直接从主线程中的实体中删除组件。以下代码示例获取每个带有附加Rotation 组件的实体，然后删除 Rotation 组件。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public partial struct RemoveComponentSystemExample : ISystem&#123;    public void OnCreate(ref SystemState state)    &#123;        var query &#x3D; state.GetEntityQuery(typeof(Rotation));        state.EntityManager.RemoveComponent&lt;Rotation&gt;(query);    &#125;    public void OnUpdate(ref SystemState state) &#123; &#125;    public void OnDestroy(ref SystemState state) &#123; &#125;&#125;</code></pre></div></figure></p><h2 id="从一份工作">从一份工作</h2><p>因为从实体中删除组件是一种结构更改，所以您不能直接在作业中执行此操作。相反，您必须使用EntityCommandBuffer 来记录您稍后删除组件的意图。</p><h1 id="读取和写入组件值">读取和写入组件值</h1><p>将组件添加到实体后，您的系统可以访问、读取和写入组件值。根据您的用例，您可以使用多种方法来实现此目的。</p><h2 id="访问单个组件">访问单个组件</h2><p>有时您可能希望一次读取或写入一个实体的单个组件。为此，在主线程上，您可以让EntityManager 读取或写入单个实体的组件值。 EntityManager保留一个查找表以快速找到每个实体的块和块内的索引。</p><h2 id="访问多个组件">访问多个组件</h2><p>对于大多数工作，您需要读取或写入一个块或一组块中所有实体的组件：</p><ul><li>ArchetypeChunk 直接读取和写入块的组件数组。</li><li>EntityQuery 有效地检索与查询匹配的组块集。</li><li>IJobEntity 使用作业在查询中遍历组件。</li></ul><h2 id="延迟组件值更改">延迟组件值更改</h2><p>要推迟组件值的更改以备后用，请使用 EntityCommandBuffer来记录您写入（而非读取）组件值的意图。这些更改只会在您稍后在主线程上播放EntityCommandBuffer 时发生。</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Entities</tag>
      
      <tag>ECS</tag>
      
      <tag>DOTS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECS 系统</title>
    <link href="/2022/11/17/ECS-systems-intro/"/>
    <url>/2022/11/17/ECS-systems-intro/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#系统">系统</a></li><li><a href="#使用-SystemBase-创建系统">使用 <code>SystemBase</code>创建系统</a><ul><li><a href="#回调方法顺序">回调方法顺序</a></li></ul></li><li><a href="#迭代数据">迭代数据</a><ul><li><a href="#额外资源">额外资源</a></li><li><a href="#使用-Entities-ForEach-迭代数据">使用<code>Entities.ForEach</code> 迭代数据</a></li><li><a href="#使用-IJobEntity-迭代数据">使用 <code>IJobEntity</code>迭代数据</a></li><li><a href="#使用-IJobEntityBatch-遍历成批数据">使用<code>IJobEntityBatch</code> 遍历成批数据</a></li><li><a href="#手动迭代数据">手动迭代数据</a></li></ul></li><li><a href="#系统更新顺序">系统更新顺序</a><ul><li><a href="#组件系统组">组件系统组</a></li><li><a href="#系统排序属性">系统排序属性</a></li><li><a href="#默认系统组">默认系统组</a></li><li><a href="#多个世界">多个世界</a></li></ul></li><li><ahref="#使用作业在多个线程上调度数据">使用作业在多个线程上调度数据</a><ul><li><a href="#工作扩展">工作扩展</a></li><li><a href="#通用职位">通用职位</a></li><li><a href="#使用-Job-WithCode-安排后台作业">使用 Job.WithCode安排后台作业</a></li><li><a href="#作业依赖">作业依赖</a></li></ul></li><li><a href="#使用-EntityQuery-查询数据">使用 EntityQuery 查询数据</a><ul><li><a href="#创建实体查询">创建实体查询</a></li><li><a href="#定义过滤器">定义过滤器</a></li><li><a href="#按启用组件过滤">按启用组件过滤</a></li><li><a href="#合并查询">合并查询</a></li><li><a href="#执行查询">执行查询</a></li><li><a href="#编辑器中的查询">编辑器中的查询</a></li></ul></li><li><a href="#使用-EntityCommandBuffer-安排数据更改">使用EntityCommandBuffer 安排数据更改</a><ul><li><a href="#EntityCommandBuffer-方法">EntityCommandBuffer方法</a></li><li><a href="#在单线程作业中使用-EntityCommandBuffer">在单线程作业中使用EntityCommandBuffer</a></li><li><a href="#在并行作业中使用-EntityCommandBuffer">在并行作业中使用EntityCommandBuffer</a></li><li><a href="#重用-EntityCommandBuffer-实例">重用 EntityCommandBuffer实例</a></li><li><a href="#多重回放">多重回放</a></li><li><a href="#在主线程上使用-EntityCommandBuffer">在主线程上使用EntityCommandBuffer</a></li><li><ahref="#使用-EntityCommandBufferSystem-自动播放和处理命令缓冲区">使用EntityCommandBufferSystem 自动播放和处理命令缓冲区</a></li><li><a href="#延迟实体">延迟实体</a></li><li><a href="#在-Entities-ForEach-方法中使用命令缓冲区">在<code>Entities.ForEach</code> 方法中使用命令缓冲区</a></li></ul></li><li><a href="#查找任意数据">查找任意数据</a><ul><li><a href="#在系统中查找实体数据">在系统中查找实体数据</a></li><li><a href="#在作业中查找实体数据">在作业中查找实体数据</a></li><li><a href="#数据访问错误">数据访问错误</a></li></ul></li><li><a href="#写入组">写入组</a><ul><li><a href="#使用写组">使用写组</a></li><li><a href="#编写组示例">编写组示例</a></li><li><a href="#创建写入组">创建写入组</a></li><li><a href="#启用写组过滤">启用写组过滤</a></li><li><ahref="#覆盖另一个使用写入组的系统">覆盖另一个使用写入组的系统</a></li><li><ahref="#扩展另一个使用写组的系统">扩展另一个使用写组的系统</a></li></ul></li><li><a href="#版本号">版本号</a><ul><li><a href="#版本号结构">版本号结构</a></li><li><a href="#实体版本号">实体版本号</a></li><li><a href="#世界版本号">世界版本号</a></li><li><a href="#作业组件系统版本号">作业组件系统版本号</a></li><li><a href="#非共享组件版本号">非共享组件版本号</a></li><li><a href="#共享组件版本号">共享组件版本号</a></li></ul></li></ul><h1 id="系统">系统</h1><p>系统是每帧在主线程上运行一次的代码单元。系统被组织成系统组的层次结构，您可以使用这些系统组来组织系统更新的顺序。有关ECS 中系统基础知识的更多信息，请参阅系统概念。<br /><span id="more"></span><br />| 标题 | 描述 |<br />| ————————————- | —————————————————— |<br />| 使用<code>SystemBase</code>创建系统 |有关如何使用<code>SystemBase</code>创建系统的信息。 |<br />| 迭代数据 | 描述了可以迭代系统中数据的各种方法。 |<br />| 系统更新顺序 | 有关系统更新顺序以及如何使用系统组控制更新顺序的信息。|<br />| 使用作业在多个线程上调度数据 | 有关如何在系统中使用作业的信息。|<br />| 使用<code>EntityQuery</code>查询实体数据 |有关使用<code>EntityQuery</code>查询实体数据的信息。 |<br />| 使用<code>EntityCommandBuffer</code>调度数据更改 |使用命令缓冲区来延迟对数据的更改。 |<br />| 查找任意数据 | 有关如何查找任意实体数据的信息。 |<br />| 写入组 | 使用写入组覆盖系统的数据。 |<br />| 版本号 | 使用版本号来检测潜在的变化。 |</p><h1 id="使用-systembase-创建系统">使用 <code>SystemBase</code>创建系统</h1><p>要创建托管系统，请实现抽象类 <code>SystemBase</code>。</p><p>您必须使用 <code>OnUpdate</code>系统事件回调，来添加您的系统必须在每一帧执行的工作。<code>ComponentSystemBase</code>命名空间中的所有其他回调方法都是可选的。</p><p>所有系统事件都在主线程上运行。最佳做法是使用 <code>OnUpdate</code>方法来安排作业来执行大部分工作。要从系统安排作业，您可以使用以下机制之一：</p><ul><li><code>Entities.ForEach</code>：遍历组件数据。</li><li><code>Job.WithCode</code>：将 lambda表达式作为单个后台作业执行。</li><li><code>IJobEntity</code>：迭代多个系统中的组件数据。</li><li><code>IJobEntityBatch</code>：按原型块迭代数据。</li></ul><p>以下示例说明了使用 <code>Entities.ForEach</code>来实现一个系统，该系统根据一个组件的值更新另一个组件：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public struct Position : IComponentData&#123;    public float3 Value;&#125;public struct Velocity : IComponentData&#123;    public float3 Value;&#125;[RequireMatchingQueriesForUpdate]public partial class ECSSystem : SystemBase&#123;    protected override void OnUpdate()    &#123;        &#x2F;&#x2F; &#96;ForEach&#96; 中捕获的局部变量        float dT &#x3D; SystemAPI.Time.DeltaTime;        Entities            .WithName(&quot;Update_Displacement&quot;)            .ForEach(                (ref Position position, in Velocity velocity) &#x3D;&gt;                &#123;                    position &#x3D; new Position()                    &#123;                        Value &#x3D; position.Value + velocity.Value * dT                    &#125;;                &#125;            )            .ScheduleParallel();    &#125;&#125;</code></pre></div></figure></p><h2 id="回调方法顺序">回调方法顺序</h2><p><code>SystemBase</code> 中有几个回调方法，Unity在系统创建过程中的不同点调用，您可以使用它们来安排系统必须在每一帧执行的工作：</p><ul><li><code>OnCreate</code>：创建系统时调用。</li><li><code>OnStartRunning</code>：在第一次调用 <code>OnUpdate</code>之前以及系统恢复运行时调用。</li><li><code>OnUpdate</code>：只要系统有工作要做，就会在每一帧调用。有关确定系统何时有工作要做的因素的更多信息，请参阅<code>ShouldRunSystem</code>。</li><li><code>OnStopRunning</code>：在 <code>OnDestroy</code>之前调用。每当系统停止运行时也会调用，如果没有实体与系统的<code>EntityQuery</code> 匹配，或者如果系统的 <code>Enabled</code>属性设置为 <code>false</code>，就会发生这种情况。</li><li><code>OnDestroy</code>：系统被销毁时调用。</li></ul><p>下图说明了系统的事件顺序：<br /><imgsrc="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/images/SystemEventOrder.png"alt="回调方法顺序" /><br />父系统组的 <code>OnUpdate</code> 方法触发其组中所有系统的<code>OnUpdate</code>方法。有关系统如何更新的更多信息，请参阅系统的更新顺序。</p><h1 id="迭代数据">迭代数据</h1><p>迭代数据是创建系统时需要执行的最常见任务之一。系统通常处理一组实体，从一个或多个组件读取数据，执行计算，然后将结果写入另一个组件。</p><p>迭代实体和组件的最有效方法是在按顺序处理组件的作业中。这利用了所有可用内核和数据局部性的处理能力来避免CPU 缓存未命中。</p><p>本节介绍如何通过以下方式迭代实体数据：</p><table><thead><tr class="header"><th>标题</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>使用 <code>Entities.ForEach</code> 迭代数据</td><td>如何使用 <code>SystemBase.Entities.ForEach</code>逐个实体地处理组件数据。</td></tr><tr class="even"><td>使用 <code>IJobEntity</code> 迭代数据</td><td>如何使用 <code>IJobEntity</code> 编写一次并创建多个计划。</td></tr><tr class="odd"><td>遍历成批数据</td><td>如何使用 <code>IJobEntityBatch</code>遍历包含匹配实体的原型块。</td></tr><tr class="even"><td>手动迭代数据</td><td>如何手动迭代实体或原型块。</td></tr></tbody></table><h2 id="额外资源">额外资源</h2><p>您还可以使用 <code>EntityQuery</code>类来构建数据视图，其中仅包含给定算法或过程所需的特定数据。上面列表中的许多迭代方法显式或内部使用<code>EntityQuery</code>。有关详细信息，请参阅使用<code>EntityQuery</code>查询实体数据。</p><h2 id="使用-entities.foreach-迭代数据">使用<code>Entities.ForEach</code> 迭代数据</h2><p>如果您使用 <code>SystemBase</code> 类来创建您的系统，则可以使用<code>Entities.ForEach</code>构造来定义和执行针对实体及其组件的算法。在编译时，Unity 将每个<code>ForEach()</code> 调用转换为生成的作业。</p><p>您向 <code>Entities.ForEach</code> 传递一个 lambda 表达式，Unity会根据 lambda 参数类型生成一个实体查询。当生成的作业运行时，Unity会为每个与查询匹配的实体调用一次 lambda。<code>ForEachLambdaJobDescription</code> 表示此生成的作业。</p><h3 id="定义一个-lambda-表达式">定义一个 lambda 表达式</h3><p>当您定义 <code>Entities.ForEach</code> lambda 表达式时，您可以声明<code>SystemBase</code>类在执行该方法时用于传递有关当前实体的信息的参数。</p><p>典型的 lambda 表达式如下所示：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Entities.ForEach(    (        Entity entity,        int entityInQueryIndex,        &#96;ref&#96; ObjectPosition translation,        in Movement move    ) &#x3D;&gt; &#123; &#x2F;* .. *&#x2F;&#125;)</code></pre></div></figure><br />您最多可以将八个参数传递给 <code>Entities.ForEach</code> lambda表达式。如果需要传递更多参数，可以定义自定义委托。有关详细信息，请参阅本文档中有关自定义委托的部分。</p><p>使用标准委托时，必须按以下顺序对参数进行分组：</p><ol type="1"><li>按值传递的参数（无参数修饰符）</li><li>可写参数（<code>ref</code>参数修饰符）</li><li>只读参数（<code>in</code>参数修饰符）</li></ol><p>您必须在所有组件上使用 <code>ref</code> 或 <code>in</code>参数修改关键字。如果你不这样做，Unity传递给你的方法的组件结构是一个副本而不是引用。这意味着它会为只读参数占用额外的内存，并且当函数返回后复制的结构超出范围时，您对组件所做的任何更改都会被静默抛出。</p><p>如果 lambda表达式不遵循此顺序，并且您还没有创建合适的委托，则编译器会提供类似于以下内容的错误：</p><div class="note note-danger">            <p>error CS1593: Delegate‘Invalid_ForEach_Signature_See_ForEach_Documentation_For_Rules_And_Restrictions’does not take N arguments</p>          </div><p>此错误消息将参数数量作为问题，即使问题是参数顺序也是如此。</p><h4 id="自定义代理">自定义代理</h4><p>如果要在 <code>ForEach</code> lambda表达式中使用八个以上的参数，则必须声明自己的委托类型和<code>ForEach</code>重载。这允许您使用无限数量的参数，并以您想要的任何顺序放置<code>ref</code>、<code>in</code> 和 <code>value</code> 参数。</p><p>您还可以在参数列表中的任意位置声明三个命名参数<code>entity</code>、<code>entityInQueryIndex</code> 和<code>nativeThreadIndex</code>。不要对这些参数使用 <code>ref</code> 或<code>in</code> 修饰符。</p><p>以下示例显示 12 个参数，并在 lambda表达式中使用<code>entity</code>参数：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">static class BringYourOwnDelegate&#123;    &#x2F;&#x2F; 声明采用 12 个参数的委托。 T0 用于 Entity 参数    public delegate void CustomForEachDelegate&lt;T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11&gt;        (T0 t0, in T1 t1, in T2 t2, in T3 t3, in T4 t4, in T5 t5,         in T6 t6, in T7 t7, in T8 t8, in T9 t9, in T10 t10, in T11 t11);    &#x2F;&#x2F; 声明函数重载    public static TDescription ForEach&lt;TDescription, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11&gt;        (this TDescription description, CustomForEachDelegate&lt;T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11&gt; codeToRun)        where TDescription : struct, Unity.Entities.CodeGeneratedJobForEach.ISupportForEachWithUniversalDelegate &#x3D;&gt;        LambdaForEachDescriptionConstructionMethods.ThrowCodeGenException&lt;TDescription&gt;();&#125;&#x2F;&#x2F; 使用自定义委托和重载的系统[RequireMatchingQueriesForUpdate]public partial class MayParamsSystem : SystemBase&#123;    protected override void OnUpdate()    &#123;        Entities.ForEach(                (Entity entity0,                    in Data1 d1,                    in Data2 d2,                    in Data3 d3,                    in Data4 d4,                    in Data5 d5,                    in Data6 d6,                    in Data7 d7,                    in Data8 d8,                    in Data9 d9,                    in Data10 d10,                    in Data11 d11                    ) &#x3D;&gt; &#123;&#x2F;* .. *&#x2F;&#125;)            .Run();    &#125;&#125;</code></pre></div></figure></p><h4 id="组件参数">组件参数</h4><p>要访问与实体关联的组件，您必须将该组件类型的参数传递给 lambda表达式。编译器会自动将传递给 lambda表达式的所有组件作为必需组件添加到实体查询中。</p><p>要更新组件值，您必须使用参数列表中的 <code>ref</code>关键字将其传递给 lambda 表达式。如果没有 <code>ref</code> 关键字，Unity将对组件的临时副本进行任何修改。</p><p>要声明传递给 lambda 表达式的只读组件，请使用参数列表中的<code>in</code> 关键字。</p><p>当您使用 <code>ref</code> 时，Unity会将当前块中的组件标记为已更改，即使 lambda表达式实际上并未修改它们。为了提高效率，您应该始终使用 <code>in</code>关键字将您的 lambda 表达式未修改的组件声明为只读。</p><p>以下示例将 <code>Source</code> 组件参数作为只读传递给作业，并将<code>Destination</code> 组件参数作为可写传递：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Entities.ForEach(    (ref Destination outputData,        in Source inputData) &#x3D;&gt;    &#123;        outputData.Value &#x3D; inputData.Value;    &#125;)    .ScheduleParallel();</code></pre></div></figure></p><div class="note note-danger">            <p>您不能将块组件传递给 <code>Entities.ForEach</code> lambda表达式。</p>          </div><p>对于动态缓冲区，使用 <code>DynamicBuffer&lt;T&gt;</code>而不是缓冲区中存储的组件类型：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">[RequireMatchingQueriesForUpdate]public partial class BufferSum : SystemBase&#123;    private EntityQuery query;    &#x2F;&#x2F; 安排两个作业之间的依赖关系    protected override void OnUpdate()    &#123;        &#x2F;&#x2F; 这里可以访问query变量，        &#x2F;&#x2F; 因为我们在下面的entities.ForEach中使用了WithStoreEntityQueryInField(query)        int entitiesInQuery &#x3D; query.CalculateEntityCount();        &#x2F;&#x2F; 创建一个原生数组来保存中间和        &#x2F;&#x2F; (每个实体一个元素)        NativeArray&lt;int&gt; intermediateSums            &#x3D; new NativeArray&lt;int&gt;(entitiesInQuery, Allocator.TempJob);        &#x2F;&#x2F; 安排第一个作业以添加所有缓冲区元素        Entities            .ForEach((int entityInQueryIndex, in DynamicBuffer&lt;IntBufferData&gt; buffer) &#x3D;&gt;        &#123;            for (int i &#x3D; 0; i &lt; buffer.Length; i++)            &#123;                intermediateSums[entityInQueryIndex] +&#x3D; buffer[i].Value;            &#125;        &#125;)            .WithStoreEntityQueryInField(ref query)            .WithName(&quot;IntermediateSums&quot;)            .ScheduleParallel(); &#x2F;&#x2F; 为每个实体块并行执行        &#x2F;&#x2F; 安排第二个工作，依赖于第一个        Job.WithCode(() &#x3D;&gt;        &#123;            int result &#x3D; 0;            for (int i &#x3D; 0; i &lt; intermediateSums.Length; i++)            &#123;                result +&#x3D; intermediateSums[i];            &#125;            &#x2F;&#x2F;不兼容burst:            Debug.Log(&quot;Final sum is &quot; + result);        &#125;)            .WithDisposeOnCompletion(intermediateSums)            .WithoutBurst()            .WithName(&quot;FinalSum&quot;)            .Schedule(); &#x2F;&#x2F; 在单个后台线程上执行    &#125;&#125;</code></pre></div></figure></p><h4 id="命名参数">命名参数</h4><p>您还可以将以下命名的参数传递给 <code>Entities.ForEach</code> lambda表达式，Unity 根据作业正在处理的实体为其分配值。<br />| 参数 | 函数 |<br />| ———————– |—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————-|<br />| Entity entity | 当前实体的实体实例。只要类型是Entity，您就可以将参数命名为任何名称。 |<br />| int entityInQueryIndex |实体在查询选择的所有实体列表中的索引。当您有一个需要为每个实体填充唯一值的nativearray时，请使用实体索引值。您可以使用 entityInQueryIndex作为该数组中的索引。您应该使用 entityInQueryIndex 作为 sortKey将命令添加到并发实体命令缓冲区。 |<br />| int nativeThreadIndex | 执行 lambda表达式当前迭代的线程的唯一索引。当您使用 Run() 执行 lambda表达式时，nativeThreadIndex 始终为零。不要使用 nativeThreadIndex作为并发实体命令缓冲区的 sortKey；使用 entityInQueryIndex 代替。 |<br />| EntityCommands commands | 只要类型是EntityCommands，您就可以将此参数命名为任何名称。仅将此参数与WithDeferredPlaybackSystem<T>() 或 WithImmediatePlayback() 结合使用。EntityCommands 类型包含几个方法，这些方法反映了 EntityCommandBuffer类型中的对应方法。如果您在 Entities.ForEach() 中使用 EntityCommands实例，编译器会在适当的地方创建额外的代码来处理实体命令缓冲区的创建、调度、播放和处置，在这些代码上调用EntityCommands 方法的对应方法。 |</p><h3 id="执行-entities.foreach-lambda-表达式">执行<code>Entities.ForEach</code> lambda 表达式</h3><p>您可以通过以下方式执行作业 lambda 表达式：</p><ul><li>使用 Schedule() 和 ScheduleParallel() 来安排作业</li><li>使用 Run() 立即在主线程上执行作业。<br />以下示例说明了使用 <code>Entities.ForEach</code> 读取<code>Velocity</code> 组件并写入 <code>ObjectPosition</code> 组件的<code>SystemBase</code> 实现：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">[RequireMatchingQueriesForUpdate]partial class ApplyVelocitySystem : SystemBase&#123;    protected override void OnUpdate()    &#123;        Entities.ForEach((ref ObjectPosition translation,            in Velocity velocity) &#x3D;&gt;            &#123;                translation.Value +&#x3D; velocity.Value;            &#125;)            .Schedule();    &#125;&#125;</code></pre></div></figure></li></ul><h3 id="选择实体">选择实体</h3><p><code>Entities.ForEach</code>有自己的机制来定义用于选择要处理的实体的实体查询。该查询会自动包含您用作lambda 表达式参数的任何组件。</p><p>您还可以使用 <code>WithAll</code>、<code>WithAny</code> 和<code>WithNone</code> 子句进一步细化 <code>Entities.ForEach</code>选择的实体。有关查询选项的完整列表，请参阅<code>SystemBase.Entities</code>。</p><p>以下示例使用这些子句根据这些参数选择实体：</p><ul><li>该实体具有组件：<code>Destination</code>、<code>Source</code> 和<code>LocalToWorld</code></li><li>实体至少具有以下组件之一：<code>ObjectRotation</code>、<code>ObjectPosition</code>或 <code>ObjectUniformScale</code></li><li>该实体没有 <code>ObjectNonUniformScale</code> 组件。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Entities.WithAll&lt;LocalToWorld&gt;()    .WithAny&lt;ObjectRotation, ObjectPosition, ObjectUniformScale&gt;()    .WithNone&lt;ObjectNonUniformScale&gt;()    .ForEach((ref Destination outputData, in Source inputData) &#x3D;&gt;    &#123;        &#x2F;* do some work *&#x2F;    &#125;)    .Schedule();</code></pre></div></figure><br />在此示例中，在 lambda 表达式中仅访问 <code>Destination</code> 和<code>Source</code> 组件，因为它们是参数列表中的唯一组件。</li></ul><h3 id="访问-entityquery-对象">访问 EntityQuery 对象</h3><p><code>Entities.ForEach</code> 使用 <code>OnCreate</code> 创建一个<code>EntityQuery</code>，您可以随时使用它的副本，甚至在调用<code>Entities.ForEach</code> 之前。</p><p>要访问此实体查询，请使用带有 <code>ref</code> 参数修饰符的<code>WithStoreEntityQueryInField(ref query)</code>。此方法将对查询的引用分配给您提供的字段。但是，此<code>EntityQuery</code> 没有 <code>Entities.ForEach</code>调用设置的任何过滤器。</p><p>以下示例说明如何访问为 <code>Entities.ForEach</code> 构造隐式创建的<code>EntityQuery</code> 对象。它使用 <code>EntityQuery</code>对象来调用 <code>CalculateEntityCount()</code>方法，并使用此计数创建一个具有足够空间的nativearray，来为查询选择的每个实体存储一个值：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">private EntityQuery query;protected override void OnUpdate()&#123;    int dataCount &#x3D; query.CalculateEntityCount();    NativeArray&lt;float&gt; dataSquared        &#x3D; new NativeArray&lt;float&gt;(dataCount, Allocator.Temp);    Entities        .WithStoreEntityQueryInField(ref query)        .ForEach((int entityInQueryIndex, in Data data) &#x3D;&gt;        &#123;            dataSquared[entityInQueryIndex] &#x3D; data.Value * data.Value;        &#125;)        .ScheduleParallel();    Job        .WithCode(() &#x3D;&gt;    &#123;        &#x2F;&#x2F;使用 dataSquared 数组...        var v &#x3D; dataSquared[dataSquared.Length - 1];    &#125;)        .WithDisposeOnCompletion(dataSquared)        .Schedule();&#125;</code></pre></div></figure></p><h3 id="访问可选组件">访问可选组件</h3><p><code>Entities.ForEach</code> lambda 表达式不支持使用<code>WithAny&lt;T,U&gt;</code> 查询和访问可选组件。</p><p>如果要读取或写入可选组件，请将 <code>Entities.ForEach</code>构造拆分为可选组件的每个组合的多个作业。例如，如果您有两个可选组件，则需要三个<code>ForEach</code>结构：一个包含第一个可选组件，一个包含第二个可选组件，一个包含两个组件。另一种选择是按块使用<code>IJobChunkiterate</code>。有关详细信息，请参阅按批次迭代数据。</p><h3 id="更改过滤">更改过滤</h3><p>您可以使用 <code>WithChangeFilter&lt;T&gt;</code>来启用<strong>更改过滤</strong>，只有在当前 <code>SystemBase</code>实例上次运行后实体中的另一个组件发生更改时，它才会处理组件。更改过滤器中的组件类型必须在lambda 表达式参数列表中，或者是 <code>WithAll&lt;T&gt;</code>语句的一部分。例如：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Entities    .WithChangeFilter&lt;Source&gt;()    .ForEach((ref Destination outputData,        in Source inputData) &#x3D;&gt;        &#123;            &#x2F;* Do work *&#x2F;        &#125;)    .ScheduleParallel();</code></pre></div></figure><br />实体查询最多支持对两种组件类型进行更改过滤。</p><p>Unity在原型块级别应用更改过滤。如果任何代码访问具有写访问权限的块中的组件，那么Unity会将该原型块中的组件类型标记为已更改，即使代码没有更改任何数据。</p><h3 id="共享组件过滤">共享组件过滤</h3><p>Unity将具有共享组件的实体与其他具有相同共享组件值的实体分组。要选择具有特定共享组件值的实体组，请使用<code>WithSharedComponentFilter</code> 方法。</p><p>以下示例选择了全部按 <code>Cohort:ISharedComponentData</code>分组的实体。此示例中的 lambda 表达式根据实体的Cohort设置<code>DisplayColor:IComponentData</code> 组件：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">[RequireMatchingQueriesForUpdate]public partial class ColorCycleJob : SystemBase&#123;    protected unsafe override void OnUpdate()    &#123;        EntityManager.GetAllUniqueSharedComponents&lt;Cohort&gt;(out var cohorts, Allocator.Temp);        for (int i&#x3D;0; i&lt;cohorts.Length; i++)        &#123;            var cohort &#x3D; cohorts[i];            DisplayColor newColor &#x3D; ColorTable.GetNextColor(cohort.Value);            Entities.WithSharedComponentFilter(cohort)                .ForEach((ref DisplayColor color) &#x3D;&gt; &#123; color &#x3D; newColor; &#125;)                .ScheduleParallel();        &#125;    &#125;&#125;</code></pre></div></figure><br />该示例使用 <code>EntityManager</code>获取所有唯一同类Cohort值的队列数组。然后它为每个队列安排一个 lambda作业，并将新颜色作为捕获变量传递给 lambda 表达式。</p><h3 id="捕获变量">捕获变量</h3><p>您可以捕获 <code>Entities.ForEach</code> lambda表达式的局部变量。当您调用其中一种 Schedule 方法而不是 Run来使用作业来执行 lambda表达式时，对捕获的变量以及如何使用它们有一些限制：</p><ul><li>您只能捕获 NativeContainer 和 blittable 类型。</li><li>作业只能写入作为NativeContainer的捕获变量。要返回单个值，请创建一个包含一个元素的nativearray。</li></ul><p>如果您要读取NativeContainer，但不写入它，请始终使用<code>WithReadOnly(variable)</code>指定只读访问权限。有关为捕获的变量设置属性的详细信息，请参阅<code>SystemBase.Entities</code>。 <code>Entities.ForEach</code>将这些作为方法提供，因为 C# 语言不允许局部变量的属性。</p><p>要在 <code>Entities.ForEach</code>运行后处理捕获的NativeContainer或包含NativeContainer的类型，请使用<code>WithDisposeOnCompletion(variable)</code>。如果您在<code>Run()</code> 中调用它，它会在 lambda表达式运行后立即处理这些类型。如果您在 <code>Schedule()</code> 和<code>ScheduleParallel()</code>中调用它，它会安排它们稍后与作业一起处理，并返回 JobHandle。</p><div class="note note-info">            <p>当您使用 <code>Run()</code>执行该方法时，您可以写入不是NativeContainer的捕获变量。但是，您仍应尽可能使用blittable 类型，以便可以使用 Burst 编译该方法。</p>          </div><h3 id="支持的功能">支持的功能</h3><p>除了使用 <code>Run()</code> 在主线程上执行 lambda表达式。您还可以使用 <code>Schedule()</code>将其作为单个作业执行，或使用 <code>ScheduleParallel()</code>将其作为并行作业执行。这些不同的执行方法对您访问数据的方式有不同的限制。此外，Burst编译器使用 C# 语言的一个受限子集，因此如果要在该子集之外使用 C#功能，则需要指定 <code>WithoutBurst()</code>。这包括访问托管类型。</p><p>下表显示了 <code>Entities.ForEach</code> 中支持哪些用于<code>SystemBase</code> 中的不同的调度方法：<br />| 支持的功能 | Run | Schedule | ScheduleParallel |<br />| ———————————– | ——————————————— | ——– | —————- |<br />| 捕获本地值类型 | ✓ | ✓ | ✓ |<br />| 捕获本地引用类型 | Only WithoutBurst and not in ISystem | | |<br />| 写入捕获的变量 | ✓ | | |<br />| 在系统类上使用字段 | Only WithoutBurst | | |<br />| 引用类型的方法 | Only WithoutBurst and not in ISystem | | |<br />| 共享组件 | Only WithoutBurst and not in ISystem | | |<br />| 托管组件 | Only WithoutBurst and not in ISystem | | |<br />| 结构变化 | Only WithStructuralChanges and not in ISystem | | |<br />| SystemBase.GetComponent | ✓ | ✓ | ✓ |<br />| SystemBase.SetComponent | ✓ | ✓ | |<br />| GetComponentDataFromEntity | ✓ | ✓ | Only as ReadOnly |<br />| HasComponent | ✓ | ✓ | ✓ |<br />| WithDisposeOnCompletion | ✓ | ✓ | ✓ |<br />| WithScheduleGranularity | | | ✓ |<br />| WithDeferredPlaybackSystem | ✓ | ✓ | ✓ |<br />| WithImmediatePlayback | ✓ | | |<br />| HasBuffer | ✓ | ✓ | ✓ |<br />| SystemBase.GetStorageInfoFromEntity | ✓ | ✓ | ✓ |<br />| SystemBase.Exists | ✓ | ✓ | ✓ |</p><div class="note note-waring">            <p><code>WithStructuralChanges()</code> 会禁用突发。如果您想获得高性能<code>Entities.ForEach</code>，请不要使用此选项。如果要使用此选项，请使用<code>EntityCommandBuffer</code>。</p>          </div><p><code>Entities.ForEach</code> 构造使用 Roslyn源代码生成器将您为构造编写的代码转换为正确的 ECS代码。这种翻译意味着您可以表达算法的意图，而无需包含复杂的样板代码。但是，这意味着一些常见的代码编写方式是不允许的。</p><p>不支持以下功能：</p><ul><li><code>.With</code> 调用中的动态代码</li><li>使用ref修饰 <code>SharedComponent</code> 参数</li><li>嵌套 <code>Entities.ForEach</code> lambda 表达式</li><li>调用存储在变量、字段或方法中的委托</li><li>具有 lambda 参数类型的 <code>SetComponent</code></li><li>具有可写 lambda 参数的 <code>GetComponent</code></li><li>lambdas 中的泛型参数</li><li>在具有泛型参数的系统中</li></ul><h3 id="依赖关系">依赖关系</h3><p>默认情况下，系统使用其 <code>Dependency</code> 属性来管理其与 ECS相关的依赖项。默认情况下，系统按照它们在 <code>OnUpdate()</code>函数中出现的顺序将使用 <code>Entities.ForEach</code> 和<code>Job.WithCode</code> 创建的每个作业添加到依赖作业句柄。您还可以将<code>JobHandle</code> 传递给您的 <code>Schedule</code>方法以手动管理作业依赖性，然后返回生成的依赖性。有关详细信息，请参阅依赖项文档。</p><p>有关作业依赖性的更多一般信息，请参阅作业依赖性。</p><h2 id="使用-ijobentity-迭代数据">使用 <code>IJobEntity</code>迭代数据</h2><p>当您在多个系统中使用不同的调用进行数据转换时，要遍历<code>ComponentData</code>，您可以使用 <code>IJobEntity</code>，它类似于<code>Entities.ForEach</code>。</p><p>它创建一个 <code>IJobEntityBatch</code>作业，因此您只需考虑要转换的数据。</p><h3 id="ijobentity-和-entities.foreach-的比较">IJobEntity 和<code>Entities.ForEach</code> 的比较</h3><p><code>IJobEntity</code> 相对于 <code>Entities.ForEach</code>的优势在于您可以编写一次代码并在多个系统中重复使用它，而不是仅一次。</p><p>这是一个 <code>Entities.ForEach</code> 示例：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">[RequireMatchingQueriesForUpdate]public partial class BoidForEachSystem : SystemBase&#123;    EntityQuery m_BoidQuery;    EntityQuery m_ObstacleQuery;    EntityQuery m_TargetQuery;    protected override void OnUpdate()    &#123;        &#x2F;&#x2F; 计算各个查询中的实体数量。        var boidCount &#x3D; m_BoidQuery.CalculateEntityCount();        var obstacleCount &#x3D; m_ObstacleQuery.CalculateEntityCount();        var targetCount &#x3D; m_TargetQuery.CalculateEntityCount();        &#x2F;&#x2F; 分配数组，以存储与相应的查询匹配的实体数量相等的数据。        var cellSeparation &#x3D; CollectionHelper.CreateNativeArray&lt;float3, RewindableAllocator&gt;(boidCount, ref World.UpdateAllocator);        var copyTargetPositions &#x3D; CollectionHelper.CreateNativeArray&lt;float3, RewindableAllocator&gt;(targetCount, ref World.UpdateAllocator);        var copyObstaclePositions &#x3D; CollectionHelper.CreateNativeArray&lt;float3, RewindableAllocator&gt;(obstacleCount, ref World.UpdateAllocator);        &#x2F;&#x2F; 安排各个数组的作业与各个查询一起存储。        Entities            .WithSharedComponentFilter(new BoidSetting&#123;num&#x3D;1&#125;)            .ForEach((int entityInQueryIndex, in LocalToWorld localToWorld) &#x3D;&gt;            &#123;                cellSeparation[entityInQueryIndex] &#x3D; localToWorld.Position;            &#125;)            .ScheduleParallel();        Entities            .WithAll&lt;BoidTarget&gt;()            .WithStoreEntityQueryInField(ref m_TargetQuery)            .ForEach((int entityInQueryIndex, in LocalToWorld localToWorld) &#x3D;&gt;            &#123;                copyTargetPositions[entityInQueryIndex] &#x3D; localToWorld.Position;            &#125;)            .ScheduleParallel();        Entities            .WithAll&lt;BoidObstacle&gt;()            .WithStoreEntityQueryInField(ref m_ObstacleQuery)            .ForEach((int entityInQueryIndex, in LocalToWorld localToWorld) &#x3D;&gt;            &#123;                copyObstaclePositions[entityInQueryIndex] &#x3D; localToWorld.Position;            &#125;)            .ScheduleParallel();    &#125;&#125;</code></pre></div></figure><br />可以改写如下：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">[RequireMatchingQueriesForUpdate]public partial class BoidJobEntitySystem : SystemBase&#123;    EntityQuery m_BoidQuery;    EntityQuery m_ObstacleQuery;    EntityQuery m_TargetQuery;    protected override void OnUpdate()    &#123;        &#x2F;&#x2F; 计算各个查询中的实体数量。        var boidCount &#x3D; m_BoidQuery.CalculateEntityCount();        var obstacleCount &#x3D; m_ObstacleQuery.CalculateEntityCount();        var targetCount &#x3D; m_TargetQuery.CalculateEntityCount();        &#x2F;&#x2F; 分配数组，以存储与相应的查询匹配的实体数量相等的数据。        var cellSeparation &#x3D; CollectionHelper.CreateNativeArray&lt;float3, RewindableAllocator&gt;(boidCount, ref World.UpdateAllocator);        var copyTargetPositions &#x3D; CollectionHelper.CreateNativeArray&lt;float3, RewindableAllocator&gt;(targetCount, ref World.UpdateAllocator);        var copyObstaclePositions &#x3D; CollectionHelper.CreateNativeArray&lt;float3, RewindableAllocator&gt;(obstacleCount, ref World.UpdateAllocator);        &#x2F;&#x2F; 为各自的数组安排作业，以与各自的查询一起存储。        new CopyPositionsJob &#123; copyPositions &#x3D; cellSeparation&#125;.ScheduleParallel(m_BoidQuery);        new CopyPositionsJob &#123; copyPositions &#x3D; copyTargetPositions&#125;.ScheduleParallel(m_TargetQuery);        new CopyPositionsJob &#123; copyPositions &#x3D; copyObstaclePositions&#125;.ScheduleParallel(m_ObstacleQuery);    &#125;    protected override void OnCreate()    &#123;        &#x2F;&#x2F; 获取相应的查询，其中包括前面描述的“CopyPositionsJob”所需的组件。        m_BoidQuery &#x3D; GetEntityQuery(typeof(LocalToWorld));        m_BoidQuery.SetSharedComponentFilter(new BoidSetting&#123;num&#x3D;1&#125;);        m_ObstacleQuery &#x3D; GetEntityQuery(typeof(LocalToWorld), typeof(BoidObstacle));        m_TargetQuery &#x3D; GetEntityQuery(typeof(LocalToWorld), typeof(BoidTarget));;    &#125;&#125;</code></pre></div></figure></p><h3 id="创建-ijobentity-作业">创建 IJobEntity 作业</h3><p>要创建 <code>IJobEntity</code> 作业，请编写一个使用<code>IJobEntity</code> 接口的结构，并实现您自己的自定义<code>Execute</code> 方法。</p><p>使用 <code>partial</code>关键字是因为源代码生成创建了一个结构，该结构在<code>project/Temp/GeneratedCode/.....</code> 中找到的单独文件中实现<code>IJobEntityBatch</code>。</p><p>以下示例每帧向每个 <code>SampleComponent</code> 值加1。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public struct SampleComponent : IComponentData &#123; public float Value; &#125;public partial struct ASampleJob : IJobEntity&#123;    &#x2F;&#x2F; 每个SampleComponent值+1    void Execute(ref SampleComponent sample)    &#123;        sample.Value +&#x3D; 1f;    &#125;&#125;public partial class ASample : SystemBase&#123;    protected override void OnUpdate()    &#123;        &#x2F;&#x2F; 调度作业        new ASampleJob().ScheduleParallel();    &#125;&#125;</code></pre></div></figure></p><h3 id="指定查询">指定查询</h3><p>您可以通过以下方式指定 IJobEntity 的查询：</p><ul><li>手动创建查询，以指定不同的调用要求。</li><li>让已实施的 <code>IJobEntity</code>为您完成，基于其给定的执行参数，以及使用属性<code>[WithAll(params Type)]</code>、<code>[WithAny(params Type)]</code>、<code>[WithNone(params Type)]</code>、<code>[ WithChangeFilter(params Type)]</code>和<code>[WithEntityQueryOptions((params EntityQueryOptions)]</code>。</li></ul><p>以下示例显示了这两个选项：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">partial struct QueryJob : IJobEntity&#123;    &#x2F;&#x2F; 迭代所有 SampleComponents 并增加它们的值    public void Execute(ref SampleComponent sample)    &#123;        sample.Value +&#x3D; 1;    &#125;&#125;[RequireMatchingQueriesForUpdate]public partial class QuerySystem : SystemBase&#123;    &#x2F;&#x2F; 与 QueryJob 匹配的查询，为 &#96;BoidTarget&#96; 指定    EntityQuery query_boidtarget;    &#x2F;&#x2F; 与 QueryJob 匹配的查询，为 &#96;BoidObstacle&#96; 指定    EntityQuery query_boidobstacle;    protected override void OnCreate()    &#123;        &#x2F;&#x2F; 包含在“QueryJob”中找到的所有执行参数的查询 - 以及其他用户指定的组件“BoidTarget”。        query_boidtarget &#x3D; GetEntityQuery(ComponentType.ReadWrite&lt;SampleComponent&gt;(),ComponentType.ReadOnly&lt;BoidTarget&gt;());        &#x2F;&#x2F; 包含在“QueryJob”中找到的所有执行参数的查询 - 以及其他用户指定的组件“BoidObstacle”。        query_boidobstacle &#x3D; GetEntityQuery(ComponentType.ReadWrite&lt;SampleComponent&gt;(),ComponentType.ReadOnly&lt;BoidObstacle&gt;());    &#125;    protected override void OnUpdate()    &#123;        &#x2F;&#x2F; Uses the BoidTarget query        new QueryJob().ScheduleParallel(query_boidtarget);        &#x2F;&#x2F; Uses the BoidObstacle query        new QueryJob().ScheduleParallel(query_boidobstacle);        &#x2F;&#x2F; Uses query created automatically that matches parameters found in &#96;QueryJob&#96;.        new QueryJob().ScheduleParallel();    &#125;&#125;</code></pre></div></figure></p><h4 id="属性">属性</h4><p>因为 IJobEntity类似于作业，所以您可以使用对作业起作用的所有属性：</p><ul><li><code>Unity.Burst.BurstCompile</code></li><li><code>Unity.Collections.DeallocateOnJobCompletion</code></li><li><code>Unity.Collections.NativeDisableParallelForRestriction</code></li><li><code>Unity.Burst.BurstDiscard</code></li><li><code>Unity.Collections.LowLevel.Unsafe.NativeSetThreadIndex</code></li><li><code>Unity.Burst.NoAlia</code></li></ul><p>IJobEntity 还具有您可以使用的其他属性：<br />| 属性 | 描述 |<br />| ——————————————————————– | ————————————————————————————————————————–|<br />| <code>Unity.Entities.WithAll(params Type[])</code> |在作业结构上设置。缩小查询范围，使实体必须匹配提供的所有类型。 |<br />| <code>Unity.Entities.WithAny(params Type[])</code> |在作业结构上设置。缩小查询范围，使实体必须匹配所提供的任何类型。 |<br />| <code>Unity.Entities.WithNone(params Type[])</code> |在作业结构上设置。缩小查询范围，使实体不必匹配所提供的任何类型。 |<br />| <code>Unity.Entities.WithChangeFilter(params Type[])</code> |在作业结构上设置或附加到执行中的参数。缩小查询范围，以便实体必须在给定组件的原型块中进行更改。|<br />|<code>Unity.Entities.WithEntityQueryOptions(params EntityQueryOptions[])</code>| 在作业结构上设置。更改查询范围以使用描述的 EntityQueryOptions。|<br />| <code>Unity.Entities.EntityInQueryIndex</code> | 在 Execute 中设置 int参数以获取查询中的当前索引，用于当前实体迭代。这与<code>Entities.ForEach</code> 中的 entityInQueryIndex 相同。 |</p><p>以下是 <code>EntityInQueryIndex</code> 的示例：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">[BurstCompile]partial struct CopyPositionsJob : IJobEntity&#123;    public NativeArray&lt;float3&gt; copyPositions;    &#x2F;&#x2F; 遍历所有 &#96;LocalToWorld&#96; 并将它们的位置存储在 &#96;copyPositions&#96; 中。    public void Execute([EntityInQueryIndex] int entityInQueryIndex, in LocalToWorld localToWorld)    &#123;        copyPositions[entityInQueryIndex] &#x3D; localToWorld.Position;    &#125;&#125;[RequireMatchingQueriesForUpdate]public partial class EntityInQuerySystem : SystemBase&#123;    &#x2F;&#x2F; 此查询应匹配 &#96;CopyPositionsJob&#96; 参数    EntityQuery query;    protected override void OnCreate()    &#123;        &#x2F;&#x2F; 获取匹配 &#96;CopyPositionsJob&#96; 参数的查询        query &#x3D; GetEntityQuery(ComponentType.ReadOnly&lt;LocalToWorld&gt;());    &#125;    protected override void OnUpdate()    &#123;        &#x2F;&#x2F; 获取一个native array，该数组的大小等于查询找到的实体数量。        var positions &#x3D; new NativeArray&lt;float3&gt;(query.CalculateEntityCount(), World.UpdateAllocator.ToAllocator);        &#x2F;&#x2F; 在并行线程上为此数组安排作业。        new CopyPositionsJob&#123;copyPositions &#x3D; positions&#125;.ScheduleParallel();        &#x2F;&#x2F; 处理作业找到的位置数组。        positions.Dispose(Dependency);    &#125;&#125;</code></pre></div></figure></p><h4 id="执行参数">执行参数</h4><p>以下是您可以在 <code>IJobEntity</code> 中使用的所有受支持<code>Execute</code> 参数的列表：</p><table><thead><tr class="header"><th>参数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>IComponentData</code></td><td>标记为 <code>ref</code> 用于读写访问，或标记为对<code>ComponentData</code> 的只读访问。</td></tr><tr class="even"><td><code>ICleanupComponentData</code></td><td>标记为 <code>ref</code> 用于读写访问，或标记为对<code>ComponentData</code> 的只读访问。</td></tr><tr class="odd"><td><code>ISharedComponent</code></td><td>标记为只读访问<code>SharedComponentData</code>。如果这是托管的，你不能突发编译或安排它。使用<code>.Run</code> 代替。</td></tr><tr class="even"><td>Managed components</td><td>使用值副本进行读写访问，或使用 <code>in</code>标记对托管组件进行只读访问。例如，UnityEngine.Transform。将托管组件标记为<code>ref</code> 是错误的，您不能对其进行突发编译或调度。使用 .Run代替。</td></tr><tr class="odd"><td><code>Entity</code></td><td>获取当前实体。这只是一个值副本，所以不要用 <code>ref</code> 或<code>in</code> 标记。</td></tr><tr class="even"><td><code>DynamicBuffer&lt;T&gt;</code></td><td>获取动态缓冲区。用 <code>ref</code> 标记为读写访问，用<code>in</code> 标记为只读访问。</td></tr><tr class="odd"><td><code>IAspect</code></td><td>获取方面。方面充当参考，因此您无法分配它们。但是，您可以使用<code>ref</code> 和 value-copy 将其标记为可读写，使用 <code>in</code>其标记为只读访问。</td></tr><tr class="even"><td><code>int</code></td><td>支持三种整数：</td></tr><tr class="odd"><td></td><td>使用属性 [Unity.Entities.ChunkIndexInQuery] 标记 <code>int</code>以获取查询中的当前原型块索引。</td></tr><tr class="even"><td></td><td>使用属性 [Unity.Entities.EntityIndexInChunk] 标记 <code>int</code>以获取当前原型块中的当前实体索引。您可以添加<code>EntityIndexInChunk</code> 和 <code>ChunkIndexInQuery</code>以获得每个实体的唯一标识符。</td></tr><tr class="odd"><td></td><td>使用属性 [Unity.Entities.EntityInQueryIndex] 标记 <code>int</code>以获取查询的打包索引。这对性能有影响，使用<code>EntityQuery.CalculateBaseEntityIndexArray[Async]</code>。</td></tr></tbody></table><h2 id="使用-ijobentitybatch-遍历成批数据">使用<code>IJobEntityBatch</code> 遍历成批数据</h2><p>在系统内实现 IJobEntityBatch 或 IJobEntityBatchWithIndex以在实体批次中迭代数据。</p><p>当您在系统的 OnUpdate 函数中计划 IJobEntityBatch作业时，系统会使用您传递给计划函数的实体查询来识别应该传递给该作业的块。该作业会为这些块中的每批实体调用一次您的Execute函数。默认情况下，批处理大小是一个完整的块，但您可以在调度作业时将批处理大小设置为块的一部分。无论批次大小如何，给定批次中的实体始终存储在同一块中。在作业的执行函数中，您可以逐个实体地迭代每个批次中的数据。</p><p>当您需要批次集中所有实体的索引值时，请使用<code>IJobEntityBatchWithIndex</code>。否则，<code>IJobEntityBatch</code>效率更高，因为它不需要计算这些索引。</p><p>要实施批处理作业：</p><ol type="1"><li><p>使用 EntityQuery 查询数据以确定要处理的实体。</p></li><li><p>使用 IJobEntityBatch 或 IJobEntityBatchWithIndex定义作业结构。</p></li><li><p>声明您的作业访问的数据。在作业结构中，包括用于标识作业必须直接访问的组件类型的ComponentTypeHandle对象的字段。此外，指定作业是读取还是写入这些组件。您还可以包含标识您要查找的实体数据的字段，这些实体不属于查询的一部分，以及用于非实体数据的字段。</p></li><li><p>编写作业结构的执行函数来转换您的数据。获取作业读取或写入的组件的NativeArray 实例，然后迭代当前批处理以执行所需的工作。</p></li><li><p>在系统 OnUpdate函数中安排作业，将标识要处理的实体的实体查询传递给调度函数。</p></li></ol><div class="note note-info">            <p>与使用 <code>Entities.ForEach</code> 相比，使用<code>IJobEntityBatch</code> 或 <code>IJobEntityBatchWithIndex</code>进行迭代更复杂并且需要更多的代码设置，并且只应在必要或更有效时使用。</p>          </div><p>有关详细信息，ECS 示例存储库包含一个简单的 HelloCube示例，该示例演示了如何使用 IJobEntityBatch。</p><h3 id="使用-entityquery-查询数据">使用 EntityQuery 查询数据</h3><p><code>EntityQuery</code> 定义了 <code>EntityArchetype</code>必须包含的组件类型集，系统才能处理其关联的块和实体。原型可以有额外的组件，但它必须至少有查询定义的组件。您还可以排除包含特定类型组件的原型。</p><p>将选择您的作业应处理的实体的查询传递给您用于安排作业的计划方法。</p><p>有关定义查询的信息，请参阅使用 <code>EntityQuery</code>查询数据。</p><div class="note note-info">            <p>不要在 <code>EntityQuery</code>中包含完全可选的组件。要处理可选组件，请使用<code>IJobEntityBatch.Execute</code> 中的<code>ArchetypeChunk.Has</code> 方法来确定当前<code>ArchetypeChunk</code>是否具有可选组件。因为同一批次中的所有实体都具有相同的组件，所以您只需要检查每个批次是否存在可选组件一次，而不是每个实体一次。</p>          </div><h3 id="定义作业结构">定义作业结构</h3><p>作业结构由执行要执行的工作的执行函数和声明执行函数使用的数据的字段组成。</p><p>典型的 <code>IJobEntityBatch</code> 作业结构如下所示：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public struct UpdateTranslationFromVelocityJob : IJobEntityBatch&#123;    public ComponentTypeHandle&lt;VelocityVector&gt; velocityTypeHandle;    public ComponentTypeHandle&lt;ObjectPosition&gt; translationTypeHandle;    public float DeltaTime;    [BurstCompile]    public void Execute(ArchetypeChunk batchInChunk, int batchIndex)    &#123;        NativeArray&lt;VelocityVector&gt; velocityVectors &#x3D;            batchInChunk.GetNativeArray(velocityTypeHandle);        NativeArray&lt;ObjectPosition&gt; translations &#x3D;            batchInChunk.GetNativeArray(translationTypeHandle);        for(int i &#x3D; 0; i &lt; batchInChunk.Count; i++)        &#123;            float3 translation &#x3D; translations[i].Value;            float3 velocity &#x3D; velocityVectors[i].Value;            float3 newTranslation &#x3D; translation + velocity * DeltaTime;            translations[i] &#x3D; new ObjectPosition() &#123; Value &#x3D; newTranslation &#125;;        &#125;    &#125;&#125;</code></pre></div></figure><br />此示例访问实体的两个组件 VelocityVector 和 Translation的数据，并根据自上次更新以来经过的时间计算新的平移。</p><h4 id="ijobentitybatch-与-ijobentitybatchwithindex">IJobEntityBatch 与IJobEntityBatchWithIndex</h4><p><code>IJobEntityBatch</code> 和 <code>IJobEntityBatchWithIndex</code>之间的唯一区别是 <code>IJobEntityBatchWithIndex</code> 在对批处理调用<code>Execute</code> 函数时传递一个<code>indexOfFirstEntityInQuery</code>参数。该参数为当前batch中第一个实体在实体查询选中的所有实体列表中的索引。</p><p>当您需要每个实体的单独索引时，请使用<code>IJobEntityBatchWithIndex</code>。例如，如果您为每个实体计算一个唯一的结果，您可以使用此索引将每个结果写入nativearray的不同元素。如果您不使用 <code>indexOfFirstEntityInQuery</code>值，请改用 <code>IJobEntityBatch</code>，以避免计算索引值的开销。</p><div class="note note-info">            <p>当您向 <code>[EntityCommandBuffer.ParallelWriter]</code>添加命令时，您可以使用 <code>batchIndex</code> 参数作为命令缓冲区函数的<code>sortKey</code> 参数。您不需要仅使用<code>IJobEntityBatchWithIndex</code>来为每个实体获取唯一的排序键。两种作业类型都可用的<code>batchIndex</code> 参数可用于此目的。</p>          </div><h4 id="声明您的工作访问的数据">声明您的工作访问的数据</h4><p>作业结构中的字段声明可用于 Execute函数的数据。这些领域分为四大类：</p><ul><li><p>ComponentTypeHandle 字段 —— 组件句柄字段允许您的 Execute函数访问存储在当前块中的实体组件和缓冲区。请参阅访问实体组件和缓冲区数据。</p></li><li><p>ComponentLookup、BufferLookup 字段 ——这些“来自实体的数据”字段允许您的 Execute函数查找任何实体的数据，无论它存储在何处。（这种类型的随机访问是访问数据效率最低的方式，只应在必要时使用。）请参阅查找其他实体的数据。</p></li><li><p>其他字段 ——您可以根据需要为您的结构声明其他字段。您可以在每次安排作业时设置此类字段的值。请参阅访问其他数据。</p></li><li><p>输出字段 ——除了更新作业中的可写实体组件或缓冲区外，您还可以写入为作业结构声明的NativeContainer字段。此类字段必须是原生容器，例如NativeArray；您不能使用其他数据类型。</p></li></ul><h5 id="访问实体组件和缓冲区数据">访问实体组件和缓冲区数据</h5><p>访问存储在查询中实体之一的组件中的数据是三个步骤的过程：</p><p>首先，您必须在作业结构上定义一个 ComponentTypeHandle 字段，将 T设置为组件的数据类型。例如：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public ComponentTypeHandle&lt;ObjectPosition&gt; translationTypeHandle;</code></pre></div></figure><br />接下来，您在作业的 Execute方法中使用此句柄字段来访问包含该类型组件数据的数组（作为NativeArray）。该数组包含批次中每个实体的一个元素：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">NativeArray&lt;ObjectPosition&gt; translations &#x3D; batchInChunk.GetNativeArray(translationTypeHandle);</code></pre></div></figure><br />最后，当您安排作业时（在系统的 OnUpdate 方法中，您使用ComponentSystemBase.GetComponentTypeHandle函数为类型句柄字段分配一个值：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; &quot;this&quot; is your &#96;SystemBase&#96; subclassupdateFromVelocityJob.translationTypeHandle &#x3D; this.GetComponentTypeHandle&lt;ObjectPosition&gt;(false);</code></pre></div></figure><br />每次安排作业时，始终设置作业的组件句柄字段。不要缓存类型句柄并在以后使用它。</p><p>批次中的每个组件数据数组都是对齐的，以便给定索引对应于所有数组中的相同实体。换句话说，如果您的作业使用一个实体的两个组件，请在两个数据数组中使用相同的数组索引来访问同一实体的数据。</p><p>您可以使用 ComponentTypeHandle 变量来访问您未包含在 EntityQuery中的组件类型。但是，您必须检查以确保当前批次包含该组件，然后再尝试访问它。使用Has 函数检查当前批次是否包含特定组件类型：</p><p>ComponentTypeHandle 字段是 ECS作业安全系统的一部分，可防止在读取和写入作业中的数据时出现竞争条件。始终设置GetComponentTypeHandle 函数的 isReadOnly参数以准确反映组件在作业中的访问方式。</p><h5 id="查找其他实体的数据">查找其他实体的数据</h5><p>通过 EntityQuery 和 IJobEntityBatch 作业（或Entities.ForEach）访问组件数据几乎总是访问数据的最有效方式。但是，通常情况下您需要以随机访问方式查找数据，例如，当一个实体依赖于另一个实体中的数据时。要执行这种类型的数据查找，您必须通过作业结构将不同类型的句柄传递给您的作业：</p><p>ComponentLookup – 访问具有该组件类型的任何实体的组件</p><p>BufferLookup – 访问具有该缓冲区类型的任何实体的缓冲区</p><p>这些类型为组件和缓冲区提供类似数组的接口，由 Entity对象索引。除了由于随机数据访问而相对低效之外，以这种方式查找数据还会增加您遇到工作安全系统建立的保障措施的机会。例如，如果您尝试根据另一个实体的变换设置一个实体的变换，作业安全系统无法判断这是否安全，因为您可以通过ComponentLookup对象访问所有变换。您可能正在写入您正在读取的相同数据，从而造成竞争条件。</p><p>要使用 ComponentLookup 和 BufferLookup，请在作业结构上声明一个类型为ComponentLookup 或 BufferLookup的字段，并在调度作业之前设置该字段的值。</p><p>有关详细信息，请参阅查找数据。</p><h5 id="访问其他数据">访问其他数据</h5><p>如果在执行作业时需要其他信息，可以在作业结构上定义一个字段，然后在Execute方法中访问该字段。您只能在安排作业时设置该值，并且该值对于所有批次都保持不变。</p><p>例如，如果您正在更新移动对象，您很可能需要传入自上次更新以来经过的时间。为此，您可以定义一个名为DeltaTime 的字段，在 OnUpdate中设置它的值并在作业执行函数中使用该值。在为新帧安排作业之前，您将在每一帧计算并为DeltaTime 字段分配一个新值。</p><h4 id="编写执行函数">编写执行函数</h4><p>编写作业结构的执行函数，将数据从输入状态转换为所需的输出状态。</p><p>IJobEntityBatch.Execute 方法的签名是：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">void Execute(ArchetypeChunk batchInChunk, int batchIndex)</code></pre></div></figure><br />对于 IJobEntityBatchWithIndex.Execute，签名是：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">void Execute(ArchetypeChunk batchInChunk, int batchIndex, int indexOfFirstEntityInQuery)</code></pre></div></figure></p><h5 id="batchinchunk-参数">batchInChunk 参数</h5><p>batchInChunk 参数提供包含此作业迭代的实体和组件的 ArchetypeChunk实例。因为一个块只能包含一个原型，所以一个块中的所有实体都具有相同的组件集。默认情况下，此对象将所有实体包含在一个块中；但是，如果您使用ScheduleParallel安排作业，则可以指定一个批次仅包含块中实体数的一小部分。</p><p>使用 batchInChunk 参数获取访问组件数据所需的 NativeArray 实例。（您还必须声明一个具有相应组件类型句柄的字段——并在安排作业时设置该字段。）</p><h5 id="batchindex-参数">batchIndex 参数</h5><p>batchIndex参数是当前批次在为当前作业创建的所有批次列表中的索引。作业中的批次不一定按索引顺序处理。</p><p>您可以在以下情况下使用 batchIndex值：您有一个NativeContainer，每个批次有一个元素，您希望将在执行函数中计算的值写入其中。使用batchIndex 作为此容器的数组索引。</p><p>如果您使用并行写入实体命令缓冲区，请将 batchIndex 参数作为 sortKey参数传递给命令缓冲区函数。</p><h5 id="indexoffirstentityinquery-参数">indexOfFirstEntityInQuery参数</h5><p>IJobEntityBatchWithIndex Execute 函数有一个名为indexofFirstEntityInQuery的附加参数。如果您将查询选择的实体描绘成一个列表，则indexOfFirstEntityInQuery将是当前批次中第一个实体的该列表的索引。作业中的批次不一定按索引顺序处理。</p><h5 id="可选组件">可选组件</h5><p>如果您的实体查询中有 Any过滤器或完全可选的组件根本没有出现在查询中，您可以使用ArchetypeChunk.Has 函数在使用之前测试当前块是否包含这些组件之一：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; If entity has Rotation and LocalToWorld components,&#x2F;&#x2F; slerp to align to the velocity vectorif (batchInChunk.Has&lt;Rotation&gt;(rotationTypeHandle) &amp;&amp;    batchInChunk.Has&lt;LocalToWorld&gt;(l2wTypeHandle))&#123;    NativeArray&lt;Rotation&gt; rotations        &#x3D; batchInChunk.GetNativeArray(rotationTypeHandle);    NativeArray&lt;LocalToWorld&gt; transforms        &#x3D; batchInChunk.GetNativeArray(l2wTypeHandle);    &#x2F;&#x2F; By putting the loop inside the check for the    &#x2F;&#x2F; optional components, we can check once per batch    &#x2F;&#x2F; rather than once per entity.    for (int i &#x3D; 0; i &lt; batchInChunk.Count; i++)    &#123;        float3 direction &#x3D; math.normalize(velocityVectors[i].Value);        float3 up &#x3D; transforms[i].Up;        quaternion rotation &#x3D; rotations[i].Value;        quaternion look &#x3D; quaternion.LookRotation(direction, up);        quaternion newRotation &#x3D; math.slerp(rotation, look, DeltaTime);        rotations[i] &#x3D; new Rotation() &#123; Value &#x3D; newRotation &#125;;    &#125;&#125;</code></pre></div></figure></p><h3 id="安排工作">安排工作</h3><p>要运行 IJobEntityBatch作业，您必须创建作业结构的实例，设置结构字段，然后安排作业。当您在<code>SystemBase</code> 实现的 OnUpdate函数中执行此操作时，系统会安排作业在每一帧运行。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">[RequireMatchingQueriesForUpdate]public partial class UpdateTranslationFromVelocitySystem : SystemBase&#123;    EntityQuery query;    protected override void OnCreate()    &#123;        &#x2F;&#x2F; Set up the query        var description &#x3D; new EntityQueryDesc()        &#123;            All &#x3D; new ComponentType[]                   &#123;ComponentType.ReadWrite&lt;ObjectPosition&gt;(),                    ComponentType.ReadOnly&lt;VelocityVector&gt;()&#125;        &#125;;        query &#x3D; this.GetEntityQuery(description);    &#125;    protected override void OnUpdate()    &#123;        &#x2F;&#x2F; Instantiate the job struct        var updateFromVelocityJob            &#x3D; new UpdateTranslationFromVelocityJob();        &#x2F;&#x2F; Set the job component type handles        &#x2F;&#x2F; &quot;this&quot; is your &#96;SystemBase&#96; subclass        updateFromVelocityJob.translationTypeHandle            &#x3D; this.GetComponentTypeHandle&lt;ObjectPosition&gt;(false);        updateFromVelocityJob.velocityTypeHandle            &#x3D; this.GetComponentTypeHandle&lt;VelocityVector&gt;(true);        &#x2F;&#x2F; Set other data need in job, such as time        updateFromVelocityJob.DeltaTime &#x3D; World.Time.DeltaTime;        &#x2F;&#x2F; Schedule the job        this.Dependency            &#x3D; updateFromVelocityJob.ScheduleParallel(query, this.Dependency);    &#125;&#125;</code></pre></div></figure><br />当您调用 GetComponentTypeHandle函数来设置组件类型变量时，请确保将作业读取但不写入的组件的 isReadOnly参数设置为 true。正确设置这些参数会对 ECS框架安排作业的效率产生重大影响。这些访问模式设置必须与其在结构定义和EntityQuery 中的等效设置相匹配。</p><p>不要在系统类变量中缓存 GetComponentTypeHandle的返回值。您必须在每次系统运行时调用该函数，并将更新后的值传递给作业。</p><h4 id="调度选项">调度选项</h4><p>您可以在安排作业时通过选择适当的功能来控制作业的执行方式：</p><ul><li><p>运行——立即在当前（主）线程上执行作业。 Run还会完成当前作业所依赖的任何计划作业。批量大小始终为1（整个块）。</p></li><li><p>Schedule——安排作业在当前作业所依赖的任何计划作业之后在工作线程上运行。为实体查询选择的每个块调用一次作业执行函数。块按顺序处理。批量大小始终为1。</p></li><li><p>ScheduleParallel——与 Schedule类似，不同之处在于您可以指定批处理大小，并且这些批处理是并行处理的（假设工作线程可用）而不是顺序处理。</p></li></ul><h4 id="设置批量大小">设置批量大小</h4><p>要设置批量大小，请使用 ScheduleParallel 方法来安排作业并将batchesPerChunk 参数设置为正整数。使用值 1将批处理大小设置为完整块。</p><p>用于调度作业的查询选择的每个块都分为 batchesPerChunk指定的批次数。来自同一块的每个批次包含大致相同数量的实体；然而，来自不同块的批次可能包含非常不同数量的实体。最大批处理大小为1，这意味着每个块中的所有实体都在对 Execute函数的一次调用中一起处理。来自不同块的实体永远不能包含在同一批中。</p><div class="note note-info">            <p>通常，使用 batchesPerChunk 设置为 1 来在对 Execute的单个调用中处理块中的所有实体是最有效的。然而，情况并非总是如此。例如，如果您的Execute函数执行的实体数量较少且算法成本较高，则可以通过使用较小的实体批次从并行处理中获得额外的好处。</p>          </div><h3 id="跳过实体不变的块">跳过实体不变的块</h3><p>如果您只需要在组件值更改时更新实体，则可以将该组件类型添加到为作业选择实体和块的EntityQuery的更改过滤器中。例如，如果您有一个系统读取两个组件并且只需要在前两个组件中的一个发生更改时更新第三个组件，则可以按如下方式使用EntityQuery：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">EntityQuery query;protected override void OnCreate()&#123;    query &#x3D; GetEntityQuery(        new ComponentType[]        &#123;            ComponentType.ReadOnly&lt;InputA&gt;(),            ComponentType.ReadOnly&lt;InputB&gt;(),            ComponentType.ReadWrite&lt;Output&gt;()        &#125;    );    query.SetChangedVersionFilter(            new ComponentType[]            &#123;                typeof(InputA),                typeof(InputB)            &#125;        );&#125;</code></pre></div></figure><br />EntityQuery 更改过滤器最多支持两个组件。如果您想检查更多或者您没有使用EntityQuery，您可以手动进行检查。要进行此检查，请使用ArchetypeChunk.DidChange 函数将组件的块更改版本与系统的LastSystemVersion 进行比较。如果此函数返回false，则您可以完全跳过当前块，因为自上次系统运行以来该类型的组件均未更改。</p><p>您必须使用结构字段将 LastSystemVersion从系统传递到作业中，如下所示：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">struct UpdateOnChangeJob : IJobEntityBatch&#123;    public ComponentTypeHandle&lt;InputA&gt; InputATypeHandle;    public ComponentTypeHandle&lt;InputB&gt; InputBTypeHandle;    [ReadOnly] public ComponentTypeHandle&lt;Output&gt; OutputTypeHandle;    public uint LastSystemVersion;    [BurstCompile]    public void Execute(ArchetypeChunk batchInChunk, int batchIndex)    &#123;        var inputAChanged &#x3D; batchInChunk.DidChange(InputATypeHandle, LastSystemVersion);        var inputBChanged &#x3D; batchInChunk.DidChange(InputBTypeHandle, LastSystemVersion);        &#x2F;&#x2F; If neither component changed, skip the current batch        if (!(inputAChanged || inputBChanged))            return;        var inputAs &#x3D; batchInChunk.GetNativeArray(InputATypeHandle);        var inputBs &#x3D; batchInChunk.GetNativeArray(InputBTypeHandle);        var outputs &#x3D; batchInChunk.GetNativeArray(OutputTypeHandle);        for (var i &#x3D; 0; i &lt; outputs.Length; i++)        &#123;            outputs[i] &#x3D; new Output &#123; Value &#x3D; inputAs[i].Value + inputBs[i].Value &#125;;        &#125;    &#125;&#125;</code></pre></div></figure><br />与所有作业结构字段一样，您必须在安排作业之前分配其值：</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">[RequireMatchingQueriesForUpdate]public partial class UpdateDataOnChangeSystem : &#96;SystemBase&#96; &#123;    EntityQuery query;    protected override void OnUpdate()    &#123;        var job &#x3D; new UpdateOnChangeJob();        job.LastSystemVersion &#x3D; this.LastSystemVersion;        job.InputATypeHandle &#x3D; GetComponentTypeHandle&lt;InputA&gt;(true);        job.InputBTypeHandle &#x3D; GetComponentTypeHandle&lt;InputB&gt;(true);        job.OutputTypeHandle &#x3D; GetComponentTypeHandle&lt;Output&gt;(false);        this.Dependency &#x3D; job.ScheduleParallel(query, this.Dependency);    &#125;    protected override void OnCreate()    &#123;        query &#x3D; GetEntityQuery(            new ComponentType[]            &#123;                ComponentType.ReadOnly&lt;InputA&gt;(),                ComponentType.ReadOnly&lt;InputB&gt;(),                ComponentType.ReadWrite&lt;Output&gt;()            &#125;        );    &#125;&#125;</code></pre></div></figure><div class="note note-info">            <p>为了提高效率，更改版本适用于整个块而不是单个实体。如果另一个能够写入该类型组件的作业访问块，则ECS 会增加该组件的更改版本，并且 DidChange 函数返回true。即使声明对组件的写访问权限的作业实际上并未更改组件值，ECS也会增加更改版本。（这是在读取组件数据而不更新它时应始终只读的原因之一。）</p>          </div><h2 id="手动迭代数据">手动迭代数据</h2><p>如果您需要以一种不适合迭代 EntityQuery中所有块的简化模型的方式管理块，您可以在nativearray中显式手动请求所有原型块，并使用 IJobParallelFor等作业处理它们.下面是一个例子：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public class RotationSpeedSystem : SystemBase&#123;   [BurstCompile]   struct RotationSpeedJob : IJobParallelFor   &#123;       [DeallocateOnJobCompletion] public NativeArray&lt;ArchetypeChunk&gt; Chunks;       public ArchetypeChunkComponentType&lt;RotationQuaternion&gt; RotationType;       [ReadOnly] public ArchetypeChunkComponentType&lt;RotationSpeed&gt; RotationSpeedType;       public float DeltaTime;       public void Execute(int chunkIndex)       &#123;           var chunk &#x3D; Chunks[chunkIndex];           var chunkRotation &#x3D; chunk.GetNativeArray(RotationType);           var chunkSpeed &#x3D; chunk.GetNativeArray(RotationSpeedType);           var instanceCount &#x3D; chunk.Count;           for (int i &#x3D; 0; i &lt; instanceCount; i++)           &#123;               var rotation &#x3D; chunkRotation[i];               var speed &#x3D; chunkSpeed[i];               rotation.Value &#x3D; math.mul(math.normalize(rotation.Value), quaternion.AxisAngle(math.up(), speed.RadiansPerSecond * DeltaTime));               chunkRotation[i] &#x3D; rotation;           &#125;       &#125;   &#125;   EntityQuery m_Query;      protected override void OnCreate()   &#123;       var queryDesc &#x3D; new EntityQueryDesc       &#123;           All &#x3D; new ComponentType[]&#123; typeof(RotationQuaternion), ComponentType.ReadOnly&lt;RotationSpeed&gt;() &#125;       &#125;;       m_Query &#x3D; GetEntityQuery(queryDesc);   &#125;   protected override void OnUpdate()   &#123;       var rotationType &#x3D; GetArchetypeChunkComponentType&lt;RotationQuaternion&gt;();       var rotationSpeedType &#x3D; GetArchetypeChunkComponentType&lt;RotationSpeed&gt;(true);       var chunks &#x3D; m_Query.ToArchetypeChunkArray(Allocator.TempJob);       var rotationsSpeedJob &#x3D; new RotationSpeedJob       &#123;           Chunks &#x3D; chunks,           RotationType &#x3D; rotationType,           RotationSpeedType &#x3D; rotationSpeedType,           DeltaTime &#x3D; Time.deltaTime       &#125;;       this.Dependency rotationsSpeedJob.Schedule(chunks.Length,32, this.Dependency);   &#125;&#125;</code></pre></div></figure></p><h3 id="如何手动迭代数据">如何手动迭代数据</h3><p>您可以使用 EntityManager类手动遍历实体或原型块，但这效率不高。您应该只使用这些迭代方法来测试或调试您的代码，或者在您拥有一组受控实体的孤立世界中。</p><p>例如，以下代码片段遍历活动世界中的所有实体：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">var entityManager &#x3D; World.Active.EntityManager;var allEntities &#x3D; entityManager.GetAllEntities();foreach (var entity in allEntities)&#123;   &#x2F;&#x2F;...&#125;allEntities.Dispose();</code></pre></div></figure><br />此代码段遍历活动世界中的所有块：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">var entityManager &#x3D; World.Active.EntityManager;var allChunks &#x3D; entityManager.GetAllChunks();foreach (var chunk in allChunks)&#123;   &#x2F;&#x2F;...&#125;allChunks.Dispose();</code></pre></div></figure></p><h1 id="系统更新顺序">系统更新顺序</h1><p>要指定系统的更新顺序，您可以使用 <code>ComponentSystemGroup</code>类。要将系统置于组中，请在系统的类声明中使用 <code>UpdateInGroup</code>属性。然后，您可以使用 <code>UpdateBefore</code> 或<code>UpdateAfter</code> 属性来指定系统必须更新的顺序。</p><p>有一组默认系统组，您可以使用它们在框架的正确阶段更新系统。您可以将一个组嵌套在另一个组中，以便您组中的所有系统都在正确的阶段更新，并根据其组内的顺序进行更新。</p><h2 id="组件系统组">组件系统组</h2><p><code>ComponentSystemGroup</code> 类表示 Unity必须按特定顺序一起更新的相关组件系统的列表。<code>ComponentSystemGroup</code> 继承自<code>ComponentSystemBase</code>，因此您可以相对于其他系统对其进行排序，并且它具有<code>OnUpdate()</code> 方法。这也意味着您可以将一个<code>ComponentSystemGroup</code> 嵌套在另一个<code>ComponentSystemGroup</code> 中，并形成层次结构。</p><p>默认情况下，当您在 <code>ComponentSystemGroup</code> 中调用<code>Update()</code>方法时，它会在其已排序的成员系统列表中的每个系统上调用<code>Update()</code>。如果任何成员系统是系统组，它们将递归更新自己的成员。生成的系统排序遵循树的深度优先遍历。</p><h2 id="系统排序属性">系统排序属性</h2><p>您可以在系统上使用以下属性来确定其更新顺序：</p><table><thead><tr class="header"><th>属性</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>UpdateInGroup</code></td><td>指定此系统应属于的<code>ComponentSystemGroup</code>。如果不设置该属性，Unity会自动将其添加到默认世界的 <code>SimulationSystemGroup</code>中。有关详细信息，请参阅默认系统组部分。</td></tr><tr class="even"><td><code>UpdateBefore</code> <code>UpdateAfter</code></td><td>排序系统相对于其他系统。为这些属性指定的系统类型必须是同一组的成员。Unity 在包含两个系统的适当的最深组中处理跨组边界的排序。例如，如果<code>CarSystem</code> 在 <code>CarGroup</code> 中，而<code>TruckSystem</code> 在 <code>TruckGroup</code> 中，并且<code>CarGroup</code> 和 <code>TruckGroup</code> 都是<code>VehicleGroup</code> 的成员，那么 <code>CarGroup</code> 和<code>TruckGroup</code> 的顺序隐式决定了 <code>CarSystem</code> 和<code>TruckSystem</code> 的相对顺序。您无需明确订购系统。</td></tr><tr class="odd"><td><code>DisableAutoCreation</code></td><td>阻止 Unity在默认世界初始化期间创建系统。您必须明确地创建和更新系统。但是，您可以将带有此标记的系统添加到<code>ComponentSystemGroup</code>的更新列表中，它会像该列表中的其他系统一样自动更新。</td></tr></tbody></table><p>如果您将 <code>DisableAutoCreation</code>属性添加到组件系统或系统组，Unity不会创建它或将其添加到默认系统组。要手动创建系统，请使用<code>World.GetOrCreateSystem&lt;MySystem&gt;()</code> 并从主线程调用<code>MySystem.Update()</code> 来更新它。您可以使用它在 Unity播放器循环中的其他位置插入系统，例如，如果您有一个应该在帧中稍后或更早运行的系统。</p><h2 id="默认系统组">默认系统组</h2><p>默认世界包含 <code>ComponentSystemGroup</code> 实例的层次结构。 Unity播放器循环中有三个根级系统组：</p><ul><li><code>InitializationSystemGroup</code>：在播放器循环的初始化阶段结束时更新。</li><li><code>SimulationSystemGroup</code>：在播放器循环的更新阶段结束时更新。</li><li><code>PresentationSystemGroup</code>：在播放器循环的<code>PreLateUpdate</code> 阶段结束时更新。</li></ul><p>默认系统组也有一些预定义的成员系统：</p><p><strong>InitializationSystemGroup</strong>:</p><ul><li>BeginInitializationEntityCommandBufferSystem</li><li>CopyInitialTransformFromGameObjectSystem</li><li>SubSceneLiveConversionSystem</li><li>SubSceneStreamingSystem</li><li>EndInitializationEntityCommandBufferSystem</li></ul><p><strong>SimulationSystemGroup</strong>:</p><ul><li>BeginSimulationEntityCommandBufferSystem</li><li>TransformSystemGroup<ul><li>ParentSystem</li><li>CopyTransformFromGameObjectSystem</li><li>TRSToLocalToWorldSystem</li><li>TRSToLocalToParentSystem</li><li>LocalToParentSystem</li><li>CopyTransformToGameObjectSystem</li></ul></li><li>LateSimulationSystemGroup</li><li>EndSimulationEntityCommandBufferSystem</li></ul><p><strong>PresentationSystemGroup</strong>:</p><ul><li>BeginPresentationEntityCommandBufferSystem</li><li>CreateMissingRenderBoundsFromMeshRenderer</li><li>RenderingSystemBootstrap</li><li>RenderBoundsUpdateSystem</li><li>RenderMeshSystem</li><li>LODGroupSystemV1</li><li>LodRequirementsUpdateSystem</li><li>EndPresentationEntityCommandBufferSystem</li></ul><p>请注意，此列表的具体内容可能会发生变化。</p><h2 id="多个世界">多个世界</h2><p>您可以创建多个世界，也可以在多个世界中实例化相同的组件系统类。您还可以从更新顺序中的不同点以不同的速率更新每个实例。</p><p>您无法手动更新给定世界中的每个系统，但您可以控制在哪个世界中创建哪些系统，以及将它们添加到哪些现有系统组中。</p><p>例如，您可以创建一个实例化 <code>SystemX</code> 和<code>SystemY</code> 的自定义世界，并将 <code>SystemX</code>添加到默认世界的 <code>SimulationSystemGroup</code>，并将<code>SystemY</code> 添加到默认世界的<code>PresentationSystemGroup</code>。这些系统可以像往常一样相对于它们的同级组对自己进行排序，Unity会更新它们以及相应的组。</p><p>您还可以使用 <code>ICustomBootstrap</code>接口来管理多个世界中的系统：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public interface ICustomBootstrap&#123;    &#x2F;&#x2F; 返回应由默认引导程序处理的系统。    &#x2F;&#x2F; 如果返回 null，则根本不会创建默认世界。    &#x2F;&#x2F; 空列表创建默认世界和入口点    List&lt;Type&gt; Initialize(List&lt;Type&gt; systems);&#125;</code></pre></div></figure><br />当您实现此接口时，它会在默认世界初始化之前将组件系统类型的完整列表传递给<code>Initialize()</code>方法。自定义引导程序可以遍历此列表并在您定义的世界中创建系统。您可以从<code>Initialize()</code> 方法返回系统列表，Unity创建它们作为默认世界初始化的一部分。</p><p>例如，这是自定义 <code>MyCustomBootstrap.Initialize()</code>实现的典型过程：</p><ol type="1"><li>创建任何其他世界及其顶级 <code>ComponentSystemGroups</code>。</li><li>对于系统类型列表中的每个类型：<ol type="1"><li>向上搜索 <code>ComponentSystemGroup</code>层次结构以找到此系统类型的顶级组。</li><li>如果它是在步骤 1 中创建的组之一，则在该世界中创建系统并使用<code>group.AddSystemToUpdateList()</code> 将其添加到层次结构中。</li><li>如果不是，则将此类型附加到列表以返回到<code>DefaultWorldInitialization</code>。</li></ol></li><li>在新的顶级组上调用 <code>group.SortSystemUpdateList()</code>。<ol type="1"><li>可选择将它们添加到默认世界组之一</li></ol></li><li>将未处理系统的列表返回给<code>DefaultWorldInitialization</code>。</li></ol><div class="note note-info">            <p>ECS 框架通过反射找到您的 <code>ICustomBootstrap</code> 实现。</p>          </div><h1 id="使用作业在多个线程上调度数据">使用作业在多个线程上调度数据</h1><p>实体包和 Unity 的 DOTS 架构广泛使用 C#作业系统。只要有可能，您应该在系统代码中使用作业。</p><p><code>SystemBase</code> 类提供 <code>Entities.ForEach</code> 和<code>Job.WithCode</code>以将应用程序的逻辑实现为多线程代码。在更复杂的情况下，您可以使用<code>IJobEntityBatch</code> 的 <code>Schedule()</code> 和<code>ScheduleParallel()</code> 方法在主线程之外转换数据。<code>Entities.ForEach</code>使用起来最简单，通常需要较少的代码来实现。</p><p>ECS 按照您的系统所在的顺序在主线程上安排作业。当您安排作业时，ECS会跟踪哪些作业读取和写入哪些组件。读取组件的作业依赖于写入同一组件的任何先前计划的作业，反之亦然。作业调度程序使用作业依赖关系来确定哪些作业可以并行运行，哪些作业必须按顺序运行。</p><p>例如，以下系统更新位置：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using Unity.Burst;using Unity.Collections;using Unity.Entities;using Unity.Jobs;using Unity.Transforms;public class MovementSpeedSystem : SystemBase&#123;    &#x2F;&#x2F; OnUpdate runs on the main thread.    protected override void OnUpdate()    &#123;        Entities            .ForEach((ref Translation position, in MovementSpeed speed) &#x3D;&gt;                &#123;                    float3 displacement &#x3D; speed.Value * dt;                    position &#x3D; new Translation()&#123;                            Value &#x3D; position.Value + displacement                        &#125;;                &#125;)            .ScheduleParallel();    &#125;&#125;</code></pre></div></figure></p><h2 id="工作扩展">工作扩展</h2><p>Unity C#作业系统允许您在多个线程上运行代码。该系统提供调度、并行处理和多线程安全。作业系统是一个核心Unity 模块，它提供通用接口和类来创建和运行作业，无论您是否使用 Entities包。</p><p>这些接口包括：</p><ul><li><code>IJob</code>：创建一个在任何线程或内核上运行的作业，由作业系统调度程序确定。</li><li><code>IJobParallelFor</code>：创建一个可以在多个线程上并行运行的作业，以处理<code>NativeContainer</code> 的元素。</li><li><code>IJobExtensions</code>：提供运行 <code>IJob</code>作业的扩展方法。</li><li><code>IJobParallelForExtensions</code>：提供运行<code>IJobParallelFor</code> 作业的扩展方法。</li><li><code>JobHandle</code>：访问计划作业的句柄。您还可以使用<code>JobHandle</code> 实例来指定作业之间的依赖关系。</li></ul><p>有关作业系统的概述，请参阅 Unity 用户手册中的 C# 作业系统。</p><p>Jobs 包扩展了作业系统以支持 ECS。它包含：</p><ul><li><code>IJobParallelForDeferExtensions</code></li><li><code>IJobFilter</code></li><li><code>JobParallelIndexListExtensions</code></li><li><code>Job​Struct​Produce&lt;T&gt;</code></li></ul><h2 id="通用职位">通用职位</h2><p>在 C#中，您可以使用继承和接口使一段代码适用于一系列类型。例如：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 该方法不仅限于一种输入，而是任何实现 IBlendable 的类型。void foo(IBlendable a) &#123;...&#125;</code></pre></div></figure><br />在 Burst 编译器使用的高性能 C# (HPC#)中，您不能使用托管类型或虚拟方法调用，因此泛型是使一段代码在一系列类型上运行的选项：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 他的方法可以对任何 IBlendable 结构进行操作（并且可以调用IBlendable 方法），但不需要托管对象或虚拟方法调用。void foo&lt;T&gt;(T a) where T : struct, IBlendable &#123;...&#125;</code></pre></div></figure><br />您必须在 HPC#中编写作业，因此对于在一系列类型上运行的作业，它必须是通用的：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">[BurstCompile()]public struct BlendJob&lt;T&gt; : IJob    where T : struct, IBlendable&#123;    public NativeReference&lt;T&gt; blendable;    public void Execute()     &#123;        var val &#x3D; blendable.Value;        val.Blend();        blendable.Value &#x3D; val;    &#125;&#125;</code></pre></div></figure></p><h3 id="从-burst-编译代码中调度通用作业">从 Burst编译代码中调度通用作业</h3><p>要从 Burst编译代码安排通用作业，您需要作业具体专业化的反射数据。不幸的是，Unity不会为所有具体的特化自动生成此反射，因此在某些情况下您必须手动注册它们：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 此程序集属性允许同一程序集中的突发编译代码为 MyJob 安排具体的专业化 &lt;int, float&gt;。[assembly: RegisterGenericJobType(typeof(MyJob&lt;int, float&gt;))]</code></pre></div></figure><br />如果您尝试安排未在程序集中注册具体专业化的作业，则 Unity会抛出异常。</p><p>注册类型的程序集无关紧要。例如，如果一个作业类型只在程序集 Foo中注册，您也可以在程序集 Bar 中安排它。</p><p>如果您多次重复注册相同的具体专业化，则不会将其视为错误。</p><h3 id="具体作业类型的自动注册">具体作业类型的自动注册</h3><p>当您直接实例化通用作业的具体特化时，Unity会自动在程序集中注册该特化：</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; Registers specialization &lt;int, float&gt; for MyJob in the assembly.var job &#x3D; new MyJob&lt;int, float&gt;();</code></pre></div></figure><p>但是，在间接实例化具体特化时，Unity 不会自动注册它：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">void makeJob&lt;T&gt;()&#123;    new MyJob&lt;T, float&gt;().Schedule();   &#125;void foo()&#123;    makeJob&lt;int&gt;();    &#x2F;&#x2F; does NOT register MyJob&lt;int, float&gt;&#125;</code></pre></div></figure><br />但是，如果您将通用作业作为返回类型或输出参数包含在签名中，则 Unity会自动注册它：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">MyJob&lt;T, float&gt; makeJob&lt;T&gt;()&#123;    var j &#x3D; new MyJob&lt;T, float&gt;()    j.Schedule();       return j;&#125;void foo()&#123;    makeJob&lt;int&gt;();    &#x2F;&#x2F; registers MyJob&lt;int, float&gt;&#125;</code></pre></div></figure><br />您可以通过多级通用方法调用使用此间接注册作品：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">MyJob&lt;T, float&gt; makeJob&lt;T&gt;()&#123;    var j &#x3D; new MyJob&lt;T, float&gt;()    j.Schedule();       return j;&#125;void foo&lt;T&gt;()&#123;    makeJob&lt;T&gt;();    &#125;void bar()&#123;    foo&lt;int&gt;();       &#x2F;&#x2F; registers MyJob&lt;int, float&gt;&#125;</code></pre></div></figure><br />您还可以将通用作业嵌套在另一个类或结构中：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">struct BlendJobWrapper&lt;T&gt; where T : struct, IBlendable&#123;    public T blendable;    [BurstCompile()]    public struct BlendJob : IJob    &#123;        public T blendable;        public void Execute() &#123;...&#125;    &#125;    public JobHandle Schedule(JobHandle dep &#x3D; new JobHandle())    &#123;        return new BlendJob &#123; blendable &#x3D; blendable &#125;.Schedule(dep);    &#125;&#125;</code></pre></div></figure><br />在前面的示例中，如果 <code>BlendJobWrapper&lt;foo&gt;</code>是自动或手动注册的，那么 <code>BlendJob&lt;foo&gt;</code>也会有效注册。仅围绕一个通用作业的包装器类型并不能解决任何问题，但是当您同时使用多个通用作业时，这些包装器类型允许更优雅的作业创建和调度。</p><h3 id="作业化分拣">作业化分拣</h3><p><code>NativeSortExtension</code>类具有排序方法，包括使用作业进行排序的方法：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public unsafe static JobHandle Sort&lt;T, U&gt;(T* array, int length, U comp, JobHandle deps)    where T : unmanaged    where U : IComparer&lt;T&gt;&#123;    if (length &#x3D;&#x3D; 0)        return inputDeps;    var segmentSortJob &#x3D; new SegmentSort&lt;T, U&gt; &#123; Data &#x3D; array, Comp &#x3D; comp, Length &#x3D; length, SegmentWidth &#x3D; 1024 &#125;;    var segmentSortMergeJob &#x3D; new SegmentSortMerge&lt;T, U&gt; &#123; Data &#x3D; array, Comp &#x3D; comp, Length &#x3D; length, SegmentWidth &#x3D; 1024 &#125;;    var segmentCount &#x3D; (length + 1023) &#x2F; 1024;    var workerSegmentCount &#x3D; segmentCount &#x2F; math.max(1, JobsUtility.MaxJobThreadCount);    var handle &#x3D; segmentSortJob.Schedule(segmentCount, workerSegmentCount, deps);    return segmentSortMergeJob.Schedule(segmentSortJobHandle);&#125;</code></pre></div></figure><br />在此示例中，排序分为两个作业：第一个作业将数组拆分为多个子部分，然后分别对它们进行并行排序。第二个作业等待第一个，然后将这些排序的子部分合并为最终的排序结果。</p><p>但是，此方法不会自动注册两个通用作业 SegmentSort 和 SegmentSortMerge的具体特化，因为这两种类型都未用作方法的返回类型或输出参数。</p><p>一种解决方案是将两个作业都放入参数中：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public unsafe static JobHandle Sort&lt;T, U&gt;(T* array, int length, U comp, JobHandle deps        out SegmentSort&lt;T, U&gt; segmentSortJob, out SegmentSortMerge&lt;T, U&gt; segmentSortMergeJob)    where T : unmanaged    where U : IComparer&lt;T&gt;&#123;    if (length &#x3D;&#x3D; 0)        return inputDeps;    segmentSortJob &#x3D; new SegmentSort&lt;T, U&gt; &#123; Data &#x3D; array, Comp &#x3D; comp, Length &#x3D; length, SegmentWidth &#x3D; 1024 &#125;;    segmentSortMergeJob &#x3D; new SegmentSortMerge&lt;T, U&gt; &#123; Data &#x3D; array, Comp &#x3D; comp, Length &#x3D; length, SegmentWidth &#x3D; 1024 &#125;;    var segmentCount &#x3D; (length + 1023) &#x2F; 1024;    var workerSegmentCount &#x3D; segmentCount &#x2F; math.max(1, JobsUtility.MaxJobThreadCount);    var handle &#x3D; segmentSortJob.Schedule(segmentCount, workerSegmentCount, deps);    return segmentSortMergeJob.Schedule(segmentSortJobHandle);&#125;</code></pre></div></figure><br />然而，这解决了注册问题，但是您随后必须传递参数以获得您可能不想要的两个作业结构。</p><p>更好的解决方案是将两种作业类型包装在一个包装器类型中：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">unsafe struct SortJob&lt;T, U&gt; :    where T : unamanged    where U : IComparer&lt;T&gt;&#123;    public T* data;    public U comparer;    public int length;    unsafe struct SegmentSort : IJobParallelFor    &#123;        [NativeDisableUnsafePtrRestriction]        public T* data;        public U comp;        public int length;        public int segmentWidth;        public void Execute(int index) &#123;...&#125;    &#125;    unsafe struct SegmentSortMerge : IJob    &#123;        [NativeDisableUnsafePtrRestriction]        public T* data;        public U comp;        public int length;        public int segmentWidth;        public void Execute() &#123;...&#125;    &#125;    public JobHandle Schedule(JobHandle dep &#x3D; new JobHandle())    &#123;        if (length &#x3D;&#x3D; 0)            return inputDeps;        var segmentSortJob &#x3D; new SegmentSort&lt;T, U&gt; &#123; Data &#x3D; array, Comp &#x3D; comp, Length &#x3D; length, SegmentWidth &#x3D; 1024 &#125;;        var segmentSortMergeJob &#x3D; new SegmentSortMerge&lt;T, U&gt; &#123; Data &#x3D; array, Comp &#x3D; comp, Length &#x3D; length, SegmentWidth &#x3D; 1024 &#125;;        var segmentCount &#x3D; (length + 1023) &#x2F; 1024;        var workerSegmentCount &#x3D; segmentCount &#x2F; math.max(1, JobsUtility.MaxJobThreadCount);        var handle &#x3D; segmentSortJob.Schedule(segmentCount, workerSegmentCount, deps);        return segmentSortMergeJob.Schedule(segmentSortJobHandle);    &#125;&#125;</code></pre></div></figure><br />在这种安排中，您可以创建 SortJob 的实例并调用其 Schedule()方法，而不是调用 Sort() 方法。通过对 SortJob进行具体实例化，您还可以自动注册所需的 SegmentSort 和 SegmentSortMerge具体特化。</p><p>这种嵌套通用作业的模式启用了一个方便的API，可以将相关的通用作业集安排在一起。</p><h2 id="使用-job.withcode-安排后台作业">使用 Job.WithCode安排后台作业</h2><p>SystemBase 类中的 Job.WithCode构造将方法作为单个后台作业运行。您还可以在主线程上运行 Job.WithCode并利用 Burst 编译来加快执行速度。</p><h3 id="使用-job.withcode">使用 Job.WithCode</h3><p>以下示例使用一个 Job.WithCode lambda 表达式用随机数填充nativearray，并使用另一个作业将这些数字加在一起：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public partial class RandomSumJob : SystemBase&#123;    private uint seed &#x3D; 1;    protected override void OnUpdate()    &#123;        Random randomGen &#x3D; new Random(seed++);        NativeArray&lt;float&gt; randomNumbers            &#x3D; new NativeArray&lt;float&gt;(500, Allocator.TempJob);        Job.WithCode(() &#x3D;&gt;        &#123;            for (int i &#x3D; 0; i &lt; randomNumbers.Length; i++)            &#123;                randomNumbers[i] &#x3D; randomGen.NextFloat();            &#125;        &#125;).Schedule();        &#x2F;&#x2F; To get data out of a job, you must use a NativeArray        &#x2F;&#x2F; even if there is only one value        NativeArray&lt;float&gt; result            &#x3D; new NativeArray&lt;float&gt;(1, Allocator.TempJob);        Job.WithCode(() &#x3D;&gt;        &#123;            for (int i &#x3D; 0; i &lt; randomNumbers.Length; i++)            &#123;                result[0] +&#x3D; randomNumbers[i];            &#125;        &#125;).Schedule();        &#x2F;&#x2F; This completes the scheduled jobs to get the result immediately, but for        &#x2F;&#x2F; better efficiency you should schedule jobs early in the frame with one        &#x2F;&#x2F; system and get the results late in the frame with a different system.        this.CompleteDependency();        UnityEngine.Debug.Log(&quot;The sum of &quot;            + randomNumbers.Length + &quot; numbers is &quot; + result[0]);        randomNumbers.Dispose();        result.Dispose();    &#125;&#125;</code></pre></div></figure><br />要运行并行作业，请实施 IJobFor。您可以使用 ScheduleParallel() 在系统的OnUpdate() 函数中安排并行作业。</p><h3 id="捕获变量-1">捕获变量</h3><p>您不能将参数传递给 Job.WithCode lambda表达式或返回值。相反，您必须在系统的 OnUpdate() 函数中捕获局部变量。</p><p>如果您使用 Schedule() 来安排您的作业在 Unity的作业系统中运行，则还有其他限制：</p><ul><li>您必须将捕获的变量声明为 NativeArray、NativeContainer或 blittable类型。</li><li>要返回数据，您必须将返回值写入捕获的nativearray，即使数据是单个值也是如此。但是，如果您使用 Run()来执行作业，则可以写入任何捕获的变量。<br />Job.WithCode有一组方法将只读和安全属性应用于捕获的NativeContainer的变量。例如，您可以使用WithReadOnly 将对变量的访问限制为只读。您还可以使用WithDisposeOnCompletion 在作业完成后自动释放容器。有关详细信息，请参阅Job.WithCode 文档的捕获变量部分。</li></ul><h3 id="执行-job.withcode-lambda-表达式">执行 Job.WithCode lambda表达式</h3><p>要执行 Job.WithCode lambda 表达式，您可以使用以下命令：</p><ul><li>Schedule()：将方法作为单个非并行作业执行。安排作业在后台线程上运行代码并更好地利用所有可用的CPU 资源。您可以显式地将 JobHandle 传递给Schedule()，或者，如果您不传递任何依赖项，系统会假定当前系统的Dependency属性表示作业的依赖项。或者，如果作业没有依赖项，您可以传入一个新的JobHandle。</li><li>Run()：在主线程上执行方法。您可以 Burst 编译Job.WithCode，因此如果您使用 Run()来执行代码，即使它在主线程上运行也会更快。当你调用 Run() 时，Unity会自动完成 Job.WithCode 构造的所有依赖。</li></ul><h3 id="依赖关系-1">依赖关系</h3><p>默认情况下，系统使用其 Dependency 属性来管理其依赖项。系统按照它们在OnUpdate() 方法中出现的顺序将您创建的每个 <code>Entities.ForEach</code>和 Job.WithCode 作业添加到依赖作业句柄。</p><p>要手动管理作业依赖性，请将 JobHandle 传递给 Schedule方法，然后返回生成的依赖性。有关详细信息，请参阅依赖项 API 文档。</p><p>有关作业依赖性的一般信息，请参阅有关作业依赖性的文档。</p><h2 id="作业依赖">作业依赖</h2><p>Unity根据系统读写的ECS组件分析各个系统的数据依赖关系。如果在帧中较早更新的系统读取较晚系统写入的数据，或写入较晚系统读取的数据，则第二个系统依赖于第一个系统。为了防止竞争条件，作业调度程序确保系统依赖的所有作业在运行该系统的作业之前已经完成。</p><h3 id="作业依赖更新顺序">作业依赖更新顺序</h3><p>系统的 Dependency 属性是一个 JobHandle，表示系统的 ECS 相关依赖项。在OnUpdate() 之前，Dependency属性反映系统对先前作业的传入依赖项。默认情况下，系统会根据您在系统中安排作业时每个作业读取和写入的组件来更新依赖属性。</p><h4 id="覆盖默认顺序">覆盖默认顺序</h4><p>要覆盖此默认行为，请使用 <code>Entities.ForEach</code> 和Job.WithCode 的重载版本，它们将作业依赖项作为参数并将更新的依赖项作为JobHandle 返回。当您使用这些构造的显式版本时，ECS不会自动将作业句柄与系统的 Dependency属性组合在一起。您必须在需要时手动组合它们。</p><p>Dependency 属性不跟踪作业可能对通过 NativeArray或其他类似容器传递的数据的依赖关系。如果您在一个作业中编写NativeArray，并在另一个作业中读取该数组，则必须手动将第一个作业的JobHandle 添加为第二个作业的依赖项。您可以使用JobHandle.CombineDependencies 来执行此操作。</p><h4 id="entities.foreach-的作业依赖顺序"><code>Entities.ForEach</code>的作业依赖顺序</h4><p>当您调用 Entities.ForEach.Run() 时，作业计划程序会在开始<code>ForEach</code> 迭代之前完成系统依赖的所有计划作业。如果您还使用WithStructuralChanges()作为构造的一部分，则作业调度程序将完成所有正在运行和已调度的作业。结构更改还会使对组件数据的任何直接引用无效。有关详细信息，请参阅有关结构更改的文档。</p><h3 id="更多资源">更多资源</h3><ul><li>JobHandle 和依赖项</li><li>Unity的工作系统</li></ul><h1 id="使用-entityquery-查询数据-1">使用 EntityQuery 查询数据</h1><p>EntityQuery查找具有一组指定组件类型的原型。然后它将原型的块收集到一个系统可以处理的数组中。</p><p>例如，如果查询匹配组件类型 A 和B，则查询会收集具有这两种组件类型的所有原型的块，而不管这些原型可能具有的任何其他组件类型。因此，具有组件类型A、B 和 C 的原型将匹配查询。</p><p>您可以使用 EntityQuery 执行以下操作：</p><p>运行作业以处理选定的实体和组件<br />获取包含所有选定实体的 NativeArray<br />按组件类型获取所选组件的 NativeArray<br />EntityQuery返回的实体和组件数组是并行的。这意味着相同的索引值始终适用于任何数组中的相同实体。</p><h2 id="创建实体查询">创建实体查询</h2><p>要创建实体查询，您可以将组件类型传递给 EntityQueryBuilder帮助器类型。以下示例定义了一个 EntityQuery，它查找所有同时具有ObjectRotation 和 ObjectRotationSpeed 组件的实体：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">EntityQuery query &#x3D; new EntityQueryBuilder(Allocator.Temp)    .WithAllRW&lt;ObjectRotation&gt;()    .WithAll&lt;ObjectRotationSpeed&gt;()    .Build(this);</code></pre></div></figure><br />查询使用 EntityQueryBuilder.WithAllRW<T> 来显示系统写入ObjectRotation。如果可能，您应该始终指定只读访问权限，因为对数据的读取访问权限的限制较少。这有助于作业调度程序更有效地执行作业。</p><h3 id="指定系统选择的原型">指定系统选择的原型</h3><p>查询将仅匹配包含您指定组件的原型。可以使用三种不同的EntityQueryBuilder 方法指定组件：</p><ul><li>WithAll<T>()：这些组件是必需的。为了匹配查询，原型必须包含查询的所有必需组件。</li><li>WithAny<T>()：这些组件是可选的。为了匹配查询，原型必须至少包含一个查询的可选组件。</li><li>WithNone<T>()：排除这些组件。为了匹配查询，原型不得包含任何查询的排除组件。<br />例如，以下查询包括包含 ObjectRotation 和 ObjectRotationSpeed组件的原型，但不包括包含 Static 组件的任何原型：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">EntityQuery query &#x3D; new EntityQueryBuilder(Allocator.Temp)    .WithAllRW&lt;ObjectRotation&gt;()    .WithAll&lt;ObjectRotationSpeed&gt;()    .WithNone&lt;Static&gt;()    .Build(this);</code></pre></div></figure></li></ul><div class="note note-info">            <p>要处理可选组件，请使用 ArchetypeChunk.Has<T>方法来确定块是否包含可选组件。这是因为同一块中的所有实体都具有相同的组件，因此您只需检查每个块是否存在可选组件一次：而不是每个实体一次。</p>          </div><p>您可以使用 EntityQueryBuilder.WithOptions()来查找专门的原型。例如：</p><ul><li>IncludePrefab：包括包含 Prefab 标签组件的原型。</li><li>IncludeDisabledEntities：包括包含 Disabled 标签组件的原型。</li><li>FilterWriteGroup：仅包含 WriteGroup中明确包含在查询中的组件的实体。排除具有来自同一 WriteGroup的任何其他组件的实体。<br />有关选项的完整列表，请参阅 EntityQueryOptions。</li></ul><h4 id="按写入组过滤">按写入组过滤</h4><p>在以下示例中，LuigiComponent 和 MarioComponent 是基于CharacterComponent 组件的同一 WriteGroup 中的组件。此查询使用需要CharacterComponent 和 MarioComponent 的 FilterWriteGroup 选项：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public struct CharacterComponent : IComponentData &#123; &#125;[WriteGroup(typeof(CharacterComponent))]public struct LuigiComponent : IComponentData &#123; &#125;[WriteGroup(typeof(CharacterComponent))]public struct MarioComponent : IComponentData &#123; &#125;[RequireMatchingQueriesForUpdate]public partial class ECSSystem : SystemBase&#123;    protected override void OnCreate()    &#123;        var query &#x3D; new EntityQueryBuilder(Allocator.Temp)            .WithAllRW&lt;CharacterComponent&gt;()            .WithAll&lt;MarioComponent&gt;()            .WithOptions(EntityQueryOptions.FilterWriteGroup)            .Build(this);    &#125;    protected override void OnUpdate()    &#123;        throw new NotImplementedException();    &#125;&#125;</code></pre></div></figure><br />此查询排除任何同时具有 LuigiComponent 和 MarioComponent 的实体，因为LuigiComponent 未明确包含在查询中。</p><p>这比 None字段更有效，因为您不需要更改其他系统使用的查询，只要它们也使用写组。</p><p>您可以使用写入组来扩展现有系统。例如，如果您在另一个系统中将CharacterComponent 和 LuigiComponent定义为不受您控制的库的一部分，则可以将 MarioComponent 与 LuigiComponent放在同一写入组中，以更改 CharacterComponent的更新方式。然后，对于您添加到 MarioComponent 的任何实体，系统都会更新CharacterComponent，但原始系统不会更新它。对于没有 MarioComponent的实体，原始系统像以前一样更新CharacterComponent。有关详细信息，请参阅有关写入组的文档。</p><h2 id="定义过滤器">定义过滤器</h2><p>要进一步对实体进行排序，您可以使用过滤器根据以下内容排除实体：</p><p>共享组件过滤器：根据共享组件的特定值过滤实体集。<br />更改过滤器：根据特定组件类型的值是否已更改来过滤实体集。<br />在您对查询对象调用 ResetFilter 之前，您设置的过滤器一直有效。</p><p>要忽略查询的活动块过滤器，请使用名称以 IgnoreFilter 结尾的EntityQuery 方法。这些方法通常比过滤等效方法更有效。例如，请参阅 IsEmpty与 IsEmptyIgnoreFilter。</p><h3 id="使用共享组件过滤器">使用共享组件过滤器</h3><p>要使用共享组件筛选器，请在 EntityQuery中包含共享组件以及任何其他需要的组件，然后调用 SetSharedComponentFilter方法。然后传入包含要选择的值的相同 ISharedComponent类型的结构。所有值都必须匹配。您最多可以向过滤器添加两个不同的共享组件。</p><p>您可以随时更改筛选器，但如果您更改筛选器，它不会更改您从组ToComponentDataArray<T> 或 ToEntityArray方法接收的任何现有实体或组件数组。您必须重新创建这些数组。</p><p>以下示例定义了一个名为 SharedGrouping的共享组件和一个仅处理组字段设置为 1 的实体的系统。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">struct SharedGrouping : ISharedComponentData&#123;    public int Group;&#125;[RequireMatchingQueriesForUpdate]partial class ImpulseSystem : SystemBase&#123;    EntityQuery query;    protected override void OnCreate()    &#123;        query &#x3D; new EntityQueryBuilder(Allocator.Temp)            .WithAllRW&lt;ObjectPosition&gt;()            .WithAll&lt;Displacement, SharedGrouping&gt;()            .Build(this);    &#125;    protected override void OnUpdate()    &#123;        &#x2F;&#x2F; Only iterate over entities that have the SharedGrouping data set to 1        query.SetSharedComponentFilter(new SharedGrouping &#123; Group &#x3D; 1 &#125;);        var positions &#x3D; query.ToComponentDataArray&lt;ObjectPosition&gt;(Allocator.Temp);        var displacements &#x3D; query.ToComponentDataArray&lt;Displacement&gt;(Allocator.Temp);        for (int i &#x3D; 0; i &lt; positions.Length; i++)            positions[i] &#x3D; new ObjectPosition            &#123;                Value &#x3D; positions[i].Value + displacements[i].Value            &#125;;    &#125;&#125;</code></pre></div></figure></p><h3 id="使用更改过滤器">使用更改过滤器</h3><p>如果您只需要在组件值更改时更新实体，请使用 SetChangedVersionFilter方法将该组件添加到 EntityQuery 过滤器。例如，以下 EntityQuery仅包含来自另一个系统已写入 Translation 组件的块的实体：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">EntityQuery query;protected override void OnCreate()&#123;    query &#x3D; new EntityQueryBuilder(Allocator.Temp)        .WithAllRW&lt;LocalToWorld&gt;()        .WithAll&lt;ObjectPosition&gt;()        .Build(this);    query.SetChangedVersionFilter(typeof(ObjectPosition));&#125;</code></pre></div></figure><br />为了提高效率，更改过滤器适用于整个原型块，而不是单个实体。更改过滤器还只检查声明对组件进行写访问的系统是否已运行，而不检查它是否更改了任何数据。例如，如果可以写入该组件类型的另一个作业访问该块，则更改过滤器将包括该块中的所有实体。这就是为什么您应该始终声明对不需要修改的组件的只读访问权限。</p><h2 id="按启用组件过滤">按启用组件过滤</h2><p>启用组件允许在运行时启用和禁用单个实体上的组件。禁用实体上的组件不会将该实体移动到新的原型中，但出于EntityQuery 匹配的目的，实体将被视为没有组件。具体来说：</p><p>如果一个实体禁用了组件 T，它将不会匹配需要组件 T 的查询（使用WithAll<T>()）。<br />如果实体禁用了组件 T，它将匹配排除组件 T 的查询（使用WithNone<T>()）。<br />大多数 EntityQuery 操作（例如 ToEntityArray 和CalculateEntityCount）会自动过滤掉其可启用组件会导致它们与查询不匹配的实体。要禁用此过滤，请使用这些操作的IgnoreFilter 变体，或在查询创建时传递EntityQueryOptions.IgnoreComponentEnabledState。</p><p>有关更多详细信息，请参阅启用的组件文档。</p><h2 id="合并查询">合并查询</h2><p>要有效地将多个查询合并为一个，您可以创建一个包含多个查询描述的查询。生成的查询与匹配任何提供的查询描述的原型相匹配。本质上，组合查询匹配查询描述的并集。以下示例选择包含ObjectRotation 组件或 ObjectRotationSpeed 组件（或两者）的任何原型：</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">EntityQuery query &#x3D; new EntityQueryBuilder(Allocator.Temp)    .WithAllRW&lt;ObjectRotation&gt;()    &#x2F;&#x2F; Start a new query description    .AddAdditionalQuery()    .WithAllRW&lt;ObjectRotationSpeed&gt;()    .Build(this);</code></pre></div></figure><h2 id="执行查询">执行查询</h2><p>通常，您在安排使用它的作业时执行实体查询。您还可以调用返回实体、组件或原型块数组的EntityQuery 方法之一：</p><p>ToEntityArray：返回所选实体的数组。<br />ToComponentDataArray：返回所选实体的 T 类型组件的数组。<br />CreateArchetypeChunkArray：返回包含所选实体的所有块。因为查询对原型、共享组件值和更改过滤器进行操作，这些对于块中的所有实体都是相同的，所以存储在返回的块集中的实体集与ToEntityArray 返回的实体集相同。<br />上述方法的异步版本也可用，它安排一个作业来收集请求的数据。其中一些变体必须返回NativeList 而不是 NativeArray 才能支持可启用的组件。请参阅ToEntityListAsync、ToComponentDataListAsync 和CreateArchetypeChunkArrayAsync。</p><h2 id="编辑器中的查询">编辑器中的查询</h2><p>在编辑器中，以下图标代表查询：。当您使用特定的实体窗口和检查器时，您会看到这一点。您还可以使用“查询”窗口查看与所选查询匹配的组件和实体。</p><h1 id="使用-entitycommandbuffer-安排数据更改">使用 EntityCommandBuffer安排数据更改</h1><p>要对实体数据更改进行排队而不是立即执行更改，您可以使用EntityCommandBuffer结构，它创建一个线程安全的命令缓冲区。如果您想在作业完成时推迟任何结构更改，这将很有用。</p><h2 id="entitycommandbuffer-方法">EntityCommandBuffer 方法</h2><p>您可以使用 EntityCommandBuffer 中的方法来记录命令，这些方法反映了EntityManager 的一些方法，例如：</p><ul><li>CreateEntity(EntityArchetype)：创建具有指定原型的新实体。</li><li>DestroyEntity(Entity)：销毁实体。</li><li>SetComponent<T>(Entity, T)：为实体上类型 T 的组件设置值。</li><li>AddComponent<T>(Entity)：将类型 T 的组件添加到实体。</li><li>RemoveComponent<T>(EntityQuery)：从匹配查询的所有实体中移除类型 T的组件。<br />Unity 仅在调用主线程上的 Playback 方法时才将更改记录在EntityCommandBuffer中。如果您尝试在播放后记录任何对命令缓冲区的进一步更改，Unity会抛出异常。</li></ul><p>EntityCommandBuffer有一个作业安全句柄，类似于NativeContainer。如果您尝试对使用命令缓冲区的未完成计划作业执行以下任何操作，安全检查会抛出异常：</p><ul><li>通过其 AddComponent、Playback、Dispose 或其他方法访问EntityCommandBuffer。</li><li>安排另一个访问相同 EntityCommandBuffer的作业，除非新作业依赖于已安排的作业。</li></ul><h2 id="在单线程作业中使用-entitycommandbuffer">在单线程作业中使用EntityCommandBuffer</h2><p>Unity无法在作业中执行结构更改，因此您可以使用实体的命令缓冲区来推迟结构更改，直到Unity 完成作业。例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; ... in a system update&#x2F;&#x2F; You don&#39;t specify a size because the buffer will grow as needed.EntityCommandBuffer ecb &#x3D; new EntityCommandBuffer(Allocator.TempJob);&#x2F;&#x2F; The ECB is captured by the &#96;ForEach&#96; job.&#x2F;&#x2F; Until completed, the job owns the ECB&#39;s job safety handle.Entities    .ForEach((Entity e, in FooComp foo) &#x3D;&gt;    &#123;        if (foo.Value &gt; 0)        &#123;            &#x2F;&#x2F; Record a command that will later add            &#x2F;&#x2F; BarComp to the entity.            ecb.AddComponent&lt;BarComp&gt;(e);        &#125;    &#125;).Schedule();this.Dependency.Complete();&#x2F;&#x2F; Now that the job is completed, you can enact the changes.&#x2F;&#x2F; Note that Playback can only be called on the main thread.ecb.Playback(this.EntityManager);&#x2F;&#x2F; You are responsible for disposing of any ECB you create.ecb.Dispose();</code></pre></div></figure><h2 id="在并行作业中使用-entitycommandbuffer">在并行作业中使用EntityCommandBuffer</h2><p>如果要在并行作业中使用实体命令缓冲区，请使用EntityCommandBuffer.ParallelWriter，它以线程安全的方式并发记录到命令缓冲区：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">EntityCommandBuffer ecb &#x3D; new EntityCommandBuffer(Allocator.TempJob);&#x2F;&#x2F; Methods of this writer record commands to &#x2F;&#x2F; the EntityCommandBuffer in a thread-safe way.EntityCommandBuffer.ParallelWriter parallelEcb &#x3D; ecb.AsParallelWriter();</code></pre></div></figure></p><blockquote><p>note<br />只有记录需要线程安全才能并发。回放在主线程上始终是单线程的。</p></blockquote><h3 id="确定性回放">确定性回放</h3><p>因为命令的记录是跨线程拆分的，所以记录命令的顺序取决于作业调度，因此是不确定的。</p><p>确定性并不总是必不可少的，但产生确定性结果的代码更容易调试。还有一些网络场景需要在不同机器上获得一致的结果。但是，确定性会对性能产生影响，因此您可能需要在某些项目中接受不确定性。</p><p>您无法避免不确定的录制顺序，但可以通过以下方式确定命令的播放顺序：</p><ol type="1"><li>每个命令记录一个“排序键”int作为第一个参数传递给每个命令方法。您必须调用 lambda 参数entityInQueryIndex，否则 <code>Entities.ForEach</code> 将无法识别int。</li><li>在播放时，在执行命令之前按命令的排序键对命令进行排序。<br />只要记录的排序键独立于调度，排序就可以确定播放顺序。</li></ol><p>在并行作业中，每个实体所需的排序键是一个数字，它与作业查询中的该实体具有固定且唯一的关联。</p><p>并行作业中提供的 entityInQueryIndex值满足这些条件。在与作业查询匹配的原型块列表中，实体具有以下索引：</p><ul><li>第一个块的第一个实体有 entityInQueryIndex 0</li><li>第一个块的第二个实体有 entityInQueryIndex 1</li><li>第二个块的第一个实体有一个entityInQueryIndex，它是第一个块的计数</li><li>第三个块的第一个实体有一个entityInQueryIndex，它是前两个块的计数之和</li></ul><p>entityInQueryIndex 始终遵循此模式。</p><p>以下示例代码显示了并行作业中使用的实体命令缓冲区：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; ... in a system updateEntityCommandBuffer ecb &#x3D; new EntityCommandBuffer(Allocator.TempJob);&#x2F;&#x2F; We need to write to the ECB concurrently across threads.EntityCommandBuffer.ParallelWriter ecbParallel &#x3D; ecb.AsParallelWriter();&#x2F;&#x2F; The entityInQueryIndex is unique for each entity and will be&#x2F;&#x2F; consistent for each particular entity regardless of scheduling.Entities    .ForEach((Entity e, int entityInQueryIndex, in FooComp foo) &#x3D;&gt; &#123;        if (foo.Value &gt; 0)        &#123;            &#x2F;&#x2F; The first arg is the &#39;sort key&#39; recorded with the command.            ecbParallel.AddComponent&lt;BarComp&gt;(entityInQueryIndex, e);        &#125;    &#125;).Schedule();&#x2F;&#x2F; Playback is single-threaded as normal.this.Dependency.Complete();&#x2F;&#x2F; To ensure deterministic playback order,&#x2F;&#x2F; the commands are first sorted by their sort keys.ecb.Playback(this.EntityManager);ecb.Dispose();</code></pre></div></figure></p><h2 id="重用-entitycommandbuffer-实例">重用 EntityCommandBuffer实例</h2><p>最好的做法是为每个作业提供自己的命令缓冲区。这是因为与在单个命令缓冲区中记录相同的命令相比，将一组命令记录到多个命令缓冲区的开销很小。</p><p>但是，您可以在非并行作业中重用相同的EntityCommandBuffer，只要这些作业在调度中不重叠即可。如果您在并行作业中重复使用EntityCommandBuffer实例，这可能会导致播放中命令的意外排序顺序，除非每个作业的排序键位于不同的范围内。</p><h2 id="多重回放">多重回放</h2><p>如果多次调用 Playback 方法，它会抛出异常。为避免这种情况，请使用PlaybackPolicy.MultiPlayback 选项创建一个 EntityCommandBuffer实例：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; ... in a system updateEntityCommandBuffer ecb &#x3D;        new EntityCommandBuffer(Allocator.TempJob, PlaybackPolicy.MultiPlayback);&#x2F;&#x2F; ... record commandsecb.Playback(this.EntityManager);&#x2F;&#x2F; Additional playbacks are OK because this ECB is MultiPlayback.ecb.Playback(this.EntityManager);ecb.Dispose();</code></pre></div></figure><br />如果您想重复生成一组实体，则多重播放很有用。为此，使用EntityCommandBuffer创建并配置一组新实体，然后重复播放以重新生成另一组匹配的实体。</p><h2 id="在主线程上使用-entitycommandbuffer">在主线程上使用EntityCommandBuffer</h2><p>您可以在主线程上记录命令缓冲区更改。这在以下情况下很有用：</p><ul><li>延迟您的更改。</li><li>多次回放一组更改。</li><li>在一个统一的地方回放很多变化。这比将更改散布在框架的不同部分更有效。</li></ul><p>每个结构更改操作都会触发一个同步点，这意味着该操作必须等待部分或所有计划作业完成。如果将结构更改组合到命令缓冲区中，则帧的同步点会更少。</p><h2 id="使用-entitycommandbuffersystem-自动播放和处理命令缓冲区">使用EntityCommandBufferSystem 自动播放和处理命令缓冲区</h2><p>您可以使用 EntityCommandBufferSystem回放和处理命令缓冲区，而不是自己手动执行。去做这个：</p><ol type="1"><li>获取要进行播放的 EntityCommandBuffer 系统的实例。</li><li>通过系统创建一个 EntityCommandBuffer 实例。</li><li>安排一个将命令写入 EntityCommandBuffer 的作业。</li><li>注册系统完成的预定作业。</li></ol><p>例如：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; ... in a system&#x2F;&#x2F; Assume an EntityCommandBufferSystem exists named FooECBSystem.EntityCommandBufferSystem sys &#x3D;        this.World.GetExistingSystemManaged&lt;FooECBSystem&gt;();&#x2F;&#x2F; Create a command buffer that will be played back&#x2F;&#x2F; and disposed by MyECBSystem.EntityCommandBuffer ecb &#x3D; sys.CreateCommandBuffer();&#x2F;&#x2F; A &#96;ForEach&#96; with no argument to Schedule implicitly&#x2F;&#x2F; assigns its returned JobHandle to this.DependencyEntities    .ForEach((Entity e, in FooComp foo) &#x3D;&gt; &#123;        &#x2F;&#x2F; ... record to the ECB    &#125;).Schedule();&#x2F;&#x2F; Register the job so that it gets completed by the ECB system.sys.AddJobHandleForProducer(this.Dependency);</code></pre></div></figure></p><div class="note note-waring">            <p>不要手动回放和处置 EntityCommandBufferSystem 创建的EntityCommandBuffer。 EntityCommandBufferSystem 为您完成这两件事。</p>          </div><p>在每次更新中，一个 EntityCommandBufferSystem：</p><ol type="1"><li>完成所有已注册的作业，以确保他们已完成录制）。</li><li>以创建它们的相同顺序播放通过系统创建的所有实体命令缓冲区。</li><li>处理 EntityCommandBuffer。</li></ol><h3 id="默认-entitycommandbuffersystem-系统">默认EntityCommandBufferSystem 系统</h3><p>默认世界具有以下默认 EntityCommandBufferSystem 系统：</p><ul><li>BeginInitializationEntityCommandBufferSystem</li><li>EndInitializationEntityCommandBufferSystem</li><li>BeginSimulationEntityCommandBufferSystem</li><li>EndSimulationEntityCommandBufferSystem</li><li>BeginPresentationEntityCommandBufferSystem</li></ul><p>因为在 Unity 将渲染数据交给渲染器之后，帧中不会发生结构变化，所以没有EndPresentationEntityCommandBufferSystem 系统。您可以改用BeginInitializationEntityCommandBufferSystem：一帧的结尾是下一帧的开始。</p><p>这些更新在标准系统组的开头和结尾。有关详细信息，请参阅有关系统更新顺序的文档。</p><p>对于大多数用例，默认系统应该足够了，但如果需要，您可以创建自己的EntityCommandBufferSystem：</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; You should specify where exactly in the frame&#x2F;&#x2F; that the ECB system should update.[UpdateInGroup(typeof(SimulationSystemGroup))][UpdateAfter(typeof(FooSystem))]public class MyECBSystem : EntityCommandBufferSystem &#123;    &#x2F;&#x2F; This class is intentionally empty. There is generally no    &#x2F;&#x2F; reason to put any code in an EntityCommandBufferSystem.&#125;</code></pre></div></figure><h2 id="延迟实体">延迟实体</h2><p>EntityCommandBuffer 方法 CreateEntity 和 Instantiate记录创建实体的命令。这些方法只记录命令，不创建实体。因此，它们返回带有负索引的实体值，代表尚不存在的占位符实体。这些占位符实体值仅在同一ECB 的记录命令中有意义。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; ... in a systemEntityCommandBuffer ecb &#x3D; new EntityCommandBuffer(Allocator.TempJob);Entity placeholderEntity &#x3D; ecb.CreateEntity();&#x2F;&#x2F; Valid to use placeholderEntity in later commands of same ECB.ecb.AddComponent&lt;FooComp&gt;(placeholderEntity);&#x2F;&#x2F; The real entity is created, and&#x2F;&#x2F; FooComp is added to the real entity.ecb.Playback(this.EntityManager);&#x2F;&#x2F; Exception! The placeholderEntity has no meaning outside&#x2F;&#x2F; the ECB which created it, even after playback.this.EntityManager.AddComponent&lt;BarComp&gt;(placeholderEntity);ecb.Dispose();</code></pre></div></figure><br />AddComponent、SetComponent 或 SetBuffer 命令中记录的值可能具有 Entity字段。在回放中，Unity将这些组件或缓冲区中的任何占位符实体值重新映射到相应的实际实体。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; ... in a systemEntityCommandBuffer ecb &#x3D; new EntityCommandBuffer(Allocator.TempJob);&#x2F;&#x2F; For all entities with a FooComp component...Entities    .WithAll&lt;FooComp&gt;()    .ForEach((Entity e) &#x3D;&gt;    &#123;        &#x2F;&#x2F; In playback, an actual entity will be created        &#x2F;&#x2F; that corresponds to this placeholder entity.        Entity placeholderEntity &#x3D; ecb.CreateEntity();        &#x2F;&#x2F; (Assume BarComp has an Entity field called TargetEnt.)        BarComp bar &#x3D; new BarComp &#123; TargetEnt &#x3D; placeholderEntity &#125;;        &#x2F;&#x2F; In playback, TargetEnt will be assigned the        &#x2F;&#x2F; actual Entity that corresponds to placeholderEntity.        ecb.AddComponent(e, bar);    &#125;).Run();&#x2F;&#x2F; After playback, each entity with FooComp now has a&#x2F;&#x2F; BarComp component whose TargetEnt references a new entity.ecb.Playback(this.EntityManager);ecb.Dispose();</code></pre></div></figure></p><h2 id="在-entities.foreach-方法中使用命令缓冲区">在<code>Entities.ForEach</code> 方法中使用命令缓冲区</h2><p>要在 <code>Entities.ForEach</code> 方法中使用命令缓冲区，请将EntityCommandBuffer 参数传递给 lambda 表达式本身。仅支持一小部分EntityCommandBuffer 方法，它们具有 [SupportedInEntitiesForEach]属性：</p><ul><li>Entity Instantiate(实体实体)</li><li>void DestroyEntity(实体实体)</li><li>void AddComponent<T>(Entity e, T component) where T : unmanaged,IComponentData</li><li>void SetComponent<T>(Entity e, T component) where T : unmanaged,IComponentData</li><li>void RemoveComponent<T>(实体 e)<br />例如，以下代码执行此操作：</li></ul><ol type="1"><li>它检查每个实体以查看其 HealthLevel 是否为 0。</li><li>如果为真，它会记录一条销毁实体的命令。</li><li>它还指定 EndSimulationEntityCommandBufferSystem 应该回放命令。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public struct HealthLevel : IComponentData&#123;    public int Value;&#125;Entities    .WithDeferredPlaybackSystem&lt;EndSimulationEntityCommandBufferSystem&gt;    .ForEach(        (Entity entity, EntityCommandBuffer buffer, HealthLevel healthLevel) &#x3D;&gt;         &#123;            if (healthLevel &#x3D;&#x3D; 0)            &#123;                buffer.DestroyEntity(entity);            &#125;        &#125;    ).ScheduleParallel();</code></pre></div></figure><br />当您在 <code>ForEach()</code>函数中使用这些方法中的任何一种时，编译器会在运行时生成创建、填充、回放和处理EntityCommandBuffer 实例或 EntityCommandBuffer.ParallelWriter实例所需的代码（如果调用了 ScheduleParallel()） .</li></ol><p>在 <code>ForEach()</code> 之外调用这些方法会导致异常。</p><h3 id="在-entities.foreach-中回放-entitycommandbuffer">在<code>Entities.ForEach</code> 中回放 EntityCommandBuffer</h3><p>要将 EntityCommandBuffer 参数传递给 <code>ForEach()</code>函数，您还必须调用以下方法之一来指定何时回放命令：</p><ul><li>延迟回放：调用 WithDeferredPlaybackSystem<T>()，其中 T标识回放命令的实体命令缓冲区系统。它必须是从 EntityCommandBufferSystem派生的类型。</li><li>立即回放：在 <code>ForEach()</code> 函数完成所有迭代后立即调用WithImmediatePlayback() 执行实体命令。您只能将 WithImmediatePlayback()与 Run() 一起使用。</li></ul><p>编译器自动生成代码来创建和处理任何 EntityCommandBuffer 实例。</p><h1 id="查找任意数据">查找任意数据</h1><p>访问和修改数据的最有效方法是使用具有实体查询和作业的系统。这以最高效的方式利用CPU资源，内存缓存未命中率最低。理想情况下，您应该使用最有效、最快的路径来执行大量数据转换。但是，有时您可能需要在程序的任意位置访问任意实体的任意组件。</p><p>您可以在实体的 IComponentData及其动态缓冲区中查找数据。您查找数据的方式取决于您的代码是使用Entities.ForEach、IJobEntityBatch作业，还是在系统中执行的主线程上的其他一些方法。</p><h2 id="在系统中查找实体数据">在系统中查找实体数据</h2><p>要从系统的 <code>Entities.ForEach</code> 或 Job.WithCode方法中查找存储在任意实体组件中的数据，请使用 GetComponent<T>(Entity)</p><p>例如，以下代码使用 GetComponent<T>(Entity) 获取 Target组件，该组件具有标识要定位的实体的实体字段。然后它将跟踪实体旋转到它们的目标：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">[RequireMatchingQueriesForUpdate]public partial class TrackingSystem : SystemBase&#123;    protected override void OnUpdate()    &#123;        float deltaTime &#x3D; SystemAPI.Time.DeltaTime;        Entities            .ForEach((ref Rotation orientation,            in LocalToWorld transform,            in Target target) &#x3D;&gt;            &#123;                &#x2F;&#x2F; Check to make sure the target Entity still exists and has                &#x2F;&#x2F; the needed component                if (!HasComponent&lt;LocalToWorld&gt;(target.entity))                    return;                &#x2F;&#x2F; Look up the entity data                LocalToWorld targetTransform &#x3D; GetComponent&lt;LocalToWorld&gt;(target.entity);                float3 targetPosition &#x3D; targetTransform.Position;                &#x2F;&#x2F; Calculate the rotation                float3 displacement &#x3D; targetPosition - transform.Position;                float3 upReference &#x3D; new float3(0, 1, 0);                quaternion lookRotation &#x3D; quaternion.LookRotationSafe(displacement, upReference);                orientation.Value &#x3D; math.slerp(orientation.Value, lookRotation, deltaTime);            &#125;)            .ScheduleParallel();    &#125;&#125;</code></pre></div></figure><br />如果要访问存储在动态缓冲区中的数据，还需要在 <code>SystemBase</code> 的OnUpdate 方法中声明一个 BufferLookup 类型的局部变量。然后，您可以在lambda 表达式中捕获局部变量。例如：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public struct BufferData : IBufferElementData&#123;    public float Value;&#125;[RequireMatchingQueriesForUpdate]public partial class BufferLookupSystem : SystemBase&#123;    protected override void OnUpdate()    &#123;        BufferLookup&lt;BufferData&gt; buffersOfAllEntities            &#x3D; this.GetBufferLookup&lt;BufferData&gt;(true);        Entities            .ForEach((ref Rotation orientation,            in LocalToWorld transform,            in Target target) &#x3D;&gt;            &#123;                &#x2F;&#x2F; Check to make sure the target Entity with this buffer type still exists                if (!buffersOfAllEntities.HasBuffer(target.entity))                    return;                &#x2F;&#x2F; Get a reference to the buffer                DynamicBuffer&lt;BufferData&gt; bufferOfOneEntity &#x3D; buffersOfAllEntities[target.entity];                &#x2F;&#x2F; Use the data in the buffer                float avg &#x3D; 0;                for (var i &#x3D; 0; i &lt; bufferOfOneEntity.Length; i++)                &#123;                    avg +&#x3D; bufferOfOneEntity[i].Value;                &#125;                if (bufferOfOneEntity.Length &gt; 0)                    avg &#x2F;&#x3D; bufferOfOneEntity.Length;            &#125;)            .ScheduleParallel();    &#125;&#125;</code></pre></div></figure></p><h2 id="在作业中查找实体数据">在作业中查找实体数据</h2><p>要在 IJobEntityBatch等作业结构中随机访问组件数据，请使用以下类型之一：</p><ul><li>组件查找</li><li>缓冲区查找<br />这些类型获得一个类似于数组的组件接口，由 Entity 对象索引。</li></ul><p>要使用它们，请声明一个类型为 ComponentLookup 或 BufferLookup的字段，设置该字段的值，然后安排作业。</p><p>例如，您可以使用 ComponentLookup 字段来查找实体的世界位置：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">[ReadOnly]public ComponentLookup&lt;LocalToWorld&gt; EntityPositions;</code></pre></div></figure></p><div class="note note-info">            <p>此声明使用 ReadOnly 属性。您应该始终将 ComponentLookup对象声明为只读，除非您想写入您访问的组件。</p>          </div><p>以下示例说明了如何设置数据字段和安排作业：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">protected override void OnUpdate()&#123;    var job &#x3D; new ChaserSystemJob();    &#x2F;&#x2F; Set non-ECS data fields    job.deltaTime &#x3D; SystemAPI.Time.DeltaTime;    &#x2F;&#x2F; Schedule the job using Dependency property    Dependency &#x3D; job.ScheduleParallel(query, this.Dependency);&#125;</code></pre></div></figure><br />要查找组件的值，请在作业的 Execute 方法中使用实体对象：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">                float3 targetPosition &#x3D; entityPosition.Position;if !ENABLE_TRANSFORM_V1                float3 chaserPosition &#x3D; transform.Value.Position;else                float3 chaserPosition &#x3D; position.Value;endif                float3 displacement &#x3D; targetPosition - chaserPosition;                float3 newPosition &#x3D; chaserPosition + displacement * deltaTime;if !ENABLE_TRANSFORM_V1                transform.Value.Position &#x3D; newPosition;else                position &#x3D; new Translation &#123; Value &#x3D; newPosition &#125;;endif</code></pre></div></figure><br />以下完整示例显示了一个系统，该系统将具有目标字段的实体移动到目标的当前位置：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">    [RequireMatchingQueriesForUpdate]    public partial class MoveTowardsEntitySystem : SystemBase    &#123;        private EntityQuery query;        [BurstCompile]        private partial struct MoveTowardsJob : IJobEntity        &#123;            &#x2F;&#x2F; Read-only data stored (potentially) in other chunks            [ReadOnly]            public ComponentLookup&lt;LocalToWorld&gt; EntityPositions;            &#x2F;&#x2F; Non-entity data            public float deltaTime;if !ENABLE_TRANSFORM_V1            public void Execute(ref LocalToWorldTransform transform, in Target target, in LocalToWorld entityPosition)else            public void Execute(Translation position, in Target target, in LocalToWorld entityPosition)endif            &#123;                &#x2F;&#x2F; Get the target Entity object                Entity targetEntity &#x3D; target.entity;                &#x2F;&#x2F; Check that the target still exists                if (!EntityPositions.HasComponent(targetEntity))                    return;                &#x2F;&#x2F; Update translation to move the chasing enitity toward the target                float3 targetPosition &#x3D; entityPosition.Position;if !ENABLE_TRANSFORM_V1                float3 chaserPosition &#x3D; transform.Value.Position;                float3 displacement &#x3D; targetPosition - chaserPosition;                transform.Value.Position &#x3D; chaserPosition + displacement * deltaTime;else                float3 chaserPosition &#x3D; position.Value;                float3 displacement &#x3D; targetPosition - chaserPosition;                position &#x3D; new Translation                &#123;                    Value &#x3D; chaserPosition + displacement * deltaTime                &#125;;endif            &#125;        &#125;        protected override void OnCreate()        &#123;            &#x2F;&#x2F; Select all entities that have Translation and Target Component            query &#x3D; this.GetEntityQuery                (if !ENABLE_TRANSFORM_V1                    typeof(LocalToWorldTransform),else                    typeof(Translation),endif                    ComponentType.ReadOnly&lt;Target&gt;()                );        &#125;        protected override void OnUpdate()        &#123;            &#x2F;&#x2F; Create the job            var job &#x3D; new MoveTowardsJob();            &#x2F;&#x2F; Set the component data lookup field            job.EntityPositions &#x3D; GetComponentLookup&lt;LocalToWorld&gt;(true);            &#x2F;&#x2F; Set non-ECS data fields            job.deltaTime &#x3D; SystemAPI.Time.DeltaTime;            &#x2F;&#x2F; Schedule the job using Dependency property            Dependency &#x3D; job.ScheduleParallel(query, Dependency);        &#125;    &#125;</code></pre></div></figure></p><h2 id="数据访问错误">数据访问错误</h2><p>如果您查找的数据与您要在作业中读取和写入的数据重叠，则随机访问可能会导致竞争条件。</p><p>如果您确定要直接读取或写入的实体数据与要随机读取或写入的特定实体数据之间没有重叠，则可以使用NativeDisableParallelForRestriction 属性标记访问器对象。</p><h1 id="写入组">写入组</h1><p>写入组为一个系统提供了一种覆盖另一个系统的机制，即使您无法更改另一个系统。</p><p>一种常见的 ECS模式是系统读取一组输入组件并将其写入另一个组件作为其输出。但是，您可能希望覆盖系统的输出，并使用基于不同输入集的不同系统来更新输出组件。</p><p>目标组件类型的写入组由 ECS 将 WriteGroup属性应用于的所有其他组件类型组成，并以该目标组件类型作为参数。作为系统创建者，您可以使用写入组，以便您的系统用户可以排除您的系统将以其他方式选择和处理的实体。这种过滤机制允许系统用户根据自己的逻辑为排除的实体更新组件，同时让您的系统在其余部分照常运行。</p><h2 id="使用写组">使用写组</h2><p>要使用写入组，您必须对系统中的查询使用写入组过滤器选项。这从查询中排除所有实体，这些实体具有来自查询中可写的任何组件的写入组的组件。</p><p>要覆盖使用写入组的系统，请将您自己的组件类型标记为该系统输出组件的写入组的一部分。原始系统忽略任何具有您的组件的实体，您可以使用您自己的系统更新这些实体的数据。</p><h2 id="编写组示例">编写组示例</h2><p>在此示例中，您使用外部包根据角色的健康状况为游戏中的所有角色着色。为此，包中有两个组件：HealthComponent和 ColorComponent；</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public struct HealthComponent : IComponentData&#123;   public int Value;&#125;public struct ColorComponent : IComponentData&#123;   public float4 Value;&#125;</code></pre></div></figure><p>包中还有两个系统：</p><ol type="1"><li>ComputeColorFromHealthSystem，它从 HealthComponent 读取并写入ColorComponent</li><li>RenderWithColorComponent，从 ColorComponent 读取<br />为了表示玩家何时使用能量提升并且他们的角色变得无敌，您将InvincibleTagComponent附加到角色的实体。在这种情况下，角色的颜色应该更改为单独的不同颜色，而上面的示例不适用。</li></ol><p>您可以创建自己的系统来覆盖 ColorComponent 值，但理想情况下ComputeColorFromHealthSystem 不会计算实体的颜色。它应该忽略任何具有InvincibleTagComponent的实体。当屏幕上有成千上万的玩家时，这就变得更加重要。</p><p>这个系统来自另一个不知道 InvincibleTagComponent的包，所以这是写组有用的时候。当您知道它计算的值无论如何都会被覆盖时，它允许系统忽略查询中的实体。您需要做两件事来支持这一点：</p><ol type="1"><li><p>将 InvincibleTagComponent 标记为 ColorComponent写入组的一部分：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">[WriteGroup(typeof(ColorComponent))]struct InvincibleTagComponent : IComponentData &#123;&#125;</code></pre></div></figure><br />ColorComponent 的写入组由所有组件类型组成，这些组件类型具有以typeof(ColorComponent) 作为参数的 WriteGroup 属性。</p></li><li><p>ComputeColorFromHealthSystem必须明确支持写组。为此，系统需要为其所有查询指定EntityQueryOptions.FilterWriteGroup 选项，如下所示：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">...protected override void OnUpdate() &#123;Entities    .WithName(&quot;ComputeColor&quot;)    .WithEntityQueryOptions(EntityQueryOptions.FilterWriteGroup) &#x2F;&#x2F; support write groups    .ForEach((ref ColorComponent color, in HealthComponent health) &#x3D;&gt; &#123;        &#x2F;&#x2F; compute color here    &#125;).ScheduleParallel();&#125;...</code></pre></div></figure><br />执行时，会发生以下情况：</p></li><li><p>系统检测到你写入 ColorComponent 因为它是一个引用参数</p></li><li><p>它查找 ColorComponent 的写入组并在其中找到InvincibleTagComponent</p></li><li><p>它排除了所有具有 InvincibleTagComponent 的实体</p></li></ol><p>好处是，这允许系统根据系统未知的类型排除实体，并且可能存在于不同的包中。</p><div class="note note-info">            <p>有关更多示例，请参阅 Unity.Transforms代码，它为其更新的每个组件使用写入组，包括 LocalToWorld。</p>          </div><h2 id="创建写入组">创建写入组</h2><p>要创建写入组，请将 WriteGroup属性添加到写入组中每个组件类型的声明中。 WriteGroup属性采用一个参数，即组中组件用于更新的组件类型。单个组件可以是多个写入组的成员。</p><p>例如，如果您的系统在实体上存在组件 A 或 B 时写入组件 W，那么您可以为W 定义一个写入组，如下所示：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public struct W : IComponentData&#123;   public int Value;&#125;[WriteGroup(typeof(W))]public struct A : IComponentData&#123;   public int Value;&#125;[WriteGroup(typeof(W))]public struct B : IComponentData&#123;   public int Value;&#125;</code></pre></div></figure><br />您没有将写入组的目标（上例中的组件 W）添加到它自己的写入组。</p><h2 id="启用写组过滤">启用写组过滤</h2><p>要启用写入组过滤，请在您的作业上设置 FilterWriteGroups 标志：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public class AddingSystem : SystemBase&#123;   protected override void OnUpdate() &#123;      Entities          &#x2F;&#x2F; support write groups by setting EntityQueryOptions         .WithEntityQueryOptions(EntityQueryOptions.FilterWriteGroup)          .ForEach((ref W w, in B b) &#x3D;&gt; &#123;            &#x2F;&#x2F; perform computation here         &#125;).ScheduleParallel();&#125;&#125;</code></pre></div></figure><br />对于查询描述对象，在创建查询时设置标志：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public class AddingSystem : SystemBase&#123;   private EntityQuery m_Query;   protected override void OnCreate()   &#123;       var queryDescription &#x3D; new EntityQueryDesc       &#123;           All &#x3D; new ComponentType[] &#123;              ComponentType.ReadWrite&lt;W&gt;(),              ComponentType.ReadOnly&lt;B&gt;()           &#125;,           Options &#x3D; EntityQueryOptions.FilterWriteGroup       &#125;;       m_Query &#x3D; GetEntityQuery(queryDescription);   &#125;   &#x2F;&#x2F; Define IJobEntityBatch struct and schedule...&#125;</code></pre></div></figure><br />当您在查询中启用写入组过滤时，该查询会将可写组件的写入组中的所有组件添加到查询的None 列表中，除非您明确将它们添加到 All 或 Any列表中。因此，如果查询明确需要来自特定写入组的实体上的每个组件，则查询只会选择该实体。如果实体具有来自该写入组的一个或多个附加组件，则查询将拒绝它。</p><p>在上面的示例代码中，查询：</p><ul><li>排除具有组件 A 的任何实体，因为 W 是可写的并且 A 是 W的写入组的一部分。</li><li>不排除具有组件 B 的任何实体。即使 B 是 W 的写入组的一部分，它也在All 列表中明确指定。</li></ul><h2 id="覆盖另一个使用写入组的系统">覆盖另一个使用写入组的系统</h2><p>如果系统在其查询中使用写组过滤，您可以使用自己的系统覆盖该系统并写入那些组件。要覆盖系统，请将您自己的组件添加到其他系统写入的组件的写入组中。</p><p>因为写组过滤排除了查询未明确要求的写组中的任何组件，所以其他系统会忽略任何具有您的组件的实体。</p><p>例如，如果您想通过指定旋转的角度和轴来设置实体的方向，您可以创建一个组件和一个系统来将角度和轴值转换为四元数并将其写入Unity.Transforms.Rotation零件。</p><p>为了防止 Unity.Transforms 系统更新Rotation，无论除您之外的其他组件是否存在，您都可以将您的组件放在Rotation 的写入组中：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using Unity.Collections;using Unity.Entities;using Unity.Transforms;using Unity.Mathematics;[Serializable][WriteGroup(typeof(Rotation))]public struct RotationAngleAxis : IComponentData&#123;   public float Angle;   public float3 Axis;&#125;</code></pre></div></figure><br />然后，您可以无竞争地使用 RotationAngleAxis 组件更新任何实体：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using Unity.Burst;using Unity.Entities;using Unity.Jobs;using Unity.Collections;using Unity.Mathematics;using Unity.Transforms;public class RotationAngleAxisSystem : SystemBase&#123;   protected override void OnUpdate()   &#123;      Entities.ForEach((ref Rotation destination, in RotationAngleAxis source) &#x3D;&gt;      &#123;         destination.Value              &#x3D; quaternion.AxisAngle(math.normalize(source.Axis), source.Angle);      &#125;).ScheduleParallel();   &#125;&#125;</code></pre></div></figure></p><h2 id="扩展另一个使用写组的系统">扩展另一个使用写组的系统</h2><p>如果你想扩展另一个系统而不是覆盖它，或者如果你想让未来的系统覆盖或扩展你的系统，那么你可以在你自己的系统上启用写组过滤。但是，当您这样做时，默认情况下两个系统都不会处理任何组件组合。您必须明确查询和处理每个组合。</p><p>在前面的示例中，它定义了一个写入组，其中包含以组件 W 为目标的组件 A和 B。如果将名为 C 的新组件添加到写入组，那么知道 C的新系统可以查询包含的实体C，这些实体是否也有组件 A 或 B 并不重要。</p><p>但是，如果新系统还启用了写组过滤，那就不再是这样了。如果您只需要组件C，则写入组过滤会排除任何具有 A 或 B的实体。相反，您必须显式查询每个有意义的组件组合。</p><div class="note note-info">            <p>您可以在适当的时候使用查询的 Any 子句。</p>          </div><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">var query &#x3D; new EntityQueryDesc&#123;    All &#x3D; new ComponentType[] &#123;       ComponentType.ReadOnly&lt;C&gt;(),        ComponentType.ReadWrite&lt;W&gt;()    &#125;,    Any &#x3D; new ComponentType[] &#123;       ComponentType.ReadOnly&lt;A&gt;(),        ComponentType.ReadOnly&lt;B&gt;()    &#125;,    Options &#x3D; EntityQueryOptions.FilterWriteGroup&#125;;</code></pre></div></figure><p>如果有任何实体包含未明确提及的写入组中的组件组合，则写入写入组目标的系统及其过滤器不会处理它们。但是，如果存在任何这些类型的实体，则很可能是程序中的逻辑错误，它们不应该存在。</p><h1 id="版本号">版本号</h1><p>您可以使用 ECS架构各部分的版本号（也称为世代）来检测潜在的变化并实施有效的优化策略，例如在数据自应用程序的最后一帧以来未发生变化时跳过处理。对实体执行快速版本检查以提高应用程序的性能非常有用。</p><p>此页面概述了 ECS 使用的所有不同版本号，以及导致它们更改的条件。</p><h2 id="版本号结构">版本号结构</h2><p>所有版本号都是 32位有符号整数。它们总是增加，除非它们环绕：有符号整数溢出是 C#中定义的行为。这意味着要比较版本号，您应该使用（不）相等运算符，而不是关系运算符。</p><p>例如，检查 VersionB 是否比 VersionA更新的正确方法是使用以下内容：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">bool VersionBIsMoreRecent &#x3D; (VersionB - VersionA) &gt; 0;</code></pre></div></figure><br />无法保证版本号增加多少。</p><h2 id="实体版本号">实体版本号</h2><p>EntityId 包含索引和版本号。因为 ECS回收索引，所以每次实体销毁实体时它都会增加 EntityManager中的版本号。如果在 EntityManager 中查找 EntityId时版本号不匹配，则意味着引用的实体不再存在。</p><p>例如，在您通过 EntityId获取一个单位正在跟踪的敌人的位置之前，您可以调用ComponentDataFromEntity.Exists。这使用版本号来检查实体是否仍然存在。</p><h2 id="世界版本号">世界版本号</h2><p>ECS每创建或销毁一个管理器（如系统），就会增加一个世界的版本号。</p><h2 id="作业组件系统版本号">作业组件系统版本号</h2><p>EntityDataManager.GlobalVersion在每次作业组件系统更新之前都会增加。</p><p>您应该将此版本号与 System.LastSystemVersion结合使用。这会在每次作业组件系统更新后获取EntityDataManager.GlobalVersion 的值。</p><p>您应该将此版本号与 Chunk.ChangeVersion[] 结合使用。</p><h3 id="块.changeversion">块.ChangeVersion</h3><p>对于原型中的每个组件类型，此数组包含 EntityDataManager.GlobalVersion的值，在组件数组最后一次被访问为在此块中可写时。这并不能保证任何事情都发生了变化，只是它可能已经发生了变化。</p><p>您不能以可写方式访问共享组件，即使也为这些组件存储了版本号：它没有任何用处。</p><p>当您在 <code>Entities.ForEach</code> 构造中使用 WithChangeFilter()方法时，ECS 将该特定组件的 Chunk.ChangeVersion 与System.LastSystemVersion进行比较，并且它仅处理其组件数组在系统上次开始运行后被访问为可写的块。</p><p>例如，如果保证一组单位的生命值数量自上一帧以来没有变化，则可以跳过检查这些单位是否应更新其损坏模型。</p><h2 id="非共享组件版本号">非共享组件版本号</h2><p>对于每个非共享组件类型，每当涉及该类型的迭代器变得无效时，ECS都会增加 EntityManager.m_ComponentTypeOrderVersion[]版本号。换句话说，任何可能修改该类型数组（不是实例）的东西。</p><p>例如，如果您有特定组件标识的静态对象和每个块的边界框，则只需在该组件的类型顺序版本更改时更新这些边界框。</p><h2 id="共享组件版本号">共享组件版本号</h2><p>当存储在引用共享组件的块中的实体发生任何结构更改时，SharedComponentDataManager.m_S​​haredComponentVersion[]版本号会增加。</p><p>例如，如果您为每个共享组件保留一个实体计数，您可以依靠该版本号仅在相应版本号更改时重做每个计数。</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Entities</tag>
      
      <tag>ECS</tag>
      
      <tag>DOTS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECS 概念</title>
    <link href="/2022/11/17/ECS-concepts-intro/"/>
    <url>/2022/11/17/ECS-concepts-intro/</url>
    
    <content type="html"><![CDATA[<h1 id="概念">概念</h1><p>Entitiespackage使用<strong>实体组件系统</strong>(<strong>ECS</strong>)架构来组织代码和数据。实体是唯一标识符，就像游戏对象的轻量级的非托管替代品。实体相当与一个ID，用来关联包含实体数据的各个组件。与游戏对象不同，实体不包含代码：它们是由您创建的系统来处理的数据单元。<br /><span id="more"></span></p><table><thead><tr class="header"><th>标题</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>Entity</td><td>实体是不包含代码的游戏对象的轻量级替代品。</td></tr><tr class="even"><td>Component</td><td>组件包含有关单个实体的数据。</td></tr><tr class="odd"><td>System</td><td>向系统添加代码以处理实体和组件。</td></tr><tr class="even"><td>World</td><td>世界将实体组织成孤立的群体。</td></tr><tr class="odd"><td>Archetype</td><td>原型是一个或多个实体可能具有的组件的独特组合。</td></tr><tr class="even"><td>Structural changes</td><td>结构更改是会影响应用程序性能的资源密集型操作。</td></tr></tbody></table><h1 id="实体">实体</h1><p>实体表示程序中具有自己数据集的离散事物，例如角色、视觉效果、UI元素，甚至是网络事务等抽象事物。实体类似于非托管(unmanaged)的轻量级游戏对象，代表程序的特定元素。但是，实体仅充当将各个唯一组件关联在一起的ID，而不包含任何代码或充当其关联组件的容器。</p><p>实体的集合存储在一个世界中，世界的 <code>EntityManager</code>管理世界中的所有实体。 <code>EntityManager</code>包含可用于创建、销毁和修改该世界中的实体的方法。其中包括以下常用方法：</p><table><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>CreateEntity</td><td>创建一个新实体。</td></tr><tr class="even"><td>Instantiate</td><td>复制现有实体并从该副本创建新实体。</td></tr><tr class="odd"><td>DestroyEntity</td><td>销毁现有实体。</td></tr><tr class="even"><td>AddComponent</td><td>将组件添加到现有实体。</td></tr><tr class="odd"><td>RemoveComponent</td><td>从现有实体中删除组件。</td></tr><tr class="even"><td>GetComponent</td><td>获取实体组件的值。</td></tr><tr class="odd"><td>SetComponent</td><td>覆盖实体组件的值。</td></tr></tbody></table><div class="note note-info">            <p>当您创建或销毁实体时，这是一种结构更改，会影响应用程序的性能。有关详细信息，请参阅有关结构更改的文档</p>          </div><p>实体没有类型，但您可以根据与其关联的组件类型对实体进行分类。<code>EntityManager</code>跟踪现有全部实体上组件的唯一组合。这些独特的组合称为原型（Archetype）。有关原型如何工作的更多信息，请参阅有关原型概念的文档。</p><h2 id="编辑器中的实体">编辑器中的实体</h2><p>在编辑器中，以下图标代表实体：<img src="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/images/editor-entity-icon.png" style="display: inline;" />。当您使用特定的实体窗口和检查器时，您会看到这一点。</p><h1 id="组件">组件</h1><p>在实体组件系统 (ECS)体系结构中，组件包含系统可以读取或写入的实体数据。</p><p>使用没有方法的<code>IComponentData</code>接口将一个结构体标记为组件类型。此组件类型只能包含非托管数据，并且它们可以包含方法，但最佳实践是它们只有纯数据。如果你想创建一个托管组件，你将它定义为一个类。有关详细信息，请参阅托管组件。</p><p>对于不同的目的，有不同类型的组件。根据您希望如何管理项目中的数据，某些组件允许对应用程序的性能进行更精细的控制。有关详细信息，请参阅组件类型。</p><p>一组独特的实体的组件称为原型。 ECS 架构按原型将组件数据存储在称为块的16KiB 内存块中。有关 ECS如何存储组件数据的更多信息，请参阅原型概念文档。</p><h1 id="系统">系统</h1><p>系统提供将组件数据从当前状态转换为下一个状态的逻辑。例如，系统可能会通过速度乘以自上次更新以来的时间间隔来更新所有移动实体的位置。</p><p>系统每帧在主线程上运行一次。系统被组织成被称为系统组的层次结构，您可以使用这些系统组来组织系统更新的顺序。</p><p>您可以创建非托管或托管系统。要定义托管系统，请创建一个继承自<code>SystemBase</code>的类。要定义非托管系统，请创建一个继承自<code>ISystem</code>的结构。</p><p><code>ISystem</code>和<code>SystemBase</code>都有三种方法，您可以覆盖<code>OnUpdate</code>、<code>OnCreate</code>和<code>OnDestroy</code>。系统的<code>OnUpdate</code>方法每帧执行一次。</p><p>一个系统只能处理一个世界中的实体，所以一个系统与一个特定的世界相关联。您可以使用<code>World</code>属性返回系统附加到的世界。</p><p>默认情况下，一个自动引导过程会为每个系统和系统组创建一个实例。这个引导将创建一个默认世界，其中包含三个系统组：<code>InitializationSystemGroup</code>、<code>SimulationSystemGroup</code>和<code>PresentationSystemGroup</code>。默认情况下系统的一个实例将被添加到<code>SimulationSystemGroup</code>。您可以使用<code>[UpdateInGroup]</code>属性来覆盖此行为。</p><p>要禁用自动引导过程，请使用脚本定义<code>#UNITY_DISABLE_AUTOMATIC_SYSTEM_BOOTSTRAP</code>。</p><h2 id="系统类型">系统类型</h2><p>您可以使用多种类型的系统：</p><ul><li><code>SystemBase</code>: 为托管系统提供基类。</li><li><code>ISystem</code>: 为非托管系统提供接口。</li><li><code>EntityCommandBufferSystem</code>:为其他系统提供实体命令缓冲区实例。这允许您将结构更改组合在一起以提高应用程序的性能。</li><li><code>ComponentSystemGroup</code>:为系统提供嵌套组织和更新顺序。</li></ul><h2 id="系统组">系统组</h2><p>一个系统组可以有系统和其他系统组作为它的子系统。系统组有一个可以覆盖的更新方法，基本的更新方法将按排序顺序更新组的子级。</p><p>每次将组添加到系统组时，它都会重新排序系统更新顺序。要控制系统组的更新顺序，请将<code>UpdateBefore</code>或<code>UpdateAfter</code>属性添加到系统以指定它应该在之前或之后更新哪些系统。这些属性仅适用于同一系统组的子系统。例如：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 如果 PeachSystem 和 DaisySystem 是同一组的子级，&#x2F;&#x2F; 则实体组件系统按排序顺序将 PeachSystem 放在 DaisySystem 之前的某处。[UpdateBefore(typeof(DaisySystem))]public partial class PeachSystem : SystemBase &#123; &#125;</code></pre></div></figure><br />要创建系统组，请创建一个继承自<code>ComponentSystemGroup</code>的类。因为系统属于一个世界，所以必须使用<code>World.GetOrCreateSystem</code>创建一个系统。要将系统添加到组，请使用<code>group.AddSystemToUpdateList</code>。您可以将其他系统组添加到现有系统组。</p><p>有关详细信息，请参阅有关系统更新顺序的文档。</p><h2 id="检查系统">检查系统</h2><p>您可以使用“Systemswindow”窗口检查每个世界中系统的更新顺序，并查看系统组的完整层次结构。有关详细信息，请参阅有关系统窗口参考的文档。</p><h3 id="编辑器中的系统">编辑器中的系统</h3><p>在编辑器中，以下图标代表不同类型的系统。当您使用特定的实体窗口和检查器时，您会看到这一点。</p><table><thead><tr class="header"><th>图标</th><th>含义</th></tr></thead><tbody><tr class="odd"><td><imgsrc="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/images/editor-system-group.png" /></td><td>一个系统组</td></tr><tr class="even"><td><imgsrc="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/images/editor-system.png" /></td><td>一个系统</td></tr><tr class="odd"><td><imgsrc="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/images/editor-system-start-step.png" /></td><td>一个带有<code>OrderFirst</code>参数的，设置为在开头执行的<code>实体命令缓冲区系统</code>。</td></tr><tr class="even"><td><imgsrc="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/images/editor-system-end-step.png" /></td><td>一个带有<code>OrderLast</code>参数的，设置为在末尾执行的<code>实体命令缓冲区系统</code>。</td></tr></tbody></table><h1 id="世界">世界</h1><p>世界是实体的集合。实体的 ID号仅在其自己的世界中是唯一的。一个世界有一个<code>EntityManager</code>结构体，你可以用它来创建、销毁和修改世界中的实体。</p><p>一个世界拥有一组系统，这些系统通常只访问同一个世界中的实体。此外，世界中具有相同组件类型集的一组实体一起存储在原型中，原型决定了你程序中的组件在内存中的组织方式。</p><h2 id="初始化">初始化</h2><p>默认情况下，当您进入播放模式时，Unity会创建一个世界实例并将每个系统添加到这个默认世界。</p><p>如果您更喜欢手动将系统添加到默认世界，请创建一个实现<code>ICustomBootstrap</code>接口的类。</p><p>如果你想完全手动控制引导，使用这些定义来禁用默认的世界创建：</p><p>-<code>#UNITY_DISABLE_AUTOMATIC_SYSTEM_BOOTSTRAP_RUNTIME_WORLD</code>：禁用默认运行时世界的生成。<br />-<code>#UNITY_DISABLE_AUTOMATIC_SYSTEM_BOOTSTRAP_EDITOR_WORLD</code>：禁用默认编辑器世界的生成。<br />-<code>#UNITY_DISABLE_AUTOMATIC_SYSTEM_BOOTSTRAP</code>：禁用两个默认世界的生成。</p><p>然后，您的代码负责创建您的世界和系统，并将您的世界的更新插入到 Unity可编写脚本的 PlayerLoop 中。</p><p>Unity 使用<code>WorldFlags</code>在编辑器中创建专门的世界。</p><h2 id="时间考量">时间考量</h2><p>世界控制其中系统的<code>Time</code>属性的值。系统的<code>Time</code>属性是当前世界时间的别名。</p><p>默认情况下，Unity为每个世界创建一个<code>TimeData</code>实体，由<code>UpdateWorldTimeSystem</code>实例更新。这反映了自上一帧以来经过的时间。</p><p><code>FixedStepSimulationSystemGroup</code>中的系统处理时间的方式与其他系统组不同。固定步长模拟组中的系统以固定间隔更新，而不是在当前增量时间更新一次，并且如果固定间隔是帧时间的足够小的一部分，则每帧可能更新不止一次。</p><p>如果您需要对世界中的时间进行更多控制，可以使用<code>World.SetTime</code>直接指定一个时间值。您还可以使用<code>PushTime</code>临时更改世界时间，使用<code>PopTime</code>返回到之前的时间（在时间栈中）。</p><h1 id="原型">原型</h1><p>原型是世界中具有相同的唯一组件类型组合的所有实体的唯一标识符。例如，一个世界中具有组件类型A 和 B 的所有实体共享一个原型。所有具有组件类型 A、B 和 C的实体共享一个不同的原型，所有具有组件类型 A 和 Z的实体共享另一个原型。</p><p>当您从实体中添加或删除组件类型时，世界的<code>EntityManager</code>会将实体移动到适当的原型。例如，如果实体具有组件类型A、B 和 C，并且您删除了它的B组件，<code>EntityManager</code>会将实体移动到具有组件类型 A 和 C的原型。如果不存在这样的原型，则<code>EntityManager</code>会创建它。</p><div class="note note-danger">            <p>频繁移动实体会占用大量资源并降低应用程序的性能。有关详细信息，请参阅有关结构变更概念的文档。</p>          </div><p>基于原型的实体架构意味着通过组件类型查询实体是高效的。例如，如果您想要查找具有组件类型A 和 B的所有实体，您可以找到具有这些组件类型的所有原型，这比扫描所有单个实体的性能更高。世界中的现有原型集往往会在程序生命周期的早期稳定下来，因此您可以缓存查询以获得更快的性能。</p><p>原型只有在它的世界被销毁时才会被销毁。</p><h2 id="原型块-archetype-chunks">原型块 Archetype chunks</h2><p>所有具有相同原型的实体和组件都存储在称为块的统一内存块中。每个块由16KiB组成，它们可以存储的实体数量取决于块原型中组件的数量和大小。<code>EntityManager</code>根据需要创建和销毁块。</p><p>块包含每个组件类型的数组，以及用于存储实体 ID的附加数组。例如，在具有组件类型 A 和 B的原型中，每个块都具有三个数组：一个数组用于 A 组件值，一个数组用于 B组件值，一个数组用于实体 ID。</p><p>块的数组是紧密打包的：块的第一个实体存储在这些数组的索引 0处，块的第二个实体存储在索引 1处，后续实体存储在连续的索引中。当一个新的实体被添加到块中时，它被存储在第一个可用的索引中。当一个实体从块中移除时（因为它被破坏或被移动到另一个原型），块的最后一个实体被移动以填补空白。</p><p>将实体添加到原型时，如果原型的现有块已满，则<code>EntityManager</code>会创建一个新块。当最后一个实体从块中移除时，<code>EntityManager</code>会销毁该块。</p><h2 id="编辑器中的原型">编辑器中的原型</h2><p>原型窗口列出了项目中所有世界的原型，并显示了每个原型的已分配和未使用内存量。</p><p>在编辑器中，以下图标代表原型：<img src="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/images/editor-archetype-icon.png" style="display: inline;" />。</p><h1 id="结构更改">结构更改</h1><p>导致 Unity重新组织内存块或内存中块的内容的操作称为结构更改。了解哪些操作是结构更改很重要，因为它们可能是资源密集型的，您只能在主线程上执行它们；不是来自jobs。</p><p>以下操作被视为结构更改：</p><ul><li>创建或销毁实体。</li><li>添加或删除组件。</li><li>设置一个共享组件值。</li></ul><h2 id="创建一个实体">创建一个实体</h2><p>当您创建一个实体时，Unity要么将实体添加到现有块中，要么如果没有块可用于实体的原型，则创建一个新块并将实体添加到其中。</p><h2 id="销毁一个实体">销毁一个实体</h2><p>当您销毁一个实体时，Unity会将该实体从其块中移除。如果移除实体在块中留下空隙，Unity会移动块中的最后一个实体来填补空隙。如果删除实体使块为空，Unity会释放块。</p><h2 id="添加或删除组件">添加或删除组件</h2><p>在实体中添加或删除组件时，您会更改实体的原型。 Unity将每个实体存储在与实体原型匹配的块中。这意味着如果您更改实体的原型，Unity必须将该实体移动到另一个块。如果不存在合适的块，Unity会创建一个新块。如果移动使前一个块有间隙或留空，Unity将移动块中的最后一个实体以分别填充间隙或释放块。</p><h2 id="设置一个共享组件值">设置一个共享组件值</h2><p>当您设置实体的共享组件的值时，Unity会将实体移动到与新共享组件值匹配的块中。如果不存在合适的块，Unity会创建一个新块。如果移动使前一个块有间隙或为空，Unity将移动块中的最后一个实体以填充间隙或分别释放块。</p><div class="note note-info">            <p>设置常规组件值不是结构更改，因为它不需要 Unity 移动实体。</p>          </div><h2 id="同步点">同步点</h2><p>您不能直接在作业中进行结构更改，因为它可能会使其他已安排的作业无效，并创建一个同步点。</p><p>一个同步点（syncpoint）是程序执行中的一个点，它等待到目前为止已经调度的所有作业完成。同步点会限制您在一段时间内使用作业系统中可用的所有工作线程的能力。因此，您的目标应该是避免同步点。ECS 中数据的结构变化是产生同步点的主要原因。</p><p>结构更改不仅要求同步点，而且还会使对任何组件数据的所有直接引用无效。这包括<code>DynamicBuffer</code>的实例和提供对组件（例如<code>ComponentSystemBase.GetComponentDataFromEntity</code>）的直接访问的方法的结果。</p><h3 id="避免同步点">避免同步点</h3><p>您可以使用实体命令缓冲区来排队缓冲结构更改，而不是立即执行它们。您可以在帧的稍后时间执行存储在实体命令缓冲区中的命令。这将跨帧分布的多个同步点减少为单个同步点。</p><p>每个标准<code>ComponentSystemGroup</code>实例都提供<code>EntityCommandBufferSystem</code>作为组中更新的第一个和最后一个系统。如果您从这些标准系统之一获取实体命令缓冲区对象，则所有结构更改都发生在帧中的同一点，从而产生一个同步点。您还可以使用实体命令缓冲区来记录作业中的结构更改，而不是仅在主线程上进行结构更改。</p><p>如果您不能为任务使用实体命令缓冲区，请将所有进行结构更改的系统按系统执行顺序分组在一起。两个都进行结构更改的系统如果按顺序更新，则只会创建一个同步点。</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Entities</tag>
      
      <tag>ECS</tag>
      
      <tag>DOTS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Entities ECS DOTS 中文文档</title>
    <link href="/2022/11/16/ECS/"/>
    <url>/2022/11/16/ECS/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>Entity1.0版本发布了，很多接口和概念都不同与之前的版本了。苦于没有更方便的中文资料去查询，总体机翻并稍微修改了一下，贴在下面，以备后用。<br /><span id="more"></span></p><h1 id="总目录">总目录</h1><ul><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#系统">系统</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#使用-SystemBase-创建系统">使用<code>SystemBase</code> 创建系统</a><ul><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#回调方法顺序">回调方法顺序</a></li></ul></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#迭代数据">迭代数据</a><ul><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#额外资源">额外资源</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#使用-Entities-ForEach-迭代数据">使用<code>Entities.ForEach</code> 迭代数据</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#使用-IJobEntity-迭代数据">使用<code>IJobEntity</code> 迭代数据</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#使用-IJobEntityBatch-遍历成批数据">使用<code>IJobEntityBatch</code> 遍历成批数据</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#手动迭代数据">手动迭代数据</a></li></ul></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#系统更新顺序">系统更新顺序</a><ul><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#组件系统组">组件系统组</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#系统排序属性">系统排序属性</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#默认系统组">默认系统组</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#多个世界">多个世界</a></li></ul></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#使用作业在多个线程上调度数据">使用作业在多个线程上调度数据</a><ul><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#工作扩展">工作扩展</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#通用职位">通用职位</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#使用-Job-WithCode-安排后台作业">使用Job.WithCode 安排后台作业</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#作业依赖">作业依赖</a></li></ul></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#使用-EntityQuery-查询数据">使用EntityQuery 查询数据</a><ul><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#创建实体查询">创建实体查询</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#定义过滤器">定义过滤器</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#按启用组件过滤">按启用组件过滤</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#合并查询">合并查询</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#执行查询">执行查询</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#编辑器中的查询">编辑器中的查询</a></li></ul></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#使用-EntityCommandBuffer-安排数据更改">使用EntityCommandBuffer 安排数据更改</a><ul><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#EntityCommandBuffer-方法">EntityCommandBuffer方法</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#在单线程作业中使用-EntityCommandBuffer">在单线程作业中使用EntityCommandBuffer</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#在并行作业中使用-EntityCommandBuffer">在并行作业中使用EntityCommandBuffer</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#重用-EntityCommandBuffer-实例">重用EntityCommandBuffer 实例</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#多重回放">多重回放</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#在主线程上使用-EntityCommandBuffer">在主线程上使用EntityCommandBuffer</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#使用-EntityCommandBufferSystem-自动播放和处理命令缓冲区">使用EntityCommandBufferSystem 自动播放和处理命令缓冲区</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#延迟实体">延迟实体</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#在-Entities-ForEach-方法中使用命令缓冲区">在<code>Entities.ForEach</code> 方法中使用命令缓冲区</a></li></ul></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#查找任意数据">查找任意数据</a><ul><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#在系统中查找实体数据">在系统中查找实体数据</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#在作业中查找实体数据">在作业中查找实体数据</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#数据访问错误">数据访问错误</a></li></ul></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#写入组">写入组</a><ul><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#使用写组">使用写组</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#编写组示例">编写组示例</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#创建写入组">创建写入组</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#启用写组过滤">启用写组过滤</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#覆盖另一个使用写入组的系统">覆盖另一个使用写入组的系统</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#扩展另一个使用写组的系统">扩展另一个使用写组的系统</a></li></ul></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#版本号">版本号</a><ul><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#版本号结构">版本号结构</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#实体版本号">实体版本号</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#世界版本号">世界版本号</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#作业组件系统版本号">作业组件系统版本号</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#非共享组件版本号">非共享组件版本号</a></li><li><ahref="https://hexo.home.kuanmi.top/2022/11/16/ECS-systems-intro/#共享组件版本号">共享组件版本号</a></li></ul></li></ul><h1 id="目录">目录</h1><ul><li><a href="#前言">前言</a></li><li><a href="#目录">目录</a></li><li><a href="#概念">概念</a><ul><li><a href="#实体">实体</a><ul><li><a href="#编辑器中的实体">编辑器中的实体</a></li></ul></li><li><a href="#组件">组件</a></li><li><a href="#系统">系统</a><ul><li><a href="#系统类型">系统类型</a></li><li><a href="#系统组">系统组</a></li><li><a href="#检查系统">检查系统</a><ul><li><a href="#编辑器中的系统">编辑器中的系统</a></li></ul></li></ul></li><li><a href="#世界">世界</a><ul><li><a href="#初始化">初始化</a></li><li><a href="#时间考量">时间考量</a></li></ul></li><li><a href="#原型">原型</a><ul><li><a href="#原型块-archetype-chunks">原型块 Archetype chunks</a></li><li><a href="#编辑器中的原型">编辑器中的原型</a></li></ul></li><li><a href="#结构变化">结构变化</a><ul><li><a href="#创建一个实体">创建一个实体</a></li><li><a href="#销毁一个实体">销毁一个实体</a></li><li><a href="#添加或删除组件">添加或删除组件</a></li><li><a href="#设置一个共享组件值">设置一个共享组件值</a></li><li><a href="#同步点">同步点</a><ul><li><a href="#避免同步点">避免同步点</a></li></ul></li></ul></li></ul></li><li><a href="#实现系统">实现系统</a><ul><li><ahref="#使用systembase创建系统">使用<code>SystemBase</code>创建系统</a><ul><li><a href="#回调方法顺序">回调方法顺序</a></li></ul></li><li><a href="#迭代数据">迭代数据</a><ul><li><a href="#使用-entitiesforeach-迭代数据">使用<code>Entities.ForEach</code> 迭代数据</a><ul><li><a href="#定义一个-lambda-表达式">定义一个 lambda 表达式</a><ul><li><a href="#自定义代理">自定义代理</a></li><li><a href="#组件参数">组件参数</a></li><li><a href="#命名参数">命名参数</a></li></ul></li><li><a href="#执行-entitiesforeach-lambda-表达式">执行 Entities.ForEachlambda 表达式</a></li><li><a href="#选择实体">选择实体</a></li><li><a href="#访问-entityquery-对象">访问 EntityQuery 对象</a></li><li><a href="#访问可选组件">访问可选组件</a></li><li><a href="#更改过滤">更改过滤</a></li><li><a href="#共享组件过滤">共享组件过滤</a></li><li><a href="#捕获变量">捕获变量</a></li><li><a href="#支持的功能">支持的功能</a></li><li><a href="#依赖关系">依赖关系</a></li></ul></li><li><a href="#使用-ijobentity-迭代数据">使用 <code>IJobEntity</code>迭代数据</a><ul><li><a href="#ijobentity-和-entitiesforeach-的比较">IJobEntity 和Entities.ForEach 的比较</a></li><li><a href="#创建-ijobentity-作业">创建 IJobEntity 作业</a></li><li><a href="#指定查询">指定查询</a><ul><li><a href="#属性">属性</a></li><li><a href="#执行参数">执行参数</a></li></ul></li></ul></li><li><a href="#遍历成批数据">遍历成批数据</a><ul><li><a href="#使用-entityquery-查询数据">使用 EntityQuery查询数据</a></li><li><a href="#定义作业结构">定义作业结构</a><ul><li><ahref="#ijobentitybatch-与-ijobentitybatchwithindex">IJobEntityBatch 与IJobEntityBatchWithIndex</a></li><li><a href="#声明您的工作访问的数据">声明您的工作访问的数据</a><ul><li><ahref="#访问实体组件和缓冲区数据">访问实体组件和缓冲区数据</a></li><li><a href="#查找其他实体的数据">查找其他实体的数据</a></li><li><a href="#访问其他数据">访问其他数据</a></li></ul></li><li><a href="#编写执行函数">编写执行函数</a><ul><li><a href="#batchinchunk-参数">batchInChunk 参数</a></li><li><a href="#batchindex-参数">batchIndex 参数</a></li><li><a href="#indexoffirstentityinquery-参数">indexOfFirstEntityInQuery参数</a></li><li><a href="#可选组件">可选组件</a></li></ul></li></ul></li><li><a href="#安排工作">安排工作</a><ul><li><a href="#调度选项">调度选项</a></li><li><a href="#设置批量大小">设置批量大小</a></li></ul></li><li><a href="#跳过实体不变的块">跳过实体不变的块</a></li></ul></li><li><a href="#手动迭代数据">手动迭代数据</a><ul><li><a href="#如何手动迭代数据">如何手动迭代数据</a></li></ul></li></ul></li><li><a href="#系统更新顺序">系统更新顺序</a><ul><li><a href="#组件系统组">组件系统组</a></li><li><a href="#系统排序属性">系统排序属性</a></li><li><a href="#默认系统组">默认系统组</a></li><li><a href="#多个世界">多个世界</a></li></ul></li><li><ahref="#使用作业在多个线程上调度数据">使用作业在多个线程上调度数据</a><ul><li><a href="#工作扩展">工作扩展</a></li><li><a href="#通用职位">通用职位</a><ul><li><a href="#从-burst-编译代码中调度通用作业">从 Burst编译代码中调度通用作业</a></li><li><a href="#具体作业类型的自动注册">具体作业类型的自动注册</a></li><li><a href="#作业化分拣">作业化分拣</a></li></ul></li><li><a href="#使用-jobwithcode-安排后台作业">使用 Job.WithCode安排后台作业</a><ul><li><a href="#使用-jobwithcode">使用 Job.WithCode</a></li><li><a href="#捕获变量-1">捕获变量</a></li><li><a href="#执行-jobwithcode-lambda-表达式">执行 Job.WithCode lambda表达式</a></li><li><a href="#依赖关系-1">依赖关系</a></li></ul></li><li><a href="#作业依赖">作业依赖</a><ul><li><a href="#作业依赖更新顺序">作业依赖更新顺序</a><ul><li><a href="#覆盖默认顺序">覆盖默认顺序</a></li><li><a href="#entitiesforeach-的作业依赖顺序">Entities.ForEach的作业依赖顺序</a></li></ul></li><li><a href="#更多资源">更多资源</a></li></ul></li></ul></li><li><a href="#使用-entityquery-查询数据-1">使用 EntityQuery 查询数据</a><ul><li><a href="#创建实体查询">创建实体查询</a><ul><li><a href="#指定系统选择的原型">指定系统选择的原型</a><ul><li><a href="#按写入组过滤">按写入组过滤</a></li></ul></li></ul></li><li><a href="#定义过滤器">定义过滤器</a><ul><li><a href="#使用共享组件过滤器">使用共享组件过滤器</a></li><li><a href="#使用更改过滤器">使用更改过滤器</a></li></ul></li><li><a href="#按启用组件过滤">按启用组件过滤</a></li><li><a href="#合并查询">合并查询</a></li><li><a href="#执行查询">执行查询</a></li><li><a href="#编辑器中的查询">编辑器中的查询</a></li></ul></li><li><a href="#使用-entitycommandbuffer-安排数据更改">使用EntityCommandBuffer 安排数据更改</a><ul><li><a href="#entitycommandbuffer-方法">EntityCommandBuffer方法</a></li><li><a href="#在单线程作业中使用-entitycommandbuffer">在单线程作业中使用EntityCommandBuffer</a></li><li><a href="#在并行作业中使用-entitycommandbuffer">在并行作业中使用EntityCommandBuffer</a><ul><li><a href="#确定性回放">确定性回放</a></li></ul></li><li><a href="#重用-entitycommandbuffer-实例">重用 EntityCommandBuffer实例</a></li><li><a href="#多重回放">多重回放</a></li><li><a href="#在主线程上使用-entitycommandbuffer">在主线程上使用EntityCommandBuffer</a></li><li><ahref="#使用-entitycommandbuffersystem-自动播放和处理命令缓冲区">使用EntityCommandBufferSystem 自动播放和处理命令缓冲区</a><ul><li><a href="#默认-entitycommandbuffersystem-系统">默认EntityCommandBufferSystem 系统</a></li></ul></li><li><a href="#延迟实体">延迟实体</a></li><li><a href="#在-entitiesforeach-方法中使用命令缓冲区">在Entities.ForEach 方法中使用命令缓冲区</a><ul><li><a href="#在-entitiesforeach-中回放-entitycommandbuffer">在Entities.forEach 中回放 EntityCommandBuffer</a></li></ul></li></ul></li><li><a href="#查找任意数据">查找任意数据</a><ul><li><a href="#在系统中查找实体数据">在系统中查找实体数据</a></li><li><a href="#在作业中查找实体数据">在作业中查找实体数据</a></li><li><a href="#数据访问错误">数据访问错误</a></li></ul></li><li><a href="#写入组">写入组</a><ul><li><a href="#使用写组">使用写组</a></li><li><a href="#编写组示例">编写组示例</a></li><li><a href="#创建写入组">创建写入组</a></li><li><a href="#启用写组过滤">启用写组过滤</a></li><li><ahref="#覆盖另一个使用写入组的系统">覆盖另一个使用写入组的系统</a></li><li><ahref="#扩展另一个使用写组的系统">扩展另一个使用写组的系统</a></li></ul></li><li><a href="#版本号">版本号</a><ul><li><a href="#版本号结构">版本号结构</a></li><li><a href="#实体版本号">实体版本号</a></li><li><a href="#世界版本号">世界版本号</a></li><li><a href="#作业组件系统版本号">作业组件系统版本号</a><ul><li><a href="#块changeversion">块.ChangeVersion</a></li></ul></li><li><a href="#非共享组件版本号">非共享组件版本号</a></li><li><a href="#共享组件版本号">共享组件版本号</a></li></ul></li></ul></li><li><a href="#组件的使用">组件的使用</a><ul><li><a href="#组件类型">组件类型</a></li><li><a href="#向实体添加组件">向实体添加组件</a></li><li><a href="#从实体中移除组件">从实体中移除组件</a></li><li><a href="#读取和写入组件值">读取和写入组件值</a></li></ul></li><li><a href="#实体包中的脚本">实体包中的脚本</a><ul><li><a href="#使用-baking-转换数据">使用 Baking 转换数据</a></li><li><a href="#使用方面组织代码">使用方面组织代码</a></li><li><a href="#转换系统">转换系统</a></li><li><a href="#blob-资产">Blob 资产</a></li><li><a href="#在运行时加载场景">在运行时加载场景</a></li></ul></li><li><a href="#在编辑器中工作">在编辑器中工作</a><ul><li><a href="#实体首选项参考">实体首选项参考</a></li><li><a href="#使用创作和运行时数据">使用创作和运行时数据</a></li><li><a href="#实体窗口">实体窗口</a></li><li><a href="#实体inspectors">实体Inspectors</a></li></ul></li><li><a href="#性能和调试">性能和调试</a><ul><li><a href="#entities-profiler-modules">Entities Profilermodules</a></li><li><a href="#entities-journaling">Entities Journaling</a></li></ul></li></ul><h1 id="概念">概念</h1><table><thead><tr class="header"><th>标题</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>Entity</td><td>实体是不包含代码的游戏对象的轻量级替代品。</td></tr><tr class="even"><td>Component</td><td>组件包含有关单个实体的数据。</td></tr><tr class="odd"><td>System</td><td>向系统添加代码以处理实体和组件。</td></tr><tr class="even"><td>World</td><td>世界将实体组织成孤立的群体。</td></tr><tr class="odd"><td>Archetype</td><td>原型是一个或多个实体可能具有的组件的独特组合。</td></tr><tr class="even"><td>Structural changes</td><td>结构更改是会影响应用程序性能的资源密集型操作。</td></tr></tbody></table><h2 id="实体">实体</h2><p>实体表示程序中具有自己数据集的离散事物，例如角色、视觉效果、UI元素，甚至是网络事务等抽象事物。实体类似于非托管(unmanaged)的轻量级游戏对象，代表程序的特定元素。但是，实体仅充当将各个唯一组件关联在一起的ID，而不包含任何代码或充当其关联组件的容器。</p><p>实体的集合存储在一个世界中，世界的 EntityManager管理世界中的所有实体。 EntityManager包含可用于创建、销毁和修改该世界中的实体的方法。其中包括以下常用方法：</p><table><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>CreateEntity</td><td>创建一个新实体。</td></tr><tr class="even"><td>Instantiate</td><td>复制现有实体并从该副本创建新实体。</td></tr><tr class="odd"><td>DestroyEntity</td><td>销毁现有实体。</td></tr><tr class="even"><td>AddComponent</td><td>将组件添加到现有实体。</td></tr><tr class="odd"><td>RemoveComponent</td><td>从现有实体中删除组件。</td></tr><tr class="even"><td>GetComponent</td><td>检索实体组件的值。</td></tr><tr class="odd"><td>SetComponent</td><td>覆盖实体组件的值。</td></tr></tbody></table><div class="note note-info">            <p>当您创建或销毁实体时，这是一种结构更改，会影响应用程序的性能。有关详细信息，请参阅有关结构更改的文档</p>          </div><p>实体没有类型，但您可以根据与其关联的组件类型对实体进行分类。EntityManager跟踪现有实体上组件的唯一组合。这些独特的组合称为原型（Archetype）。有关原型如何工作的更多信息，请参阅有关原型概念的文档。</p><h3 id="编辑器中的实体">编辑器中的实体</h3><p>在编辑器中，以下图标代表实体：<img src="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/images/editor-entity-icon.png" style="display: inline;" />。当您使用特定的实体窗口和检查器时，您会看到这一点。</p><h2 id="组件">组件</h2><p>在实体组件系统 (ECS)体系结构中，组件包含系统可以读取或写入的实体数据。</p><p>使用没有方法的<code>IComponentData</code>接口将一个结构体标记为组件类型。此组件类型只能包含非托管数据，并且它们可以包含方法，但最佳实践是它们只有纯数据。如果你想创建一个托管组件，你将它定义为一个类。有关详细信息，请参阅托管组件。</p><p>有不同类型的组件用于不同的目的。根据您希望如何管理项目中的数据，某些组件允许对应用程序的性能进行更精细的控制。有关详细信息，请参阅组件类型。</p><p>一组独特的实体的组件称为原型。 ECS 架构按原型将组件数据存储在称为块的16KiB 内存块中。有关 ECS如何存储组件数据的更多信息，请参阅原型概念文档。</p><h2 id="系统">系统</h2><p>系统提供将组件数据从当前状态转换为下一个状态的逻辑。例如，系统可能会通过速度乘以自上次更新以来的时间间隔来更新所有移动实体的位置。</p><p>系统每帧在主线程上运行一次。系统被组织成被称为系统组的层次结构，您可以使用这些系统组来组织系统更新的顺序。</p><p>您可以创建非托管或托管系统。要定义托管系统，请创建一个继承自<code>SystemBase</code>的类。要定义非托管系统，请创建一个继承自<code>ISystem</code>的结构。</p><p><code>ISystem</code>和<code>SystemBase</code>都有三种方法，您可以覆盖<code>OnUpdate</code>、<code>OnCreate</code>和<code>OnDestroy</code>。系统的<code>OnUpdate</code>方法每帧执行一次。</p><p>一个系统只能处理一个世界中的实体，所以一个系统与一个特定的世界相关联。您可以使用<code>World</code>属性返回系统附加到的世界。</p><p>默认情况下，自动引导过程会为每个系统和系统组创建一个实例。引导创建一个默认世界，其中包含三个系统组：<code>InitializationSystemGroup</code>、<code>SimulationSystemGroup</code>和<code>PresentationSystemGroup</code>。默认情况下系统的一个实例被添加到<code>SimulationSystemGroup</code>。您可以使用<code>[UpdateInGroup]</code>属性来覆盖此行为。</p><p>要禁用自动引导过程，请使用脚本定义<code>#UNITY_DISABLE_AUTOMATIC_SYSTEM_BOOTSTRAP</code>。</p><h3 id="系统类型">系统类型</h3><p>您可以使用多种类型的系统：<br />-<code>SystemBase</code>: 为托管系统提供基类。<br />-<code>ISystem</code>: 为非托管系统提供接口。<br />-<code>EntityCommandBufferSystem</code>:为其他系统提供实体命令缓冲区实例。这允许您将结构更改组合在一起以提高应用程序的性能。<br />-<code>ComponentSystemGroup</code>: 为系统提供嵌套组织和更新顺序。</p><h3 id="系统组">系统组</h3><p>一个系统组可以有系统和其他系统组作为它的子系统。系统组有一个可以覆盖的更新方法，基本方法按排序顺序更新组的子级。</p><p>每次将组添加到系统组时，它都会重新排序系统更新顺序。要控制系统组的更新顺序，请将<code>UpdateBefore</code>或<code>UpdateAfter</code>属性添加到系统以指定它应该在之前或之后更新哪些系统。这些属性仅适用于同一系统组的子系统。例如：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">&#x2F;&#x2F; 如果 PeachSystem 和 DaisySystem 是同一组的子级，&#x2F;&#x2F; 则实体组件系统按排序顺序将 PeachSystem 放在 DaisySystem 之前的某处。    [UpdateBefore(typeof(DaisySystem))]    public partial class PeachSystem : SystemBase &#123; &#125;</code></pre></div></figure><br />要创建系统组，请创建一个继承自<code>ComponentSystemGroup</code>的类。因为系统属于一个世界，所以必须使用<code>World.GetOrCreateSystem</code>创建一个系统。要将系统添加到组，请使用<code>group.AddSystemToUpdateList</code>。您可以将其他系统组添加到现有系统组。</p><p>有关详细信息，请参阅有关系统更新顺序的文档。</p><h3 id="检查系统">检查系统</h3><p>您可以使用“Systems”窗口检查每个世界中系统的更新顺序，并查看系统组的完整层次结构。有关详细信息，请参阅有关系统窗口参考的文档。</p><h4 id="编辑器中的系统">编辑器中的系统</h4><p>在编辑器中，以下图标代表不同类型的系统。当您使用特定的实体窗口和检查器时，您会看到这一点。<br />| 图标 | 含义 |<br />| —————————————————————————————————————————————— |——————————————————————– |<br />|<img src="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/images/editor-system-group.png" style="display: inline;" />| 一个系统组 |<br />|<img src="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/images/editor-system.png" style="display: inline;" />| 一个系统 |<br />|<img src="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/images/editor-system-start-step.png" style="display: inline;" />|一个带有<code>OrderFirst</code>参数的，设置为在开头执行的<code>实体命令缓冲区系统</code>。|<br />|<img src="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/images/editor-system-end-step.png" style="display: inline;" />|一个带有<code>OrderLast</code>参数的，设置为在末尾执行的<code>实体命令缓冲区系统</code>。|</p><h2 id="世界">世界</h2><p>世界是实体的集合。实体的 ID号仅在其自己的世界中是唯一的。一个世界有一个<code>EntityManager</code>结构体，你可以用它来创建、销毁和修改世界中的实体。</p><p>一个世界拥有一组系统，这些系统通常只访问同一个世界中的实体。此外，世界中具有相同组件类型集的一组实体一起存储在原型中，原型决定了你程序中的组件在内存中的组织方式。</p><h3 id="初始化">初始化</h3><p>默认情况下，当您进入播放模式时，Unity会创建一个世界实例并将每个系统添加到这个默认世界。</p><p>如果您更喜欢手动将系统添加到默认世界，请创建一个实现<code>ICustomBootstrap</code>接口的类。</p><p>如果你想完全手动控制引导，使用这些定义来禁用默认的世界创建：</p><p>-<code>#UNITY_DISABLE_AUTOMATIC_SYSTEM_BOOTSTRAP_RUNTIME_WORLD</code>：禁用默认运行时世界的生成。<br />-<code>#UNITY_DISABLE_AUTOMATIC_SYSTEM_BOOTSTRAP_EDITOR_WORLD</code>：禁用默认编辑器世界的生成。<br />-<code>#UNITY_DISABLE_AUTOMATIC_SYSTEM_BOOTSTRAP</code>：禁用两个默认世界的生成。</p><p>然后，您的代码负责创建您的世界和系统，并将您的世界的更新插入到 Unity可编写脚本的 PlayerLoop 中。</p><p>Unity 使用<code>WorldFlags</code>在编辑器中创建专门的世界。</p><h3 id="时间考量">时间考量</h3><p>世界控制其中系统的<code>Time</code>属性的值。系统的<code>Time</code>属性是当前世界时间的别名。</p><p>默认情况下，Unity为每个世界创建一个<code>TimeData</code>实体，由<code>UpdateWorldTimeSystem</code>实例更新。这反映了自上一帧以来经过的时间。</p><p><code>FixedStepSimulationSystemGroup</code>中的系统处理时间的方式与其他系统组不同。固定步长模拟组中的系统以固定间隔更新，而不是在当前增量时间更新一次，并且如果固定间隔是帧时间的足够小的一部分，则每帧可能更新不止一次。</p><p>如果您需要对世界中的时间进行更多控制，可以使用<code>World.SetTime</code>直接指定一个时间值。您还可以使用<code>PushTime</code>临时更改世界时间，使用<code>PopTime</code>返回到之前的时间（在时间栈中）。</p><h2 id="原型">原型</h2><p>原型是世界中所有实体的唯一标识符，这些实体具有相同的唯一组件类型组合。例如，一个世界中具有组件类型A 和 B 的所有实体共享一个原型。所有具有组件类型 A、B 和 C的实体共享一个不同的原型，所有具有组件类型 A 和 Z的实体共享另一个原型。</p><p>当您从实体中添加或删除组件类型时，世界的<code>EntityManager</code>会将实体移动到适当的原型。例如，如果实体具有组件类型A、B 和 C，并且您删除了它的B<code>组件，EntityManager</code>会将实体移动到具有组件类型 A 和 C的原型。如果不存在这样的原型，则<code>EntityManager</code>会创建它。</p><div class="note note-warning">            <p>频繁移动实体会占用大量资源并降低应用程序的性能。有关详细信息，请参阅有关结构变更概念的文档。</p>          </div><p>基于原型的实体组织意味着通过组件类型查询实体是高效的。例如，如果您想要查找具有组件类型A 和 B的所有实体，您可以找到具有这些组件类型的所有原型，这比扫描所有单个实体的性能更高。世界中的现有原型集往往会在程序生命周期的早期稳定下来，因此您可以缓存查询以获得更快的性能。</p><p>原型只有在它的世界被销毁时才会被销毁。</p><h3 id="原型块-archetype-chunks">原型块 Archetype chunks</h3><p>所有具有相同原型的实体和组件都存储在称为块的统一内存块中。每个块由16KiB组成，它们可以存储的实体数量取决于块原型中组件的数量和大小。<code>EntityManager</code>根据需要创建和销毁块。</p><p>块包含每个组件类型的数组，以及用于存储实体 ID的附加数组。例如，在具有组件类型 A 和 B的原型中，每个块都具有三个数组：一个数组用于 A 组件值，一个数组用于 B组件值，一个数组用于实体 ID。</p><p>块的数组是紧密打包的：块的第一个实体存储在这些数组的索引 0处，块的第二个实体存储在索引 1处，后续实体存储在连续的索引中。当一个新的实体被添加到块中时，它被存储在第一个可用的索引中。当一个实体从块中移除时（因为它被破坏或被移动到另一个原型），块的最后一个实体被移动以填补空白。</p><p>将实体添加到原型时，如果原型的现有块已满，则<code>EntityManager</code>会创建一个新块。当最后一个实体从块中移除时，<code>EntityManager</code>会销毁该块。</p><h3 id="编辑器中的原型">编辑器中的原型</h3><p>原型窗口列出了项目中所有世界的原型，并显示了每个原型的已分配和未使用内存量。</p><p>在编辑器中，以下图标代表原型：<img src="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/images/editor-archetype-icon.png" style="display: inline;" />。</p><h2 id="结构变化">结构变化</h2><p>导致 Unity重新组织内存块或内存中块的内容的操作称为结构更改。了解哪些操作是结构更改很重要，因为它们可能是资源密集型的，您只能在主线程上执行它们；不是来自jobs。</p><p>以下操作被视为结构更改：</p><ul><li>创建或销毁实体。</li><li>添加或删除组件。</li><li>设置一个共享组件值。</li></ul><h3 id="创建一个实体">创建一个实体</h3><p>当您创建一个实体时，Unity要么将实体添加到现有块中，要么如果没有块可用于实体的原型，则创建一个新块并将实体添加到其中。</p><h3 id="销毁一个实体">销毁一个实体</h3><p>当您销毁一个实体时，Unity会将该实体从其块中移除。如果移除实体在块中留下空隙，Unity会移动块中的最后一个实体来填补空隙。如果删除实体使块为空，Unity会释放块。</p><h3 id="添加或删除组件">添加或删除组件</h3><p>在实体中添加或删除组件时，您会更改实体的原型。 Unity将每个实体存储在与实体原型匹配的块中。这意味着如果您更改实体的原型，Unity必须将该实体移动到另一个块。如果不存在合适的块，Unity会创建一个新块。如果移动使前一个块有间隙或留空，Unity将移动块中的最后一个实体以分别填充间隙或释放块。</p><h3 id="设置一个共享组件值">设置一个共享组件值</h3><p>当您设置实体的共享组件的值时，Unity会将实体移动到与新共享组件值匹配的块中。如果不存在合适的块，Unity会创建一个新块。如果移动使前一个块有间隙或为空，Unity将移动块中的最后一个实体以填充间隙或分别释放块。</p><div class="note note-info">            <p>设置常规组件值不是结构更改，因为它不需要 Unity 移动实体。</p>          </div><h3 id="同步点">同步点</h3><p>您不能直接在作业中进行结构更改，因为它可能会使其他已安排的作业无效，并创建一个同步点。</p><p>一个同步点（syncpoint）是程序执行中的一个点，它等待到目前为止已经调度的所有作业完成。同步点会限制您在一段时间内使用作业系统中可用的所有工作线程的能力。因此，您的目标应该是避免同步点。ECS 中数据的结构变化是产生同步点的主要原因。</p><p>结构更改不仅要求同步点，而且还会使对任何组件数据的所有直接引用无效。这包括<code>DynamicBuffer</code>的实例和提供对组件（例如<code>ComponentSystemBase.GetComponentDataFromEntity</code>）的直接访问的方法的结果。</p><h4 id="避免同步点">避免同步点</h4><p>您可以使用实体命令缓冲区来排队缓冲结构更改，而不是立即执行它们。您可以在帧的稍后时间执行存储在实体命令缓冲区中的命令。这将跨帧分布的多个同步点减少为单个同步点。</p><p>每个标准<code>ComponentSystemGroup</code>实例都提供<code>EntityCommandBufferSystem</code>作为组中更新的第一个和最后一个系统。如果您从这些标准系统之一获取实体命令缓冲区对象，则所有结构更改都发生在帧中的同一点，从而产生一个同步点。您还可以使用实体命令缓冲区来记录作业中的结构更改，而不是仅在主线程上进行结构更改。</p><p>如果您不能为任务使用实体命令缓冲区，请将所有进行结构更改的系统按系统执行顺序分组在一起。两个都进行结构更改的系统如果按顺序更新，则只会创建一个同步点。</p><h1 id="实现系统">实现系统</h1><p>系统是每帧在主线程上运行一次的代码单元。系统被组织成系统组的层次结构，您可以使用这些系统组来组织系统更新的顺序。有关ECS 中系统基础知识的更多信息，请参阅系统概念。<br />| 标题 | 描述 |<br />| ————————————- | —————————————————— |<br />| 使用<code>SystemBase</code>创建系统 |有关如何使用<code>SystemBase</code>创建系统的信息。 |<br />| 迭代数据 | 描述了可以迭代系统中数据的各种方法。 |<br />| 系统更新顺序 | 有关系统更新顺序以及如何使用系统组控制更新顺序的信息。|<br />| 使用作业在多个线程上调度数据 | 有关如何在系统中使用作业的信息。|<br />| 使用<code>EntityQuery</code>查询实体数据 |有关使用<code>EntityQuery</code>查询实体数据的信息。 |<br />| 使用<code>EntityCommandBuffer</code>调度数据更改 |使用命令缓冲区来延迟对数据的更改。 |<br />| 查找任意数据 | 有关如何查找任意实体数据的信息。 |<br />| 写入组 | 使用写入组覆盖系统的数据。 |<br />| 版本号 | 使用版本号来检测潜在的变化。 |</p><h2 id="使用systembase创建系统">使用<code>SystemBase</code>创建系统</h2><p>要创建托管系统，请实现抽象类 <code>SystemBase</code>。</p><p>您必须使用 <code>OnUpdate</code>系统事件回调来添加您的系统必须在每一帧执行的工作。<code>ComponentSystemBase</code>命名空间中的所有其他回调方法都是可选的。</p><p>所有系统事件都在主线程上运行。最佳做法是使用 <code>OnUpdate</code>方法来安排作业来执行大部分工作。要从系统安排作业，您可以使用以下机制之一：</p><ul><li><code>Entities.ForEach</code>：遍历组件数据。</li><li><code>Job.WithCode</code>：将 lambda表达式作为单个后台作业执行。</li><li><code>IJobEntity</code>：迭代多个系统中的组件数据。</li><li><code>IJobEntityBatch</code>：按原型块迭代数据。<br />以下示例说明了使用 <code>Entities.ForEach</code>来实现一个系统，该系统根据一个组件的值更新另一个组件：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public struct Position : IComponentData&#123;    public float3 Value;&#125;public struct Velocity : IComponentData&#123;    public float3 Value;&#125;[RequireMatchingQueriesForUpdate]public partial class ECSSystem : SystemBase&#123;    protected override void OnUpdate()    &#123;        &#x2F;&#x2F; Local variable captured in ForEach        float dT &#x3D; SystemAPI.Time.DeltaTime;        Entities            .WithName(&quot;Update_Displacement&quot;)            .ForEach(                (ref Position position, in Velocity velocity) &#x3D;&gt;                &#123;                    position &#x3D; new Position()                    &#123;                        Value &#x3D; position.Value + velocity.Value * dT                    &#125;;                &#125;            )            .ScheduleParallel();    &#125;&#125;</code></pre></div></figure></li></ul><h3 id="回调方法顺序">回调方法顺序</h3><p><code>SystemBase</code> 中有几个回调方法，Unity在系统创建过程中的不同点调用，您可以使用它们来安排系统必须在每一帧执行的工作：</p><ul><li><code>OnCreate</code>：创建系统时调用。</li><li><code>OnStartRunning</code>：在第一次调用 <code>OnUpdate</code>之前以及系统恢复运行时调用。</li><li><code>OnUpdate</code>：只要系统有工作要做，就会在每一帧调用。有关确定系统何时有工作要做的因素的更多信息，请参阅<code>ShouldRunSystem</code>。</li><li><code>OnStopRunning</code>：在 <code>OnDestroy</code>之前调用。每当系统停止运行时也会调用，如果没有实体与系统的<code>EntityQuery</code> 匹配，或者如果系统的 <code>Enabled</code>属性设置为 <code>false</code>，就会发生这种情况。</li><li><code>OnDestroy</code>：系统被销毁时调用。</li></ul><p>下图说明了系统的事件顺序：<br /><imgsrc="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/images/SystemEventOrder.png"alt="回调方法顺序" /><br />父系统组的 <code>OnUpdate</code> 方法触发其组中所有系统的<code>OnUpdate</code>方法。有关系统如何更新的更多信息，请参阅系统的更新顺序。</p><h2 id="迭代数据">迭代数据</h2><p>迭代数据是创建系统时需要执行的最常见任务之一。系统通常处理一组实体，从一个或多个组件读取数据，执行计算，然后将结果写入另一个组件。</p><p>迭代实体和组件的最有效方法是在按顺序处理组件的作业中。这利用了所有可用内核和数据局部性的处理能力来避免CPU 缓存未命中。</p><p>本节介绍如何通过以下方式迭代实体数据：</p><table><thead><tr class="header"><th>标题</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>使用 <code>Entities.ForEach</code> 迭代数据</td><td>如何使用 <code>SystemBase.Entities.ForEach</code>逐个实体地处理组件数据。</td></tr><tr class="even"><td>使用 <code>IJobEntity</code> 迭代数据</td><td>如何使用 <code>IJobEntity</code> 编写一次并创建多个计划。</td></tr><tr class="odd"><td>遍历成批数据</td><td>如何使用 <code>IJobEntityBatch</code>遍历包含匹配实体的原型块。</td></tr><tr class="even"><td>手动迭代数据</td><td>如何手动迭代实体或原型块。</td></tr></tbody></table><p>您还可以使用 EntityQuery类来构建数据视图，其中仅包含给定算法或过程所需的特定数据。上面列表中的许多迭代方法显式或内部使用EntityQuery。有关详细信息，请参阅使用实体查询查询实体数据。</p><h3 id="使用-entities.foreach-迭代数据">使用<code>Entities.ForEach</code> 迭代数据</h3><p>如果您使用 SystemBase 类来创建您的系统，则可以使用 Entities.ForEach构造来定义和执行针对实体及其组件的算法。在编译时，Unity 将每个 ForEach()调用转换为生成的作业。</p><p>您向 Entities.ForEach 传递一个 lambda 表达式，Unity 会根据 lambda参数类型生成一个实体查询。当生成的作业运行时，Unity会为每个与查询匹配的实体调用一次 lambda。 ForEachLambdaJobDescription表示此生成的作业。</p><h4 id="定义一个-lambda-表达式">定义一个 lambda 表达式</h4><p>当您定义 Entities.ForEach lambda 表达式时，您可以声明 SystemBase类在执行该方法时用于传递有关当前实体的信息的参数。</p><p>典型的 lambda 表达式如下所示：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Entities.ForEach(    (Entity entity,        int entityInQueryIndex,        ref ObjectPosition translation,        in Movement move) &#x3D;&gt; &#123; &#x2F;* .. *&#x2F;&#125;)</code></pre></div></figure><br />您最多可以将八个参数传递给 Entities.ForEach lambda表达式。如果需要传递更多参数，可以定义自定义委托。有关详细信息，请参阅本文档中有关自定义委托的部分。</p><p>使用标准委托时，必须按以下顺序对参数进行分组：</p><ol type="1"><li>按值传递的参数（无参数修饰符）</li><li>可写参数（ref参数修饰符）</li><li>只读参数（在参数修饰符中）<br />您必须在所有组件上使用 ref 或 in 参数修改关键字。如果你不这样做，Unity传递给你的方法的组件结构是一个副本而不是引用。这意味着它会为只读参数占用额外的内存，并且当函数返回后复制的结构超出范围时，您对组件所做的任何更改都会被静默抛出。</li></ol><p>如果 lambda表达式不遵循此顺序，并且您还没有创建合适的委托，则编译器会提供类似于以下内容的错误：</p><p>error CS1593: Delegate‘Invalid_ForEach_Signature_See_ForEach_Documentation_For_Rules_And_Restrictions’does not take N arguments</p><p>此错误消息将参数数量作为问题，即使问题是参数顺序也是如此。</p><h5 id="自定义代理">自定义代理</h5><p>如果要在 ForEach lambda表达式中使用八个以上的参数，则必须声明自己的委托类型和 ForEach重载。这允许您使用无限数量的参数，并以您想要的任何顺序放置 ref、in 和value 参数。</p><p>您还可以在参数列表中的任意位置声明三个命名参数entity、entityInQueryIndex 和 nativeThreadIndex。不要对这些参数使用 ref或 in 修饰符。</p><p>以下示例显示 12 个参数，并在 lambda 表达式中使用实体参数：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">static class BringYourOwnDelegate&#123;    &#x2F;&#x2F; Declare the delegate that takes 12 parameters. T0 is used for the Entity argument    public delegate void CustomForEachDelegate&lt;T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11&gt;        (T0 t0, in T1 t1, in T2 t2, in T3 t3, in T4 t4, in T5 t5,         in T6 t6, in T7 t7, in T8 t8, in T9 t9, in T10 t10, in T11 t11);    &#x2F;&#x2F; Declare the function overload    public static TDescription ForEach&lt;TDescription, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11&gt;        (this TDescription description, CustomForEachDelegate&lt;T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11&gt; codeToRun)        where TDescription : struct, Unity.Entities.CodeGeneratedJobForEach.ISupportForEachWithUniversalDelegate &#x3D;&gt;        LambdaForEachDescriptionConstructionMethods.ThrowCodeGenException&lt;TDescription&gt;();&#125;&#x2F;&#x2F; A system that uses the custom delegate and overload[RequireMatchingQueriesForUpdate]public partial class MayParamsSystem : SystemBase&#123;    protected override void OnUpdate()    &#123;        Entities.ForEach(                (Entity entity0,                    in Data1 d1,                    in Data2 d2,                    in Data3 d3,                    in Data4 d4,                    in Data5 d5,                    in Data6 d6,                    in Data7 d7,                    in Data8 d8,                    in Data9 d9,                    in Data10 d10,                    in Data11 d11                    ) &#x3D;&gt; &#123;&#x2F;* .. *&#x2F;&#125;)            .Run();    &#125;&#125;</code></pre></div></figure></p><h5 id="组件参数">组件参数</h5><p>要访问与实体关联的组件，您必须将该组件类型的参数传递给 lambda表达式。编译器会自动将传递给 lambda表达式的所有组件作为必需组件添加到实体查询中。</p><p>要更新组件值，您必须使用参数列表中的 ref 关键字将其传递给 lambda表达式。如果没有 ref 关键字，Unity 将对组件的临时副本进行任何修改。</p><p>要声明传递给 lambda 表达式的只读组件，请使用参数列表中的 in关键字。</p><p>当您使用 ref 时，Unity 会将当前块中的组件标记为已更改，即使 lambda表达式实际上并未修改它们。为了提高效率，您应该始终使用 in 关键字将您的lambda 表达式未修改的组件声明为只读。</p><p>以下示例将 Source 组件参数作为只读传递给作业，并将 Destination组件参数作为可写传递：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Entities.ForEach(    (ref Destination outputData,        in Source inputData) &#x3D;&gt;    &#123;        outputData.Value &#x3D; inputData.Value;    &#125;)    .ScheduleParallel();</code></pre></div></figure></p><div class="note note-waring">            <p>You can’t pass chunk components to the Entities.ForEach lambdaexpression.</p>          </div><p>对于动态缓冲区，使用 DynamicBuffer<T>而不是缓冲区中存储的组件类型：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">[RequireMatchingQueriesForUpdate]public partial class BufferSum : SystemBase&#123;    private EntityQuery query;    &#x2F;&#x2F;Schedules the two jobs with a dependency between them    protected override void OnUpdate()    &#123;        &#x2F;&#x2F;The query variable can be accessed here because we are        &#x2F;&#x2F;using WithStoreEntityQueryInField(query) in the entities.ForEach below        int entitiesInQuery &#x3D; query.CalculateEntityCount();        &#x2F;&#x2F;Create a native array to hold the intermediate sums        &#x2F;&#x2F;(one element per entity)        NativeArray&lt;int&gt; intermediateSums            &#x3D; new NativeArray&lt;int&gt;(entitiesInQuery, Allocator.TempJob);        &#x2F;&#x2F;Schedule the first job to add all the buffer elements        Entities            .ForEach((int entityInQueryIndex, in DynamicBuffer&lt;IntBufferData&gt; buffer) &#x3D;&gt;        &#123;            for (int i &#x3D; 0; i &lt; buffer.Length; i++)            &#123;                intermediateSums[entityInQueryIndex] +&#x3D; buffer[i].Value;            &#125;        &#125;)            .WithStoreEntityQueryInField(ref query)            .WithName(&quot;IntermediateSums&quot;)            .ScheduleParallel(); &#x2F;&#x2F; Execute in parallel for each chunk of entities        &#x2F;&#x2F;Schedule the second job, which depends on the first        Job.WithCode(() &#x3D;&gt;        &#123;            int result &#x3D; 0;            for (int i &#x3D; 0; i &lt; intermediateSums.Length; i++)            &#123;                result +&#x3D; intermediateSums[i];            &#125;            &#x2F;&#x2F;Not burst compatible:            Debug.Log(&quot;Final sum is &quot; + result);        &#125;)            .WithDisposeOnCompletion(intermediateSums)            .WithoutBurst()            .WithName(&quot;FinalSum&quot;)            .Schedule(); &#x2F;&#x2F; Execute on a single, background thread    &#125;&#125;</code></pre></div></figure></p><h5 id="命名参数">命名参数</h5><p>您还可以将以下命名参数传递给 Entities.ForEach lambda 表达式，Unity根据作业正在处理的实体为其分配值。<br />| 参数 | 函数 |<br />| ———————– |—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————-|<br />| Entity entity | 当前实体的实体实例。只要类型是Entity，您就可以将参数命名为任何名称。 |<br />| int entityInQueryIndex |实体在查询选择的所有实体列表中的索引。当您有一个需要为每个实体填充唯一值的本机数组时，请使用实体索引值。您可以使用entityInQueryIndex 作为该数组中的索引。您应该使用 entityInQueryIndex作为 sortKey 将命令添加到并发实体命令缓冲区。 |<br />| int nativeThreadIndex | 执行 lambda表达式当前迭代的线程的唯一索引。当您使用 Run() 执行 lambda表达式时，nativeThreadIndex 始终为零。不要使用 nativeThreadIndex作为并发实体命令缓冲区的 sortKey；使用 entityInQueryIndex 代替。 |<br />| EntityCommands commands | 只要类型是EntityCommands，您就可以将此参数命名为任何名称。仅将此参数与WithDeferredPlaybackSystem<T>() 或 WithImmediatePlayback() 结合使用。EntityCommands 类型包含几个方法，这些方法反映了 EntityCommandBuffer类型中的对应方法。如果您在 Entities.ForEach() 中使用 EntityCommands实例，编译器会在适当的地方创建额外的代码来处理实体命令缓冲区的创建、调度、播放和处置，在这些代码上调用EntityCommands 方法的对应方法。 |</p><h4 id="执行-entities.foreach-lambda-表达式">执行 Entities.ForEachlambda 表达式</h4><p>您可以通过以下方式执行作业 lambda 表达式：</p><ul><li>使用 Schedule() 和 ScheduleParallel() 来安排作业</li><li>使用 Run() 立即在主线程上执行作业。<br />以下示例说明了使用 Entities.ForEach 读取 Velocity 组件并写入ObjectPosition 组件的 SystemBase 实现：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">[RequireMatchingQueriesForUpdate]partial class ApplyVelocitySystem : SystemBase&#123;    protected override void OnUpdate()    &#123;        Entities.ForEach((ref ObjectPosition translation,            in Velocity velocity) &#x3D;&gt;            &#123;                translation.Value +&#x3D; velocity.Value;            &#125;)            .Schedule();    &#125;&#125;</code></pre></div></figure></li></ul><h4 id="选择实体">选择实体</h4><p>Entities.ForEach有自己的机制来定义用于选择要处理的实体的实体查询。该查询会自动包含您用作lambda 表达式参数的任何组件。</p><p>您还可以使用 WithAll、WithAny 和 WithNone 子句进一步细化Entities.ForEach 选择的实体。有关查询选项的完整列表，请参阅SystemBase.Entities。</p><p>以下示例使用这些子句根据这些参数选择实体：</p><ul><li>该实体具有组件、Destination、Source 和 LocalToWorld</li><li>实体至少具有以下组件之一：ObjectRotation、ObjectPosition 或ObjectUniformScale</li><li>该实体没有 ObjectNonUniformScale 组件。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Entities.WithAll&lt;LocalToWorld&gt;()    .WithAny&lt;Rotation, ObjectPosition, ObjectUniformScale&gt;()    .WithNone&lt;ObjectNonUniformScale&gt;()    .ForEach((ref Destination outputData, in Source inputData) &#x3D;&gt;    &#123;        &#x2F;* do some work *&#x2F;    &#125;)    .Schedule();</code></pre></div></figure><br />在此示例中，在 lambda 表达式中仅访问 Destination 和 Source组件，因为它们是参数列表中的唯一组件。</li></ul><h4 id="访问-entityquery-对象">访问 EntityQuery 对象</h4><p>Entities.ForEach 在 OnCreate 中创建一个EntityQuery，您可以随时使用它的副本，甚至在调用 Entities.ForEach之前。</p><p>要访问此实体查询，请使用带有 ref 参数修饰符的WithStoreEntityQueryInField(refquery)。此方法将对查询的引用分配给您提供的字段。但是，此 EntityQuery没有 Entities.ForEach 调用设置的任何过滤器。</p><p>以下示例说明如何访问为 Entities.ForEach 构造隐式创建的 EntityQuery对象。它使用 EntityQuery 对象调用 CalculateEntityCount()方法并使用此计数创建一个具有足够空间的本机数组来为查询选择的每个实体存储一个值：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private EntityQuery query;protected override void OnUpdate()&#123;    int dataCount &#x3D; query.CalculateEntityCount();    NativeArray&lt;float&gt; dataSquared        &#x3D; new NativeArray&lt;float&gt;(dataCount, Allocator.Temp);    Entities        .WithStoreEntityQueryInField(ref query)        .ForEach((int entityInQueryIndex, in Data data) &#x3D;&gt;        &#123;            dataSquared[entityInQueryIndex] &#x3D; data.Value * data.Value;        &#125;)        .ScheduleParallel();    Job        .WithCode(() &#x3D;&gt;    &#123;        &#x2F;&#x2F;Use dataSquared array...        var v &#x3D; dataSquared[dataSquared.Length - 1];    &#125;)        .WithDisposeOnCompletion(dataSquared)        .Schedule();&#125;</code></pre></div></figure></p><h4 id="访问可选组件">访问可选组件</h4><p>Entities.ForEach lambda 表达式不支持使用 WithAny&lt;T,U&gt;查询和访问可选组件。</p><p>如果要读取或写入可选组件，请将 Entities.ForEach构造拆分为可选组件的每个组合的多个作业。例如，如果您有两个可选组件，则需要三个ForEach结构：一个包含第一个可选组件，一个包含第二个可选组件，一个包含两个组件。另一种选择是按块使用IJobChunkiterate。有关详细信息，请参阅按批次迭代数据。</p><h4 id="更改过滤">更改过滤</h4><p>您可以使用 WithChangeFilter<T> 来启用更改过滤，只有在当前 SystemBase实例上次运行后实体中的另一个组件发生更改时，它才会处理组件。更改过滤器中的组件类型必须在lambda 表达式参数列表中，或者是 WithAll<T> 语句的一部分。例如：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Entities    .WithChangeFilter&lt;Source&gt;()    .ForEach((ref Destination outputData,        in Source inputData) &#x3D;&gt;        &#123;            &#x2F;* Do work *&#x2F;        &#125;)    .ScheduleParallel();</code></pre></div></figure><br />实体查询最多支持对两种组件类型进行更改过滤。</p><p>Unity在原型块级别应用更改过滤。如果任何代码访问具有写访问权限的块中的组件，那么Unity会将该原型块中的组件类型标记为已更改，即使代码没有更改任何数据。</p><h4 id="共享组件过滤">共享组件过滤</h4><p>Unity将具有共享组件的实体与其他具有相同共享组件值的实体分组。要选择具有特定共享组件值的实体组，请使用WithSharedComponentFilter 方法。</p><p>以下示例选择按 Cohort ISharedComponentData 分组的实体。此示例中的lambda 表达式根据实体的群组设置 DisplayColor IComponentData 组件：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">[RequireMatchingQueriesForUpdate]public partial class ColorCycleJob : SystemBase&#123;    protected unsafe override void OnUpdate()    &#123;        EntityManager.GetAllUniqueSharedComponents&lt;Cohort&gt;(out var cohorts, Allocator.Temp);        for (int i&#x3D;0; i&lt;cohorts.Length; i++)        &#123;            var cohort &#x3D; cohorts[i];            DisplayColor newColor &#x3D; ColorTable.GetNextColor(cohort.Value);            Entities.WithSharedComponentFilter(cohort)                .ForEach((ref DisplayColor color) &#x3D;&gt; &#123; color &#x3D; newColor; &#125;)                .ScheduleParallel();        &#125;    &#125;&#125;</code></pre></div></figure><br />该示例使用 EntityManager获取所有唯一同类群组值。然后它为每个队列安排一个 lambda作业，并将新颜色作为捕获变量传递给 lambda 表达式。</p><h4 id="捕获变量">捕获变量</h4><p>您可以捕获 Entities.ForEach lambda 表达式的局部变量。当您调用其中一种Schedule 方法而不是 Run 来使用作业来执行 lambda表达式时，对捕获的变量以及如何使用它们有一些限制：</p><ul><li>您只能捕获本机容器和 blittable 类型。</li><li>作业只能写入作为本机容器的捕获变量。要返回单个值，请创建一个包含一个元素的本机数组。</li></ul><p>如果您读取本机容器，但不写入它，请始终使用 WithReadOnly(variable)指定只读访问权限。有关为捕获的变量设置属性的详细信息，请参阅SystemBase.Entities。 Entities.ForEach 将这些作为方法提供，因为 C#语言不允许局部变量的属性。</p><p>要在 Entities.ForEach运行后处理捕获的本机容器或包含本机容器的类型，请使用WithDisposeOnCompletion(variable)。如果您在 Run() 中调用它，它会在lambda 表达式运行后立即处理这些类型。如果您在 Schedule() 和ScheduleParallel() 中调用它，它会安排它们稍后与作业一起处理，并返回JobHandle。</p><div class="note note-info">            <p>当您使用 Run()执行该方法时，您可以写入不是本机容器的捕获变量。但是，您仍应尽可能使用blittable 类型，以便可以使用 Burst 编译该方法。</p>          </div><h4 id="支持的功能">支持的功能</h4><p>使用 Run() 在主线程上执行 lambda 表达式。您还可以使用 Schedule()将其作为单个作业执行，或使用 ScheduleParallel()将其作为并行作业执行。这些不同的执行方法对您访问数据的方式有不同的限制。此外，Burst编译器使用 C# 语言的一个受限子集，因此如果要在该子集之外使用 C#功能，则需要指定 WithoutBurst()。这包括访问托管类型。</p><p>下表显示了 Entities.ForEach 中支持哪些功能，用于 SystemBase中可用的不同调度方法：<br />| 支持的功能 | Run | Schedule | ScheduleParallel |<br />| ———————————– | ——————————————— | ——– | —————- |<br />| Capture local value type | ✓ | ✓ | ✓ |<br />| Capture local reference type | Only WithoutBurst and not in ISystem ||<br />| Writing to captured variables | ✓ |<br />| Use field on the system class | Only WithoutBurst |<br />| Methods on reference types | Only WithoutBurst and not in ISystem|<br />| Shared Components | Only WithoutBurst and not in ISystem |<br />| Managed Components | Only WithoutBurst and not in ISystem |<br />| Structural changes | Only WithStructuralChanges and not in ISystem|<br />| SystemBase.GetComponent | ✓ | ✓ | ✓ |<br />| SystemBase.SetComponent | ✓ | ✓ |<br />| GetComponentDataFromEntity | ✓ | ✓ | Only as ReadOnly |<br />| HasComponent | ✓ | ✓ | ✓ |<br />| WithDisposeOnCompletion | ✓ | ✓ | ✓ |<br />| WithScheduleGranularity | | | ✓ |<br />| WithDeferredPlaybackSystem | ✓ | ✓ | ✓ |<br />| WithImmediatePlayback | ✓ | |<br />| HasBuffer | ✓ | ✓ | ✓ |<br />| SystemBase.GetStorageInfoFromEntity | ✓ | ✓ | ✓ |<br />| SystemBase.Exists | ✓ | ✓ | ✓ |</p><div class="note note-waring">            <p>WithStructuralChanges() 禁用突发。如果您想获得高性能Entities.ForEach，请不要使用此选项。如果要使用此选项，请使用EntityCommandBuffer。</p>          </div><p>Entities.ForEach 构造使用 Roslyn源代码生成器将您为构造编写的代码转换为正确的 ECS代码。这种翻译意味着您可以表达算法的意图，而无需包含复杂的样板代码。但是，这意味着一些常见的代码编写方式是不允许的。</p><p>不支持以下功能：</p><ul><li>.With 调用中的动态代码</li><li>SharedComponent 参数由 ref</li><li>嵌套 Entities.ForEach lambda 表达式</li><li>使用存储在变量、字段或方法中的委托进行调用</li><li>具有 lambda 参数类型的 SetComponent</li><li>具有可写 lambda 参数的 GetComponent</li><li>lambdas 中的通用参数</li><li>在具有通用参数的系统中</li></ul><h4 id="依赖关系">依赖关系</h4><p>默认情况下，系统使用其 Dependency 属性来管理其与 ECS相关的依赖项。默认情况下，系统按照它们在 OnUpdate()函数中出现的顺序将使用 Entities.ForEach 和 Job.WithCode创建的每个作业添加到依赖作业句柄。您还可以将 JobHandle 传递给您的Schedule方法以手动管理作业依赖性，然后返回生成的依赖性。有关详细信息，请参阅依赖项文档。</p><p>有关作业依赖性的更多一般信息，请参阅作业依赖性。</p><h3 id="使用-ijobentity-迭代数据">使用 <code>IJobEntity</code>迭代数据</h3><p>当您在多个系统中使用不同的调用进行数据转换时，要遍历ComponentData，您可以使用 IJobEntity，它类似于 Entities.ForEach。</p><p>它创建一个 IJobEntityBatch 作业，因此您只需考虑要转换的数据。</p><h4 id="ijobentity-和-entities.foreach-的比较">IJobEntity 和Entities.ForEach 的比较</h4><p>IJobEntity 相对于 Entities.ForEach的优势在于您可以编写一次代码并在多个系统中重复使用它，而不是仅一次。</p><p>这是一个 Entities.ForEach 示例：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">[RequireMatchingQueriesForUpdate]public partial class BoidForEachSystem : SystemBase&#123;    EntityQuery m_BoidQuery;    EntityQuery m_ObstacleQuery;    EntityQuery m_TargetQuery;    protected override void OnUpdate()    &#123;        &#x2F;&#x2F; Calculate amount of entities in respective queries.        var boidCount &#x3D; m_BoidQuery.CalculateEntityCount();        var obstacleCount &#x3D; m_ObstacleQuery.CalculateEntityCount();        var targetCount &#x3D; m_TargetQuery.CalculateEntityCount();        &#x2F;&#x2F; Allocate arrays to store data equal to the amount of entities matching respective queries.        var cellSeparation &#x3D; CollectionHelper.CreateNativeArray&lt;float3, RewindableAllocator&gt;(boidCount, ref World.UpdateAllocator);        var copyTargetPositions &#x3D; CollectionHelper.CreateNativeArray&lt;float3, RewindableAllocator&gt;(targetCount, ref World.UpdateAllocator);        var copyObstaclePositions &#x3D; CollectionHelper.CreateNativeArray&lt;float3, RewindableAllocator&gt;(obstacleCount, ref World.UpdateAllocator);        &#x2F;&#x2F; Schedule job for respective arrays to be stored with respective queries.        Entities            .WithSharedComponentFilter(new BoidSetting&#123;num&#x3D;1&#125;)            .ForEach((int entityInQueryIndex, in LocalToWorld localToWorld) &#x3D;&gt;            &#123;                cellSeparation[entityInQueryIndex] &#x3D; localToWorld.Position;            &#125;)            .ScheduleParallel();        Entities            .WithAll&lt;BoidTarget&gt;()            .WithStoreEntityQueryInField(ref m_TargetQuery)            .ForEach((int entityInQueryIndex, in LocalToWorld localToWorld) &#x3D;&gt;            &#123;                copyTargetPositions[entityInQueryIndex] &#x3D; localToWorld.Position;            &#125;)            .ScheduleParallel();        Entities            .WithAll&lt;BoidObstacle&gt;()            .WithStoreEntityQueryInField(ref m_ObstacleQuery)            .ForEach((int entityInQueryIndex, in LocalToWorld localToWorld) &#x3D;&gt;            &#123;                copyObstaclePositions[entityInQueryIndex] &#x3D; localToWorld.Position;            &#125;)            .ScheduleParallel();    &#125;&#125;</code></pre></div></figure><br />可以改写如下：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">[RequireMatchingQueriesForUpdate]public partial class BoidJobEntitySystem : SystemBase&#123;    EntityQuery m_BoidQuery;    EntityQuery m_ObstacleQuery;    EntityQuery m_TargetQuery;    protected override void OnUpdate()    &#123;        &#x2F;&#x2F; Calculate amount of entities in respective queries.        var boidCount &#x3D; m_BoidQuery.CalculateEntityCount();        var obstacleCount &#x3D; m_ObstacleQuery.CalculateEntityCount();        var targetCount &#x3D; m_TargetQuery.CalculateEntityCount();        &#x2F;&#x2F; Allocate arrays to store data equal to the amount of entities matching respective queries.        var cellSeparation &#x3D; CollectionHelper.CreateNativeArray&lt;float3, RewindableAllocator&gt;(boidCount, ref World.UpdateAllocator);        var copyTargetPositions &#x3D; CollectionHelper.CreateNativeArray&lt;float3, RewindableAllocator&gt;(targetCount, ref World.UpdateAllocator);        var copyObstaclePositions &#x3D; CollectionHelper.CreateNativeArray&lt;float3, RewindableAllocator&gt;(obstacleCount, ref World.UpdateAllocator);        &#x2F;&#x2F; Schedule job for respective arrays to be stored with respective queries.        new CopyPositionsJob &#123; copyPositions &#x3D; cellSeparation&#125;.ScheduleParallel(m_BoidQuery);        new CopyPositionsJob &#123; copyPositions &#x3D; copyTargetPositions&#125;.ScheduleParallel(m_TargetQuery);        new CopyPositionsJob &#123; copyPositions &#x3D; copyObstaclePositions&#125;.ScheduleParallel(m_ObstacleQuery);    &#125;    protected override void OnCreate()    &#123;        &#x2F;&#x2F; Get respective queries, that includes components required by &#96;CopyPositionsJob&#96; described earlier.        m_BoidQuery &#x3D; GetEntityQuery(typeof(LocalToWorld));        m_BoidQuery.SetSharedComponentFilter(new BoidSetting&#123;num&#x3D;1&#125;);        m_ObstacleQuery &#x3D; GetEntityQuery(typeof(LocalToWorld), typeof(BoidObstacle));        m_TargetQuery &#x3D; GetEntityQuery(typeof(LocalToWorld), typeof(BoidTarget));;    &#125;&#125;</code></pre></div></figure></p><h4 id="创建-ijobentity-作业">创建 IJobEntity 作业</h4><p>要创建 IJobEntity 作业，请编写一个使用 IJobEntity接口的结构，并实现您自己的自定义 Execute 方法。</p><p>使用 partial 关键字是因为源代码生成创建了一个结构，该结构在project/Temp/GeneratedCode/….. 中找到的单独文件中实现IJobEntityBatch。</p><p>以下示例每帧向每个 SampleComponent 添加一个。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public struct SampleComponent : IComponentData &#123; public float Value; &#125;public partial struct ASampleJob : IJobEntity&#123;    &#x2F;&#x2F; Adds one to every SampleComponent value    void Execute(ref SampleComponent sample)    &#123;        sample.Value +&#x3D; 1f;    &#125;&#125;public partial class ASample : SystemBase&#123;    protected override void OnUpdate()    &#123;        &#x2F;&#x2F; Schedules the job        new ASampleJob().ScheduleParallel();    &#125;&#125;</code></pre></div></figure></p><h4 id="指定查询">指定查询</h4><p>您可以通过以下方式指定 IJobEntity 的查询：</p><ul><li>手动创建查询，以指定不同的调用要求。</li><li>让已实施的 IJobEntity 为您完成，基于其给定的执行参数，以及使用属性[WithAll(params Type)]、[WithAny(params Type)]、[WithNone(paramsType)]、[ WithChangeFilter(params Type)] 和[WithEntityQueryOptions((params EntityQueryOptions)]。<br />以下示例显示了这两个选项：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">partial struct QueryJob : IJobEntity&#123;    &#x2F;&#x2F; Iterates over all SampleComponents and increments their value    public void Execute(ref SampleComponent sample)    &#123;        sample.Value +&#x3D; 1;    &#125;&#125;[RequireMatchingQueriesForUpdate]public partial class QuerySystem : SystemBase&#123;    &#x2F;&#x2F; Query that matches QueryJob, specified for &#96;BoidTarget&#96;    EntityQuery query_boidtarget;    &#x2F;&#x2F; Query that matches QueryJob, specified for &#96;BoidObstacle&#96;    EntityQuery query_boidobstacle;    protected override void OnCreate()    &#123;        &#x2F;&#x2F; Query that contains all of Execute params found in &#96;QueryJob&#96; - as well as additional user specified component &#96;BoidTarget&#96;.        query_boidtarget &#x3D; GetEntityQuery(ComponentType.ReadWrite&lt;SampleComponent&gt;(),ComponentType.ReadOnly&lt;BoidTarget&gt;());        &#x2F;&#x2F; Query that contains all of Execute params found in &#96;QueryJob&#96; - as well as additional user specified component &#96;BoidObstacle&#96;.        query_boidobstacle &#x3D; GetEntityQuery(ComponentType.ReadWrite&lt;SampleComponent&gt;(),ComponentType.ReadOnly&lt;BoidObstacle&gt;());    &#125;    protected override void OnUpdate()    &#123;        &#x2F;&#x2F; Uses the BoidTarget query        new QueryJob().ScheduleParallel(query_boidtarget);        &#x2F;&#x2F; Uses the BoidObstacle query        new QueryJob().ScheduleParallel(query_boidobstacle);        &#x2F;&#x2F; Uses query created automatically that matches parameters found in &#96;QueryJob&#96;.        new QueryJob().ScheduleParallel();    &#125;&#125;</code></pre></div></figure></li></ul><h5 id="属性">属性</h5><p>因为 IJobEntity类似于作业，所以您可以使用对作业起作用的所有属性：</p><ul><li>Unity.Burst.BurstCompile</li><li>Unity.Collections.DeallocateOnJobCompletion</li><li>Unity.Collections.NativeDisableParallelForRestriction</li><li>Unity.Burst.BurstDiscard</li><li>Unity.Collections.LowLevel.Unsafe.NativeSetThreadIndex</li><li>Unity.Collections.NativeDisableParallelForRestriction</li><li>Unity.Burst.NoAlia</li></ul><p>IJobEntity 还具有您可以使用的其他属性：<br />| 属性 | 描述 |<br />| —————————————————————— | ————————————————————————————————————————|<br />| Unity.Entities.WithAll(params Type[]) |在作业结构上设置。缩小查询范围，使实体必须匹配提供的所有类型。 |<br />| Unity.Entities.WithAny(params Type[]) |在作业结构上设置。缩小查询范围，使实体必须匹配所提供的任何类型。 |<br />| Unity.Entities.WithNone(params Type[]) |在作业结构上设置。缩小查询范围，使实体不必匹配所提供的任何类型。 |<br />| Unity.Entities.WithChangeFilter(params Type[]) |在作业结构上设置或附加到执行中的参数。缩小查询范围，以便实体必须在给定组件的原型块中进行更改。|<br />| Unity.Entities.WithEntityQueryOptions(params EntityQueryOptions[]) |在作业结构上设置。更改查询范围以使用描述的 EntityQueryOptions。 |<br />| Unity.Entities.EntityInQueryIndex | 在 Execute 中设置 int参数以获取查询中的当前索引，用于当前实体迭代。这与 Entities.ForEach 中的entityInQueryIndex 相同。 |</p><p>以下是 EntityInQueryIndex 的示例：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">[BurstCompile]partial struct CopyPositionsJob : IJobEntity&#123;    public NativeArray&lt;float3&gt; copyPositions;    &#x2F;&#x2F; Iterates over all &#96;LocalToWorld&#96; and stores their position inside &#96;copyPositions&#96;.    public void Execute([EntityInQueryIndex] int entityInQueryIndex, in LocalToWorld localToWorld)    &#123;        copyPositions[entityInQueryIndex] &#x3D; localToWorld.Position;    &#125;&#125;[RequireMatchingQueriesForUpdate]public partial class EntityInQuerySystem : SystemBase&#123;    &#x2F;&#x2F; This query should match &#96;CopyPositionsJob&#96; parameters    EntityQuery query;    protected override void OnCreate()    &#123;        &#x2F;&#x2F; Get query that matches &#96;CopyPositionsJob&#96; parameters        query &#x3D; GetEntityQuery(ComponentType.ReadOnly&lt;LocalToWorld&gt;());    &#125;    protected override void OnUpdate()    &#123;        &#x2F;&#x2F; Get a native array equal to the size of the amount of entities found by the query.        var positions &#x3D; new NativeArray&lt;float3&gt;(query.CalculateEntityCount(), World.UpdateAllocator.ToAllocator);        &#x2F;&#x2F; Schedule job on parallel threads for this array.        new CopyPositionsJob&#123;copyPositions &#x3D; positions&#125;.ScheduleParallel();        &#x2F;&#x2F; Dispose the array of positions found by the job.        positions.Dispose(Dependency);    &#125;&#125;</code></pre></div></figure></p><h5 id="执行参数">执行参数</h5><p>以下是您可以在 IJobEntity 中使用的所有受支持的执行参数的列表：</p><table><thead><tr class="header"><th>参数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>IComponentData</td><td>标记为 ref 用于读写访问，或标记为对 ComponentData 的只读访问。</td></tr><tr class="even"><td>ICleanupComponentData</td><td>标记为 ref 用于读写访问，或标记为对 ComponentData 的只读访问。</td></tr><tr class="odd"><td>ISharedComponent</td><td>标记为只读访问SharedComponentData。如果这是托管的，你不能突发编译或安排它。使用 .Run代替。</td></tr><tr class="even"><td>Managed components</td><td>使用值副本进行读写访问，或使用 in标记对托管组件进行只读访问。例如，UnityEngine.Transform。将托管组件标记为ref 是错误的，您不能对其进行突发编译或调度。使用 .Run 代替。</td></tr><tr class="odd"><td>Entity</td><td>获取当前实体。这只是一个值副本，所以不要用 ref 或 in 标记。</td></tr><tr class="even"><td>DynamicBuffer<T></td><td>获取动态缓冲区。用 ref 标记为读写访问，用 in 标记为只读访问。</td></tr><tr class="odd"><td>IAspect</td><td>获取方面。方面充当参考，因此您无法分配它们。但是，您可以使用 ref 和value-copy 将其标记为可读写，并将其标记为只读访问。</td></tr><tr class="even"><td>int</td><td>支持三种整数：</td></tr><tr class="odd"><td></td><td>使用属性 [Unity.Entities.ChunkIndexInQuery] 标记 int以获取查询中的当前原型块索引。</td></tr><tr class="even"><td></td><td>使用属性 [Unity.Entities.EntityIndexInChunk] 标记 int以获取当前原型块中的当前实体索引。您可以添加 EntityIndexInChunk 和ChunkIndexInQuery 以获得每个实体的唯一标识符。</td></tr><tr class="odd"><td></td><td>使用属性 [Unity.Entities.EntityInQueryIndex] 标记 int以获取查询的打包索引。这对性能有影响，使用EntityQuery.CalculateBaseEntityIndexArray[Async]。</td></tr></tbody></table><h3 id="遍历成批数据">遍历成批数据</h3><p>在系统内实施 IJobEntityBatch 或 IJobEntityBatchWithIndex以在实体批次中迭代数据。</p><p>当您在系统的 OnUpdate 函数中计划 IJobEntityBatch作业时，系统会使用您传递给计划函数的实体查询来识别应该传递给该作业的块。该作业会为这些块中的每批实体调用一次您的Execute函数。默认情况下，批处理大小是一个完整的块，但您可以在调度作业时将批处理大小设置为块的一部分。无论批次大小如何，给定批次中的实体始终存储在同一块中。在作业的执行函数中，您可以逐个实体地迭代每个批次中的数据。</p><p>当您需要批次集中所有实体的索引值时，请使用IJobEntityBatchWithIndex。否则，IJobEntityBatch效率更高，因为它不需要计算这些索引。</p><p>要实施批处理作业：</p><ol type="1"><li><p>使用 EntityQuery 查询数据以确定要处理的实体。</p></li><li><p>使用 IJobEntityBatch 或 IJobEntityBatchWithIndex定义作业结构。</p></li><li><p>声明您的作业访问的数据。在作业结构中，包括用于标识作业必须直接访问的组件类型的ComponentTypeHandle对象的字段。此外，指定作业是读取还是写入这些组件。您还可以包含标识您要查找的实体数据的字段，这些实体不属于查询的一部分，以及用于非实体数据的字段。</p></li><li><p>编写作业结构的执行函数来转换您的数据。获取作业读取或写入的组件的NativeArray 实例，然后迭代当前批处理以执行所需的工作。</p></li><li><p>在系统 OnUpdate函数中安排作业，将标识要处理的实体的实体查询传递给调度函数。</p></li></ol><div class="note note-info">            <p>与使用 Entities.ForEach 相比，使用 IJobEntityBatch 或IJobEntityBatchWithIndex进行迭代更复杂并且需要更多的代码设置，并且只应在必要或更有效时使用。</p>          </div><p>有关详细信息，ECS 示例存储库包含一个简单的 HelloCube示例，该示例演示了如何使用 IJobEntityBatch。</p><h4 id="使用-entityquery-查询数据">使用 EntityQuery 查询数据</h4><p>EntityQuery 定义了 EntityArchetype必须包含的组件类型集，系统才能处理其关联的块和实体。原型可以有额外的组件，但它必须至少有查询定义的组件。您还可以排除包含特定类型组件的原型。</p><p>将选择您的作业应处理的实体的查询传递给您用于安排作业的计划方法。</p><p>有关定义查询的信息，请参阅使用 EntityQuery 查询数据。</p><div class="note note-info">            <p>不要在 EntityQuery 中包含完全可选的组件。要处理可选组件，请使用IJobEntityBatch.Execute 中的 ArchetypeChunk.Has 方法来确定当前ArchetypeChunk是否具有可选组件。因为同一批次中的所有实体都具有相同的组件，所以您只需要检查每个批次是否存在可选组件一次，而不是每个实体一次。</p>          </div><h4 id="定义作业结构">定义作业结构</h4><p>作业结构由执行要执行的工作的执行函数和声明执行函数使用的数据的字段组成。</p><p>典型的 IJobEntityBatch 作业结构如下所示：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public struct UpdateTranslationFromVelocityJob : IJobEntityBatch&#123;    public ComponentTypeHandle&lt;VelocityVector&gt; velocityTypeHandle;    public ComponentTypeHandle&lt;ObjectPosition&gt; translationTypeHandle;    public float DeltaTime;    [BurstCompile]    public void Execute(ArchetypeChunk batchInChunk, int batchIndex)    &#123;        NativeArray&lt;VelocityVector&gt; velocityVectors &#x3D;            batchInChunk.GetNativeArray(velocityTypeHandle);        NativeArray&lt;ObjectPosition&gt; translations &#x3D;            batchInChunk.GetNativeArray(translationTypeHandle);        for(int i &#x3D; 0; i &lt; batchInChunk.Count; i++)        &#123;            float3 translation &#x3D; translations[i].Value;            float3 velocity &#x3D; velocityVectors[i].Value;            float3 newTranslation &#x3D; translation + velocity * DeltaTime;            translations[i] &#x3D; new ObjectPosition() &#123; Value &#x3D; newTranslation &#125;;        &#125;    &#125;&#125;</code></pre></div></figure><br />此示例访问实体的两个组件 VelocityVector 和 Translation的数据，并根据自上次更新以来经过的时间计算新的平移。</p><h5 id="ijobentitybatch-与-ijobentitybatchwithindex">IJobEntityBatch 与IJobEntityBatchWithIndex</h5><p>IJobEntityBatch 和 IJobEntityBatchWithIndex 之间的唯一区别是IJobEntityBatchWithIndex 在对批处理调用 Execute 函数时传递一个indexOfFirstEntityInQuery参数。该参数为当前batch中第一个实体在实体查询选中的所有实体列表中的索引。</p><p>当您需要每个实体的单独索引时，请使用IJobEntityBatchWithIndex。例如，如果您为每个实体计算一个唯一的结果，您可以使用此索引将每个结果写入本机数组的不同元素。如果您不使用indexOfFirstEntityInQuery 值，请改用IJobEntityBatch，以避免计算索引值的开销。</p><div class="note note-info">            <p>当您向 [EntityCommandBuffer.ParallelWriter] 添加命令时，您可以使用batchIndex 参数作为命令缓冲区函数的 sortKey 参数。您不需要仅使用IJobEntityBatchWithIndex来为每个实体获取唯一的排序键。两种作业类型都可用的 batchIndex参数可用于此目的。</p>          </div><h5 id="声明您的工作访问的数据">声明您的工作访问的数据</h5><p>作业结构中的字段声明可用于 Execute函数的数据。这些领域分为四大类：</p><ul><li><p>ComponentTypeHandle 字段——组件句柄字段允许您的 Execute函数访问存储在当前块中的实体组件和缓冲区。请参阅访问实体组件和缓冲区数据。</p></li><li><p>ComponentLookup、BufferLookup字段——这些“来自实体的数据”字段允许您的 Execute函数查找任何实体的数据，无论它存储在何处。（这种类型的随机访问是访问数据效率最低的方式，只应在必要时使用。）请参阅查找其他实体的数据。</p></li><li><p>其他字段——您可以根据需要为您的结构声明其他字段。您可以在每次安排作业时设置此类字段的值。请参阅访问其他数据。</p></li><li><p>输出字段——除了更新作业中的可写实体组件或缓冲区外，您还可以写入为作业结构声明的本机容器字段。此类字段必须是原生容器，例如NativeArray；您不能使用其他数据类型。</p></li></ul><h6 id="访问实体组件和缓冲区数据">访问实体组件和缓冲区数据</h6><p>访问存储在查询中实体之一的组件中的数据是三个步骤的过程：</p><p>首先，您必须在作业结构上定义一个 ComponentTypeHandle 字段，将 T设置为组件的数据类型。例如：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public ComponentTypeHandle&lt;ObjectPosition&gt; translationTypeHandle;</code></pre></div></figure><br />接下来，您在作业的 Execute方法中使用此句柄字段来访问包含该类型组件数据的数组（作为NativeArray）。该数组包含批次中每个实体的一个元素：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">NativeArray&lt;ObjectPosition&gt; translations &#x3D; batchInChunk.GetNativeArray(translationTypeHandle);</code></pre></div></figure><br />最后，当您安排作业时（在系统的 OnUpdate 方法中，您使用ComponentSystemBase.GetComponentTypeHandle函数为类型句柄字段分配一个值：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">&#x2F;&#x2F; &quot;this&quot; is your SystemBase subclassupdateFromVelocityJob.translationTypeHandle &#x3D; this.GetComponentTypeHandle&lt;ObjectPosition&gt;(false);</code></pre></div></figure><br />每次安排作业时，始终设置作业的组件句柄字段。不要缓存类型句柄并在以后使用它。</p><p>批次中的每个组件数据数组都是对齐的，以便给定索引对应于所有数组中的相同实体。换句话说，如果您的作业使用一个实体的两个组件，请在两个数据数组中使用相同的数组索引来访问同一实体的数据。</p><p>您可以使用 ComponentTypeHandle 变量来访问您未包含在 EntityQuery中的组件类型。但是，您必须检查以确保当前批次包含该组件，然后再尝试访问它。使用Has 函数检查当前批次是否包含特定组件类型：</p><p>ComponentTypeHandle 字段是 ECS作业安全系统的一部分，可防止在读取和写入作业中的数据时出现竞争条件。始终设置GetComponentTypeHandle 函数的 isReadOnly参数以准确反映组件在作业中的访问方式。</p><h6 id="查找其他实体的数据">查找其他实体的数据</h6><p>通过 EntityQuery 和 IJobEntityBatch 作业（或Entities.ForEach）访问组件数据几乎总是访问数据的最有效方式。但是，通常情况下您需要以随机访问方式查找数据，例如，当一个实体依赖于另一个实体中的数据时。要执行这种类型的数据查找，您必须通过作业结构将不同类型的句柄传递给您的作业：</p><p>ComponentLookup – 访问具有该组件类型的任何实体的组件</p><p>BufferLookup – 访问具有该缓冲区类型的任何实体的缓冲区</p><p>这些类型为组件和缓冲区提供类似数组的接口，由 Entity对象索引。除了由于随机数据访问而相对低效之外，以这种方式查找数据还会增加您遇到工作安全系统建立的保障措施的机会。例如，如果您尝试根据另一个实体的变换设置一个实体的变换，作业安全系统无法判断这是否安全，因为您可以通过ComponentLookup对象访问所有变换。您可能正在写入您正在读取的相同数据，从而造成竞争条件。</p><p>要使用 ComponentLookup 和 BufferLookup，请在作业结构上声明一个类型为ComponentLookup 或 BufferLookup的字段，并在调度作业之前设置该字段的值。</p><p>有关详细信息，请参阅查找数据。</p><h6 id="访问其他数据">访问其他数据</h6><p>如果在执行作业时需要其他信息，可以在作业结构上定义一个字段，然后在Execute方法中访问该字段。您只能在安排作业时设置该值，并且该值对于所有批次都保持不变。</p><p>例如，如果您正在更新移动对象，您很可能需要传入自上次更新以来经过的时间。为此，您可以定义一个名为DeltaTime 的字段，在 OnUpdate中设置它的值并在作业执行函数中使用该值。在为新帧安排作业之前，您将在每一帧计算并为DeltaTime 字段分配一个新值。</p><h5 id="编写执行函数">编写执行函数</h5><p>编写作业结构的执行函数，将数据从输入状态转换为所需的输出状态。</p><p>IJobEntityBatch.Execute 方法的签名是：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">void Execute(ArchetypeChunk batchInChunk, int batchIndex)</code></pre></div></figure><br />对于 IJobEntityBatchWithIndex.Execute，签名是：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">void Execute(ArchetypeChunk batchInChunk, int batchIndex, int indexOfFirstEntityInQuery)</code></pre></div></figure></p><h6 id="batchinchunk-参数">batchInChunk 参数</h6><p>batchInChunk 参数提供包含此作业迭代的实体和组件的 ArchetypeChunk实例。因为一个块只能包含一个原型，所以一个块中的所有实体都具有相同的组件集。默认情况下，此对象将所有实体包含在一个块中；但是，如果您使用ScheduleParallel安排作业，则可以指定一个批次仅包含块中实体数的一小部分。</p><p>使用 batchInChunk 参数获取访问组件数据所需的 NativeArray 实例。（您还必须声明一个具有相应组件类型句柄的字段——并在安排作业时设置该字段。）</p><h6 id="batchindex-参数">batchIndex 参数</h6><p>batchIndex参数是当前批次在为当前作业创建的所有批次列表中的索引。作业中的批次不一定按索引顺序处理。</p><p>您可以在以下情况下使用 batchIndex值：您有一个本机容器，每个批次有一个元素，您希望将在执行函数中计算的值写入其中。使用batchIndex 作为此容器的数组索引。</p><p>如果您使用并行写入实体命令缓冲区，请将 batchIndex 参数作为 sortKey参数传递给命令缓冲区函数。</p><h6 id="indexoffirstentityinquery-参数">indexOfFirstEntityInQuery参数</h6><p>IJobEntityBatchWithIndex Execute 函数有一个名为indexofFirstEntityInQuery的附加参数。如果您将查询选择的实体描绘成一个列表，则indexOfFirstEntityInQuery将是当前批次中第一个实体的该列表的索引。作业中的批次不一定按索引顺序处理。</p><h6 id="可选组件">可选组件</h6><p>如果您的实体查询中有 Any过滤器或完全可选的组件根本没有出现在查询中，您可以使用ArchetypeChunk.Has 函数在使用之前测试当前块是否包含这些组件之一：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">&#x2F;&#x2F; If entity has Rotation and LocalToWorld components,&#x2F;&#x2F; slerp to align to the velocity vectorif (batchInChunk.Has&lt;Rotation&gt;(rotationTypeHandle) &amp;&amp;    batchInChunk.Has&lt;LocalToWorld&gt;(l2wTypeHandle))&#123;    NativeArray&lt;Rotation&gt; rotations        &#x3D; batchInChunk.GetNativeArray(rotationTypeHandle);    NativeArray&lt;LocalToWorld&gt; transforms        &#x3D; batchInChunk.GetNativeArray(l2wTypeHandle);    &#x2F;&#x2F; By putting the loop inside the check for the    &#x2F;&#x2F; optional components, we can check once per batch    &#x2F;&#x2F; rather than once per entity.    for (int i &#x3D; 0; i &lt; batchInChunk.Count; i++)    &#123;        float3 direction &#x3D; math.normalize(velocityVectors[i].Value);        float3 up &#x3D; transforms[i].Up;        quaternion rotation &#x3D; rotations[i].Value;        quaternion look &#x3D; quaternion.LookRotation(direction, up);        quaternion newRotation &#x3D; math.slerp(rotation, look, DeltaTime);        rotations[i] &#x3D; new Rotation() &#123; Value &#x3D; newRotation &#125;;    &#125;&#125;</code></pre></div></figure></p><h4 id="安排工作">安排工作</h4><p>要运行 IJobEntityBatch作业，您必须创建作业结构的实例，设置结构字段，然后安排作业。当您在SystemBase 实现的 OnUpdate函数中执行此操作时，系统会安排作业在每一帧运行。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">[RequireMatchingQueriesForUpdate]public partial class UpdateTranslationFromVelocitySystem : SystemBase&#123;    EntityQuery query;    protected override void OnCreate()    &#123;        &#x2F;&#x2F; Set up the query        var description &#x3D; new EntityQueryDesc()        &#123;            All &#x3D; new ComponentType[]                   &#123;ComponentType.ReadWrite&lt;ObjectPosition&gt;(),                    ComponentType.ReadOnly&lt;VelocityVector&gt;()&#125;        &#125;;        query &#x3D; this.GetEntityQuery(description);    &#125;    protected override void OnUpdate()    &#123;        &#x2F;&#x2F; Instantiate the job struct        var updateFromVelocityJob            &#x3D; new UpdateTranslationFromVelocityJob();        &#x2F;&#x2F; Set the job component type handles        &#x2F;&#x2F; &quot;this&quot; is your SystemBase subclass        updateFromVelocityJob.translationTypeHandle            &#x3D; this.GetComponentTypeHandle&lt;ObjectPosition&gt;(false);        updateFromVelocityJob.velocityTypeHandle            &#x3D; this.GetComponentTypeHandle&lt;VelocityVector&gt;(true);        &#x2F;&#x2F; Set other data need in job, such as time        updateFromVelocityJob.DeltaTime &#x3D; World.Time.DeltaTime;        &#x2F;&#x2F; Schedule the job        this.Dependency            &#x3D; updateFromVelocityJob.ScheduleParallel(query, this.Dependency);    &#125;&#125;</code></pre></div></figure><br />当您调用 GetComponentTypeHandle函数来设置组件类型变量时，请确保将作业读取但不写入的组件的 isReadOnly参数设置为 true。正确设置这些参数会对 ECS框架安排作业的效率产生重大影响。这些访问模式设置必须与其在结构定义和EntityQuery 中的等效设置相匹配。</p><p>不要在系统类变量中缓存 GetComponentTypeHandle的返回值。您必须在每次系统运行时调用该函数，并将更新后的值传递给作业。</p><h5 id="调度选项">调度选项</h5><p>您可以在安排作业时通过选择适当的功能来控制作业的执行方式：</p><ul><li><p>运行——立即在当前（主）线程上执行作业。 Run还会完成当前作业所依赖的任何计划作业。批量大小始终为1（整个块）。</p></li><li><p>Schedule——安排作业在当前作业所依赖的任何计划作业之后在工作线程上运行。为实体查询选择的每个块调用一次作业执行函数。块按顺序处理。批量大小始终为1。</p></li><li><p>ScheduleParallel——与 Schedule类似，不同之处在于您可以指定批处理大小，并且这些批处理是并行处理的（假设工作线程可用）而不是顺序处理。</p></li></ul><h5 id="设置批量大小">设置批量大小</h5><p>要设置批量大小，请使用 ScheduleParallel 方法来安排作业并将batchesPerChunk 参数设置为正整数。使用值 1将批处理大小设置为完整块。</p><p>用于调度作业的查询选择的每个块都分为 batchesPerChunk指定的批次数。来自同一块的每个批次包含大致相同数量的实体；然而，来自不同块的批次可能包含非常不同数量的实体。最大批处理大小为1，这意味着每个块中的所有实体都在对 Execute函数的一次调用中一起处理。来自不同块的实体永远不能包含在同一批中。</p><div class="note note-info">            <p>通常，使用 batchesPerChunk 设置为 1 来在对 Execute的单个调用中处理块中的所有实体是最有效的。然而，情况并非总是如此。例如，如果您的Execute函数执行的实体数量较少且算法成本较高，则可以通过使用较小的实体批次从并行处理中获得额外的好处。</p>          </div><h4 id="跳过实体不变的块">跳过实体不变的块</h4><p>如果您只需要在组件值更改时更新实体，则可以将该组件类型添加到为作业选择实体和块的EntityQuery的更改过滤器中。例如，如果您有一个系统读取两个组件并且只需要在前两个组件中的一个发生更改时更新第三个组件，则可以按如下方式使用EntityQuery：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">EntityQuery query;protected override void OnCreate()&#123;    query &#x3D; GetEntityQuery(        new ComponentType[]        &#123;            ComponentType.ReadOnly&lt;InputA&gt;(),            ComponentType.ReadOnly&lt;InputB&gt;(),            ComponentType.ReadWrite&lt;Output&gt;()        &#125;    );    query.SetChangedVersionFilter(            new ComponentType[]            &#123;                typeof(InputA),                typeof(InputB)            &#125;        );&#125;</code></pre></div></figure><br />EntityQuery 更改过滤器最多支持两个组件。如果您想检查更多或者您没有使用EntityQuery，您可以手动进行检查。要进行此检查，请使用ArchetypeChunk.DidChange 函数将组件的块更改版本与系统的LastSystemVersion 进行比较。如果此函数返回false，则您可以完全跳过当前块，因为自上次系统运行以来该类型的组件均未更改。</p><p>您必须使用结构字段将 LastSystemVersion从系统传递到作业中，如下所示：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">struct UpdateOnChangeJob : IJobEntityBatch&#123;    public ComponentTypeHandle&lt;InputA&gt; InputATypeHandle;    public ComponentTypeHandle&lt;InputB&gt; InputBTypeHandle;    [ReadOnly] public ComponentTypeHandle&lt;Output&gt; OutputTypeHandle;    public uint LastSystemVersion;    [BurstCompile]    public void Execute(ArchetypeChunk batchInChunk, int batchIndex)    &#123;        var inputAChanged &#x3D; batchInChunk.DidChange(InputATypeHandle, LastSystemVersion);        var inputBChanged &#x3D; batchInChunk.DidChange(InputBTypeHandle, LastSystemVersion);        &#x2F;&#x2F; If neither component changed, skip the current batch        if (!(inputAChanged || inputBChanged))            return;        var inputAs &#x3D; batchInChunk.GetNativeArray(InputATypeHandle);        var inputBs &#x3D; batchInChunk.GetNativeArray(InputBTypeHandle);        var outputs &#x3D; batchInChunk.GetNativeArray(OutputTypeHandle);        for (var i &#x3D; 0; i &lt; outputs.Length; i++)        &#123;            outputs[i] &#x3D; new Output &#123; Value &#x3D; inputAs[i].Value + inputBs[i].Value &#125;;        &#125;    &#125;&#125;</code></pre></div></figure><br />与所有作业结构字段一样，您必须在安排作业之前分配其值：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">[RequireMatchingQueriesForUpdate]public partial class UpdateDataOnChangeSystem : SystemBase &#123;    EntityQuery query;    protected override void OnUpdate()    &#123;        var job &#x3D; new UpdateOnChangeJob();        job.LastSystemVersion &#x3D; this.LastSystemVersion;        job.InputATypeHandle &#x3D; GetComponentTypeHandle&lt;InputA&gt;(true);        job.InputBTypeHandle &#x3D; GetComponentTypeHandle&lt;InputB&gt;(true);        job.OutputTypeHandle &#x3D; GetComponentTypeHandle&lt;Output&gt;(false);        this.Dependency &#x3D; job.ScheduleParallel(query, this.Dependency);    &#125;    protected override void OnCreate()    &#123;        query &#x3D; GetEntityQuery(            new ComponentType[]            &#123;                ComponentType.ReadOnly&lt;InputA&gt;(),                ComponentType.ReadOnly&lt;InputB&gt;(),                ComponentType.ReadWrite&lt;Output&gt;()            &#125;        );    &#125;&#125;</code></pre></div></figure><div class="note note-info">            <p>为了提高效率，更改版本适用于整个块而不是单个实体。如果另一个能够写入该类型组件的作业访问块，则ECS 会增加该组件的更改版本，并且 DidChange 函数返回true。即使声明对组件的写访问权限的作业实际上并未更改组件值，ECS也会增加更改版本。（这是在读取组件数据而不更新它时应始终只读的原因之一。）</p>          </div><h3 id="手动迭代数据">手动迭代数据</h3><p>如果您需要以一种不适合迭代 EntityQuery中所有块的简化模型的方式管理块，您可以在本机数组中显式手动请求所有原型块，并使用IJobParallelFor 等作业处理它们.下面是一个例子：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class RotationSpeedSystem : SystemBase&#123;   [BurstCompile]   struct RotationSpeedJob : IJobParallelFor   &#123;       [DeallocateOnJobCompletion] public NativeArray&lt;ArchetypeChunk&gt; Chunks;       public ArchetypeChunkComponentType&lt;RotationQuaternion&gt; RotationType;       [ReadOnly] public ArchetypeChunkComponentType&lt;RotationSpeed&gt; RotationSpeedType;       public float DeltaTime;       public void Execute(int chunkIndex)       &#123;           var chunk &#x3D; Chunks[chunkIndex];           var chunkRotation &#x3D; chunk.GetNativeArray(RotationType);           var chunkSpeed &#x3D; chunk.GetNativeArray(RotationSpeedType);           var instanceCount &#x3D; chunk.Count;           for (int i &#x3D; 0; i &lt; instanceCount; i++)           &#123;               var rotation &#x3D; chunkRotation[i];               var speed &#x3D; chunkSpeed[i];               rotation.Value &#x3D; math.mul(math.normalize(rotation.Value), quaternion.AxisAngle(math.up(), speed.RadiansPerSecond * DeltaTime));               chunkRotation[i] &#x3D; rotation;           &#125;       &#125;   &#125;   EntityQuery m_Query;      protected override void OnCreate()   &#123;       var queryDesc &#x3D; new EntityQueryDesc       &#123;           All &#x3D; new ComponentType[]&#123; typeof(RotationQuaternion), ComponentType.ReadOnly&lt;RotationSpeed&gt;() &#125;       &#125;;       m_Query &#x3D; GetEntityQuery(queryDesc);   &#125;   protected override void OnUpdate()   &#123;       var rotationType &#x3D; GetArchetypeChunkComponentType&lt;RotationQuaternion&gt;();       var rotationSpeedType &#x3D; GetArchetypeChunkComponentType&lt;RotationSpeed&gt;(true);       var chunks &#x3D; m_Query.ToArchetypeChunkArray(Allocator.TempJob);       var rotationsSpeedJob &#x3D; new RotationSpeedJob       &#123;           Chunks &#x3D; chunks,           RotationType &#x3D; rotationType,           RotationSpeedType &#x3D; rotationSpeedType,           DeltaTime &#x3D; Time.deltaTime       &#125;;       this.Dependency rotationsSpeedJob.Schedule(chunks.Length,32, this.Dependency);   &#125;&#125;</code></pre></div></figure></p><h4 id="如何手动迭代数据">如何手动迭代数据</h4><p>您可以使用 EntityManager类手动遍历实体或原型块，但这效率不高。您应该只使用这些迭代方法来测试或调试您的代码，或者在您拥有一组受控实体的孤立世界中。</p><p>例如，以下代码片段遍历活动世界中的所有实体：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">var entityManager &#x3D; World.Active.EntityManager;var allEntities &#x3D; entityManager.GetAllEntities();foreach (var entity in allEntities)&#123;   &#x2F;&#x2F;...&#125;allEntities.Dispose();</code></pre></div></figure><br />此代码段遍历活动世界中的所有块：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">var entityManager &#x3D; World.Active.EntityManager;var allChunks &#x3D; entityManager.GetAllChunks();foreach (var chunk in allChunks)&#123;   &#x2F;&#x2F;...&#125;allChunks.Dispose();</code></pre></div></figure></p><h2 id="系统更新顺序">系统更新顺序</h2><p>要指定系统的更新顺序，您可以使用 ComponentSystemGroup类。要将系统置于组中，请在系统的类声明中使用 UpdateInGroup属性。然后，您可以使用 UpdateBefore 或 UpdateAfter属性来指定系统必须更新的顺序。</p><p>有一组默认系统组，您可以使用它们在框架的正确阶段更新系统。您可以将一个组嵌套在另一个组中，以便您组中的所有系统都在正确的阶段更新，并根据其组内的顺序进行更新。</p><h3 id="组件系统组">组件系统组</h3><p>ComponentSystemGroup 类表示 Unity必须按特定顺序一起更新的相关组件系统的列表。 ComponentSystemGroup 继承自ComponentSystemBase，因此您可以相对于其他系统对其进行排序，并且它具有OnUpdate() 方法。这也意味着您可以将一个 ComponentSystemGroup嵌套在另一个 ComponentSystemGroup 中，并形成层次结构。</p><p>默认情况下，当您在 ComponentSystemGroup 中调用 Update()方法时，它会在其已排序的成员系统列表中的每个系统上调用Update()。如果任何成员系统是系统组，它们将递归更新自己的成员。生成的系统排序遵循树的深度优先遍历。</p><h3 id="系统排序属性">系统排序属性</h3><p>您可以在系统上使用以下属性来确定其更新顺序：</p><table><thead><tr class="header"><th>属性</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>UpdateInGroup</td><td>指定此系统应属于的 ComponentSystemGroup。如果不设置该属性，Unity会自动将其添加到默认世界的 SimulationSystemGroup中。有关详细信息，请参阅默认系统组部分。</td></tr><tr class="even"><td>UpdateBefore UpdateAfter</td><td>Order系统相对于其他系统。为这些属性指定的系统类型必须是同一组的成员。 Unity在包含两个系统的适当的最深组中处理跨组边界的排序。例如，如果 CarSystem在 CarGroup 中，而 TruckSystem 在 TruckGroup 中，并且 CarGroup 和TruckGroup 都是 VehicleGroup 的成员，那么 CarGroup 和 TruckGroup的顺序隐式决定了 CarSystem 和 TruckSystem的相对顺序。您无需明确订购系统。</td></tr><tr class="odd"><td>DisableAutoCreation</td><td>阻止 Unity在默认世界初始化期间创建系统。您必须明确地创建和更新系统。但是，您可以将带有此标记的系统添加到ComponentSystemGroup的更新列表中，它会像该列表中的其他系统一样自动更新。</td></tr></tbody></table><p>如果您将 DisableAutoCreation 属性添加到组件系统或系统组，Unity不会创建它或将其添加到默认系统组。要手动创建系统，请使用World.GetOrCreateSystem<MySystem>() 并从主线程调用 MySystem.Update()来更新它。您可以使用它在 Unity播放器循环中的其他位置插入系统，例如，如果您有一个应该在帧中稍后或更早运行的系统。</p><h3 id="默认系统组">默认系统组</h3><p>默认世界包含 ComponentSystemGroup 实例的层次结构。 Unity播放器循环中有三个根级系统组：</p><ul><li>InitializationSystemGroup：在播放器循环的初始化阶段结束时更新。</li><li>SimulationSystemGroup：在播放器循环的更新阶段结束时更新。</li><li>PresentationSystemGroup：在播放器循环的 PreLateUpdate阶段结束时更新。<br />默认系统组也有一些预定义的成员系统：</li></ul><p><strong>InitializationSystemGroup</strong>:</p><ul><li>BeginInitializationEntityCommandBufferSystem</li><li>CopyInitialTransformFromGameObjectSystem</li><li>SubSceneLiveConversionSystem</li><li>SubSceneStreamingSystem</li><li>EndInitializationEntityCommandBufferSystem</li></ul><p><strong>SimulationSystemGroup</strong>:</p><ul><li>BeginSimulationEntityCommandBufferSystem</li><li>TransformSystemGroup<ul><li>ParentSystem</li><li>CopyTransformFromGameObjectSystem</li><li>TRSToLocalToWorldSystem</li><li>TRSToLocalToParentSystem</li><li>LocalToParentSystem</li><li>CopyTransformToGameObjectSystem</li></ul></li><li>LateSimulationSystemGroup</li><li>EndSimulationEntityCommandBufferSystem</li></ul><p><strong>PresentationSystemGroup</strong>:</p><ul><li>BeginPresentationEntityCommandBufferSystem</li><li>CreateMissingRenderBoundsFromMeshRenderer</li><li>RenderingSystemBootstrap</li><li>RenderBoundsUpdateSystem</li><li>RenderMeshSystem</li><li>LODGroupSystemV1</li><li>LodRequirementsUpdateSystem</li><li>EndPresentationEntityCommandBufferSystem<br />请注意，此列表的具体内容可能会发生变化。</li></ul><h3 id="多个世界">多个世界</h3><p>您可以创建多个世界，也可以在多个世界中实例化相同的组件系统类。您还可以从更新顺序中的不同点以不同的速率更新每个实例。</p><p>您无法手动更新给定世界中的每个系统，但您可以控制在哪个世界中创建哪些系统，以及将它们添加到哪些现有系统组中。</p><p>例如，您可以创建一个实例化 SystemX 和 SystemY 的自定义世界，并将SystemX 添加到默认世界的 SimulationSystemGroup，并将 SystemY添加到默认世界的PresentationSystemGroup。这些系统可以像往常一样相对于它们的同级组对自己进行排序，Unity会更新它们以及相应的组。</p><p>您还可以使用 ICustomBootstrap 接口来管理多个世界中的系统：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public interface ICustomBootstrap&#123;    &#x2F;&#x2F; 返回应由默认引导程序处理的系统。    &#x2F;&#x2F; 如果返回 null，则根本不会创建默认世界。    &#x2F;&#x2F; 空列表创建默认世界和入口点    List&lt;Type&gt; Initialize(List&lt;Type&gt; systems);&#125;</code></pre></div></figure><br />当您实现此接口时，它会在默认世界初始化之前将组件系统类型的完整列表传递给Initialize()方法。自定义引导程序可以遍历此列表并在您定义的世界中创建系统。您可以从Initialize() 方法返回系统列表，Unity创建它们作为默认世界初始化的一部分。</p><p>例如，这是自定义 MyCustomBootstrap.Initialize() 实现的典型过程：</p><ol type="1"><li>创建任何其他世界及其顶级 ComponentSystemGroups。</li><li>对于系统类型列表中的每个类型：<ol type="1"><li>向上搜索 ComponentSystemGroup层次结构以找到此系统类型的顶级组。</li><li>如果它是在步骤 1 中创建的组之一，则在该世界中创建系统并使用group.AddSystemToUpdateList() 将其添加到层次结构中。</li><li>如果不是，则将此类型附加到列表以返回到DefaultWorldInitialization。</li></ol></li><li>在新的顶级组上调用 group.SortSystemUpdateList()。<ol type="1"><li>可选择将它们添加到默认世界组之一</li></ol></li><li>将未处理系统的列表返回给 DefaultWorldInitialization。</li></ol><div class="note note-info">            <p>ECS 框架通过反射找到您的 ICustomBootstrap 实现。</p>          </div><h2 id="使用作业在多个线程上调度数据">使用作业在多个线程上调度数据</h2><p>实体包和 Unity 的 DOTS 架构广泛使用 C#作业系统。只要有可能，您应该在系统代码中使用作业。</p><p>SystemBase 类提供 Entities.ForEach 和 Job.WithCode以将应用程序的逻辑实现为多线程代码。在更复杂的情况下，您可以使用IJobEntityBatch 的 Schedule() 和 ScheduleParallel()方法在主线程之外转换数据。 Entities.ForEach使用起来最简单，通常需要较少的代码来实现。</p><p>ECS 按照您的系统所在的顺序在主线程上安排作业。当您安排作业时，ECS会跟踪哪些作业读取和写入哪些组件。读取组件的作业依赖于写入同一组件的任何先前计划的作业，反之亦然。作业调度程序使用作业依赖关系来确定哪些作业可以并行运行，哪些作业必须按顺序运行。</p><p>例如，以下系统更新位置：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using Unity.Burst;using Unity.Collections;using Unity.Entities;using Unity.Jobs;using Unity.Transforms;public class MovementSpeedSystem : SystemBase&#123;    &#x2F;&#x2F; OnUpdate runs on the main thread.    protected override void OnUpdate()    &#123;        Entities            .ForEach((ref Translation position, in MovementSpeed speed) &#x3D;&gt;                &#123;                    float3 displacement &#x3D; speed.Value * dt;                    position &#x3D; new Translation()&#123;                            Value &#x3D; position.Value + displacement                        &#125;;                &#125;)            .ScheduleParallel();    &#125;&#125;</code></pre></div></figure></p><h3 id="工作扩展">工作扩展</h3><p>Unity C#作业系统允许您在多个线程上运行代码。该系统提供调度、并行处理和多线程安全。作业系统是一个核心Unity 模块，它提供通用接口和类来创建和运行作业，无论您是否使用 Entities包。</p><p>这些接口包括：</p><ul><li>IJob：创建一个在任何线程或内核上运行的作业，由作业系统调度程序确定。</li><li>IJobParallelFor：创建一个可以在多个线程上并行运行的作业，以处理NativeContainer 的元素。</li><li>IJobExtensions：提供运行 IJob 作业的扩展方法。</li><li>IJobParallelForExtensions：提供运行 IJobParallelFor作业的扩展方法。</li><li>JobHandle：访问计划作业的句柄。您还可以使用 JobHandle实例来指定作业之间的依赖关系。<br />有关作业系统的概述，请参阅 Unity 用户手册中的 C# 作业系统。</li></ul><p>Jobs 包扩展了作业系统以支持 ECS。它包含：</p><ul><li>IJobParallelForDeferExtensions</li><li>IJobFilter</li><li>JobParallelIndexListExtensions</li><li>Job​Struct​Produce<T></li></ul><h3 id="通用职位">通用职位</h3><p>在 C#中，您可以使用继承和接口使一段代码适用于一系列类型。例如：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">&#x2F;&#x2F; The method is not limited to just one kind of &#x2F;&#x2F; input but rather any type which implements IBlendable.void foo(IBlendable a) &#123;...&#125;</code></pre></div></figure><br />在 Burst 编译器使用的高性能 C# (HPC#)中，您不能使用托管类型或虚拟方法调用，因此泛型是使一段代码在一系列类型上运行的选项：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">&#x2F;&#x2F; This method can operate on any IBlendable struct (and can call the &#x2F;&#x2F; IBlendable methods) but requires no managed objects or virtual method calls.void foo&lt;T&gt;(T a) where T : struct, IBlendable &#123;...&#125;</code></pre></div></figure><br />您必须在 HPC#中编写作业，因此对于在一系列类型上运行的作业，它必须是通用的：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">[BurstCompile()]public struct BlendJob&lt;T&gt; : IJob    where T : struct, IBlendable&#123;    public NativeReference&lt;T&gt; blendable;    public void Execute()     &#123;        var val &#x3D; blendable.Value;        val.Blend();        blendable.Value &#x3D; val;    &#125;&#125;</code></pre></div></figure></p><h4 id="从-burst-编译代码中调度通用作业">从 Burst编译代码中调度通用作业</h4><p>要从 Burst编译代码安排通用作业，您需要作业具体专业化的反射数据。不幸的是，Unity不会为所有具体的特化自动生成此反射，因此在某些情况下您必须手动注册它们：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">&#x2F;&#x2F; This assembly attribute allows Burst-compiled &#x2F;&#x2F; code in the same assembly to schedule the&#x2F;&#x2F; concrete specialization &lt;int, float&gt; for MyJob. *&#x2F;[assembly: RegisterGenericJobType(typeof(MyJob&lt;int, float&gt;))]</code></pre></div></figure><br />如果您尝试安排未在程序集中注册具体专业化的作业，则 Unity会抛出异常。</p><p>注册类型的程序集无关紧要。例如，如果一个作业类型只在程序集 Foo中注册，您也可以在程序集 Bar 中安排它。</p><p>如果您多次重复注册相同的具体专业化，则不会将其视为错误。</p><h4 id="具体作业类型的自动注册">具体作业类型的自动注册</h4><p>当您直接实例化通用作业的具体特化时，Unity会自动在程序集中注册该特化：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">&#x2F;&#x2F; Registers specialization &lt;int, float&gt; for MyJob in the assembly.var job &#x3D; new MyJob&lt;int, float&gt;();</code></pre></div></figure><p>但是，在间接实例化具体特化时，Unity 不会自动注册它：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">void makeJob&lt;T&gt;()&#123;    new MyJob&lt;T, float&gt;().Schedule();   &#125;void foo()&#123;    makeJob&lt;int&gt;();    &#x2F;&#x2F; does NOT register MyJob&lt;int, float&gt;&#125;</code></pre></div></figure><br />但是，如果您将通用作业作为返回类型或输出参数包含在签名中，则 Unity会自动注册它：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">MyJob&lt;T, float&gt; makeJob&lt;T&gt;()&#123;    var j &#x3D; new MyJob&lt;T, float&gt;()    j.Schedule();       return j;&#125;void foo()&#123;    makeJob&lt;int&gt;();    &#x2F;&#x2F; registers MyJob&lt;int, float&gt;&#125;</code></pre></div></figure><br />您可以通过多级通用方法调用使用此间接注册作品：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">MyJob&lt;T, float&gt; makeJob&lt;T&gt;()&#123;    var j &#x3D; new MyJob&lt;T, float&gt;()    j.Schedule();       return j;&#125;void foo&lt;T&gt;()&#123;    makeJob&lt;T&gt;();    &#125;void bar()&#123;    foo&lt;int&gt;();       &#x2F;&#x2F; registers MyJob&lt;int, float&gt;&#125;</code></pre></div></figure><br />您还可以将通用作业嵌套在另一个类或结构中：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">struct BlendJobWrapper&lt;T&gt; where T : struct, IBlendable&#123;    public T blendable;    [BurstCompile()]    public struct BlendJob : IJob    &#123;        public T blendable;        public void Execute() &#123;...&#125;    &#125;    public JobHandle Schedule(JobHandle dep &#x3D; new JobHandle())    &#123;        return new BlendJob &#123; blendable &#x3D; blendable &#125;.Schedule(dep);    &#125;&#125;</code></pre></div></figure><br />在前面的示例中，如果 BlendJobWrapper<foo> 是自动或手动注册的，那么BlendJob<foo>也会有效注册。仅围绕一个通用作业的包装器类型并不能解决任何问题，但是当您同时使用多个通用作业时，这些包装器类型允许更优雅的作业创建和调度。</p><h4 id="作业化分拣">作业化分拣</h4><p>NativeSortExtension类具有排序方法，包括使用作业进行排序的方法：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public unsafe static JobHandle Sort&lt;T, U&gt;(T* array, int length, U comp, JobHandle deps)    where T : unmanaged    where U : IComparer&lt;T&gt;&#123;    if (length &#x3D;&#x3D; 0)        return inputDeps;    var segmentSortJob &#x3D; new SegmentSort&lt;T, U&gt; &#123; Data &#x3D; array, Comp &#x3D; comp, Length &#x3D; length, SegmentWidth &#x3D; 1024 &#125;;    var segmentSortMergeJob &#x3D; new SegmentSortMerge&lt;T, U&gt; &#123; Data &#x3D; array, Comp &#x3D; comp, Length &#x3D; length, SegmentWidth &#x3D; 1024 &#125;;    var segmentCount &#x3D; (length + 1023) &#x2F; 1024;    var workerSegmentCount &#x3D; segmentCount &#x2F; math.max(1, JobsUtility.MaxJobThreadCount);    var handle &#x3D; segmentSortJob.Schedule(segmentCount, workerSegmentCount, deps);    return segmentSortMergeJob.Schedule(segmentSortJobHandle);&#125;</code></pre></div></figure><br />在此示例中，排序分为两个作业：第一个作业将数组拆分为多个子部分，然后分别对它们进行并行排序。第二个作业等待第一个，然后将这些排序的子部分合并为最终的排序结果。</p><p>但是，此方法不会自动注册两个通用作业 SegmentSort 和 SegmentSortMerge的具体特化，因为这两种类型都未用作方法的返回类型或输出参数。</p><p>一种解决方案是将两个作业都放入参数中：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public unsafe static JobHandle Sort&lt;T, U&gt;(T* array, int length, U comp, JobHandle deps        out SegmentSort&lt;T, U&gt; segmentSortJob, out SegmentSortMerge&lt;T, U&gt; segmentSortMergeJob)    where T : unmanaged    where U : IComparer&lt;T&gt;&#123;    if (length &#x3D;&#x3D; 0)        return inputDeps;    segmentSortJob &#x3D; new SegmentSort&lt;T, U&gt; &#123; Data &#x3D; array, Comp &#x3D; comp, Length &#x3D; length, SegmentWidth &#x3D; 1024 &#125;;    segmentSortMergeJob &#x3D; new SegmentSortMerge&lt;T, U&gt; &#123; Data &#x3D; array, Comp &#x3D; comp, Length &#x3D; length, SegmentWidth &#x3D; 1024 &#125;;    var segmentCount &#x3D; (length + 1023) &#x2F; 1024;    var workerSegmentCount &#x3D; segmentCount &#x2F; math.max(1, JobsUtility.MaxJobThreadCount);    var handle &#x3D; segmentSortJob.Schedule(segmentCount, workerSegmentCount, deps);    return segmentSortMergeJob.Schedule(segmentSortJobHandle);&#125;</code></pre></div></figure><br />然而，这解决了注册问题，但是您随后必须传递参数以获得您可能不想要的两个作业结构。</p><p>更好的解决方案是将两种作业类型包装在一个包装器类型中：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">unsafe struct SortJob&lt;T, U&gt; :    where T : unamanged    where U : IComparer&lt;T&gt;&#123;    public T* data;    public U comparer;    public int length;    unsafe struct SegmentSort : IJobParallelFor    &#123;        [NativeDisableUnsafePtrRestriction]        public T* data;        public U comp;        public int length;        public int segmentWidth;        public void Execute(int index) &#123;...&#125;    &#125;    unsafe struct SegmentSortMerge : IJob    &#123;        [NativeDisableUnsafePtrRestriction]        public T* data;        public U comp;        public int length;        public int segmentWidth;        public void Execute() &#123;...&#125;    &#125;    public JobHandle Schedule(JobHandle dep &#x3D; new JobHandle())    &#123;        if (length &#x3D;&#x3D; 0)            return inputDeps;        var segmentSortJob &#x3D; new SegmentSort&lt;T, U&gt; &#123; Data &#x3D; array, Comp &#x3D; comp, Length &#x3D; length, SegmentWidth &#x3D; 1024 &#125;;        var segmentSortMergeJob &#x3D; new SegmentSortMerge&lt;T, U&gt; &#123; Data &#x3D; array, Comp &#x3D; comp, Length &#x3D; length, SegmentWidth &#x3D; 1024 &#125;;        var segmentCount &#x3D; (length + 1023) &#x2F; 1024;        var workerSegmentCount &#x3D; segmentCount &#x2F; math.max(1, JobsUtility.MaxJobThreadCount);        var handle &#x3D; segmentSortJob.Schedule(segmentCount, workerSegmentCount, deps);        return segmentSortMergeJob.Schedule(segmentSortJobHandle);    &#125;&#125;</code></pre></div></figure><br />在这种安排中，您可以创建 SortJob 的实例并调用其 Schedule()方法，而不是调用 Sort() 方法。通过对 SortJob进行具体实例化，您还可以自动注册所需的 SegmentSort 和 SegmentSortMerge具体特化。</p><p>这种嵌套通用作业的模式启用了一个方便的API，可以将相关的通用作业集安排在一起。</p><h3 id="使用-job.withcode-安排后台作业">使用 Job.WithCode安排后台作业</h3><p>SystemBase 类中的 Job.WithCode构造将方法作为单个后台作业运行。您还可以在主线程上运行 Job.WithCode并利用 Burst 编译来加快执行速度。</p><h4 id="使用-job.withcode">使用 Job.WithCode</h4><p>以下示例使用一个 Job.WithCode lambda表达式用随机数填充本机数组，并使用另一个作业将这些数字加在一起：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public partial class RandomSumJob : SystemBase&#123;    private uint seed &#x3D; 1;    protected override void OnUpdate()    &#123;        Random randomGen &#x3D; new Random(seed++);        NativeArray&lt;float&gt; randomNumbers            &#x3D; new NativeArray&lt;float&gt;(500, Allocator.TempJob);        Job.WithCode(() &#x3D;&gt;        &#123;            for (int i &#x3D; 0; i &lt; randomNumbers.Length; i++)            &#123;                randomNumbers[i] &#x3D; randomGen.NextFloat();            &#125;        &#125;).Schedule();        &#x2F;&#x2F; To get data out of a job, you must use a NativeArray        &#x2F;&#x2F; even if there is only one value        NativeArray&lt;float&gt; result            &#x3D; new NativeArray&lt;float&gt;(1, Allocator.TempJob);        Job.WithCode(() &#x3D;&gt;        &#123;            for (int i &#x3D; 0; i &lt; randomNumbers.Length; i++)            &#123;                result[0] +&#x3D; randomNumbers[i];            &#125;        &#125;).Schedule();        &#x2F;&#x2F; This completes the scheduled jobs to get the result immediately, but for        &#x2F;&#x2F; better efficiency you should schedule jobs early in the frame with one        &#x2F;&#x2F; system and get the results late in the frame with a different system.        this.CompleteDependency();        UnityEngine.Debug.Log(&quot;The sum of &quot;            + randomNumbers.Length + &quot; numbers is &quot; + result[0]);        randomNumbers.Dispose();        result.Dispose();    &#125;&#125;</code></pre></div></figure><br />要运行并行作业，请实施 IJobFor。您可以使用 ScheduleParallel() 在系统的OnUpdate() 函数中安排并行作业。</p><h4 id="捕获变量-1">捕获变量</h4><p>您不能将参数传递给 Job.WithCode lambda表达式或返回值。相反，您必须在系统的 OnUpdate() 函数中捕获局部变量。</p><p>如果您使用 Schedule() 来安排您的作业在 Unity的作业系统中运行，则还有其他限制：</p><ul><li>您必须将捕获的变量声明为 NativeArray、本机容器或 blittable类型。</li><li>要返回数据，您必须将返回值写入捕获的本机数组，即使数据是单个值也是如此。但是，如果您使用Run() 来执行作业，则可以写入任何捕获的变量。<br />Job.WithCode有一组方法将只读和安全属性应用于捕获的本机容器的变量。例如，您可以使用WithReadOnly 将对变量的访问限制为只读。您还可以使用WithDisposeOnCompletion 在作业完成后自动释放容器。有关详细信息，请参阅Job.WithCode 文档的捕获变量部分。</li></ul><h4 id="执行-job.withcode-lambda-表达式">执行 Job.WithCode lambda表达式</h4><p>要执行 Job.WithCode lambda 表达式，您可以使用以下命令：</p><ul><li>Schedule()：将方法作为单个非并行作业执行。安排作业在后台线程上运行代码并更好地利用所有可用的CPU 资源。您可以显式地将 JobHandle 传递给Schedule()，或者，如果您不传递任何依赖项，系统会假定当前系统的Dependency属性表示作业的依赖项。或者，如果作业没有依赖项，您可以传入一个新的JobHandle。</li><li>Run()：在主线程上执行方法。您可以 Burst 编译Job.WithCode，因此如果您使用 Run()来执行代码，即使它在主线程上运行也会更快。当你调用 Run() 时，Unity会自动完成 Job.WithCode 构造的所有依赖。</li></ul><h4 id="依赖关系-1">依赖关系</h4><p>默认情况下，系统使用其 Dependency 属性来管理其依赖项。系统按照它们在OnUpdate() 方法中出现的顺序将您创建的每个 Entities.ForEach 和Job.WithCode 作业添加到依赖作业句柄。</p><p>要手动管理作业依赖性，请将 JobHandle 传递给 Schedule方法，然后返回生成的依赖性。有关详细信息，请参阅依赖项 API 文档。</p><p>有关作业依赖性的一般信息，请参阅有关作业依赖性的文档。</p><h3 id="作业依赖">作业依赖</h3><p>Unity根据系统读写的ECS组件分析各个系统的数据依赖关系。如果在帧中较早更新的系统读取较晚系统写入的数据，或写入较晚系统读取的数据，则第二个系统依赖于第一个系统。为了防止竞争条件，作业调度程序确保系统依赖的所有作业在运行该系统的作业之前已经完成。</p><h4 id="作业依赖更新顺序">作业依赖更新顺序</h4><p>系统的 Dependency 属性是一个 JobHandle，表示系统的 ECS 相关依赖项。在OnUpdate() 之前，Dependency属性反映系统对先前作业的传入依赖项。默认情况下，系统会根据您在系统中安排作业时每个作业读取和写入的组件来更新依赖属性。</p><h5 id="覆盖默认顺序">覆盖默认顺序</h5><p>要覆盖此默认行为，请使用 Entities.ForEach 和 Job.WithCode的重载版本，它们将作业依赖项作为参数并将更新的依赖项作为 JobHandle返回。当您使用这些构造的显式版本时，ECS 不会自动将作业句柄与系统的Dependency 属性组合在一起。您必须在需要时手动组合它们。</p><p>Dependency 属性不跟踪作业可能对通过 NativeArray或其他类似容器传递的数据的依赖关系。如果您在一个作业中编写NativeArray，并在另一个作业中读取该数组，则必须手动将第一个作业的JobHandle 添加为第二个作业的依赖项。您可以使用JobHandle.CombineDependencies 来执行此操作。</p><h5 id="entities.foreach-的作业依赖顺序">Entities.ForEach的作业依赖顺序</h5><p>当您调用 Entities.ForEach.Run() 时，作业计划程序会在开始 ForEach迭代之前完成系统依赖的所有计划作业。如果您还使用 WithStructuralChanges()作为构造的一部分，则作业调度程序将完成所有正在运行和已调度的作业。结构更改还会使对组件数据的任何直接引用无效。有关详细信息，请参阅有关结构更改的文档。</p><h4 id="更多资源">更多资源</h4><ul><li>JobHandle 和依赖项</li><li>Unity的工作系统</li></ul><h2 id="使用-entityquery-查询数据-1">使用 EntityQuery 查询数据</h2><p>EntityQuery查找具有一组指定组件类型的原型。然后它将原型的块收集到一个系统可以处理的数组中。</p><p>例如，如果查询匹配组件类型 A 和B，则查询会收集具有这两种组件类型的所有原型的块，而不管这些原型可能具有的任何其他组件类型。因此，具有组件类型A、B 和 C 的原型将匹配查询。</p><p>您可以使用 EntityQuery 执行以下操作：</p><p>运行作业以处理选定的实体和组件<br />获取包含所有选定实体的 NativeArray<br />按组件类型获取所选组件的 NativeArray<br />EntityQuery返回的实体和组件数组是并行的。这意味着相同的索引值始终适用于任何数组中的相同实体。</p><h3 id="创建实体查询">创建实体查询</h3><p>要创建实体查询，您可以将组件类型传递给 EntityQueryBuilder帮助器类型。以下示例定义了一个 EntityQuery，它查找所有同时具有ObjectRotation 和 ObjectRotationSpeed 组件的实体：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">EntityQuery query &#x3D; new EntityQueryBuilder(Allocator.Temp)    .WithAllRW&lt;ObjectRotation&gt;()    .WithAll&lt;ObjectRotationSpeed&gt;()    .Build(this);</code></pre></div></figure><br />查询使用 EntityQueryBuilder.WithAllRW<T> 来显示系统写入ObjectRotation。如果可能，您应该始终指定只读访问权限，因为对数据的读取访问权限的限制较少。这有助于作业调度程序更有效地执行作业。</p><h4 id="指定系统选择的原型">指定系统选择的原型</h4><p>查询将仅匹配包含您指定组件的原型。可以使用三种不同的EntityQueryBuilder 方法指定组件：</p><ul><li>WithAll<T>()：这些组件是必需的。为了匹配查询，原型必须包含查询的所有必需组件。</li><li>WithAny<T>()：这些组件是可选的。为了匹配查询，原型必须至少包含一个查询的可选组件。</li><li>WithNone<T>()：排除这些组件。为了匹配查询，原型不得包含任何查询的排除组件。<br />例如，以下查询包括包含 ObjectRotation 和 ObjectRotationSpeed组件的原型，但不包括包含 Static 组件的任何原型：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">EntityQuery query &#x3D; new EntityQueryBuilder(Allocator.Temp)    .WithAllRW&lt;ObjectRotation&gt;()    .WithAll&lt;ObjectRotationSpeed&gt;()    .WithNone&lt;Static&gt;()    .Build(this);</code></pre></div></figure></li></ul><div class="note note-info">            <p>要处理可选组件，请使用 ArchetypeChunk.Has<T>方法来确定块是否包含可选组件。这是因为同一块中的所有实体都具有相同的组件，因此您只需检查每个块是否存在可选组件一次：而不是每个实体一次。</p>          </div><p>您可以使用 EntityQueryBuilder.WithOptions()来查找专门的原型。例如：</p><ul><li>IncludePrefab：包括包含 Prefab 标签组件的原型。</li><li>IncludeDisabledEntities：包括包含 Disabled 标签组件的原型。</li><li>FilterWriteGroup：仅包含 WriteGroup中明确包含在查询中的组件的实体。排除具有来自同一 WriteGroup的任何其他组件的实体。<br />有关选项的完整列表，请参阅 EntityQueryOptions。</li></ul><h5 id="按写入组过滤">按写入组过滤</h5><p>在以下示例中，LuigiComponent 和 MarioComponent 是基于CharacterComponent 组件的同一 WriteGroup 中的组件。此查询使用需要CharacterComponent 和 MarioComponent 的 FilterWriteGroup 选项：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public struct CharacterComponent : IComponentData &#123; &#125;[WriteGroup(typeof(CharacterComponent))]public struct LuigiComponent : IComponentData &#123; &#125;[WriteGroup(typeof(CharacterComponent))]public struct MarioComponent : IComponentData &#123; &#125;[RequireMatchingQueriesForUpdate]public partial class ECSSystem : SystemBase&#123;    protected override void OnCreate()    &#123;        var query &#x3D; new EntityQueryBuilder(Allocator.Temp)            .WithAllRW&lt;CharacterComponent&gt;()            .WithAll&lt;MarioComponent&gt;()            .WithOptions(EntityQueryOptions.FilterWriteGroup)            .Build(this);    &#125;    protected override void OnUpdate()    &#123;        throw new NotImplementedException();    &#125;&#125;</code></pre></div></figure><br />此查询排除任何同时具有 LuigiComponent 和 MarioComponent 的实体，因为LuigiComponent 未明确包含在查询中。</p><p>这比 None字段更有效，因为您不需要更改其他系统使用的查询，只要它们也使用写组。</p><p>您可以使用写入组来扩展现有系统。例如，如果您在另一个系统中将CharacterComponent 和 LuigiComponent定义为不受您控制的库的一部分，则可以将 MarioComponent 与 LuigiComponent放在同一写入组中，以更改 CharacterComponent的更新方式。然后，对于您添加到 MarioComponent 的任何实体，系统都会更新CharacterComponent，但原始系统不会更新它。对于没有 MarioComponent的实体，原始系统像以前一样更新CharacterComponent。有关详细信息，请参阅有关写入组的文档。</p><h3 id="定义过滤器">定义过滤器</h3><p>要进一步对实体进行排序，您可以使用过滤器根据以下内容排除实体：</p><p>共享组件过滤器：根据共享组件的特定值过滤实体集。<br />更改过滤器：根据特定组件类型的值是否已更改来过滤实体集。<br />在您对查询对象调用 ResetFilter 之前，您设置的过滤器一直有效。</p><p>要忽略查询的活动块过滤器，请使用名称以 IgnoreFilter 结尾的EntityQuery 方法。这些方法通常比过滤等效方法更有效。例如，请参阅 IsEmpty与 IsEmptyIgnoreFilter。</p><h4 id="使用共享组件过滤器">使用共享组件过滤器</h4><p>要使用共享组件筛选器，请在 EntityQuery中包含共享组件以及任何其他需要的组件，然后调用 SetSharedComponentFilter方法。然后传入包含要选择的值的相同 ISharedComponent类型的结构。所有值都必须匹配。您最多可以向过滤器添加两个不同的共享组件。</p><p>您可以随时更改筛选器，但如果您更改筛选器，它不会更改您从组ToComponentDataArray<T> 或 ToEntityArray方法接收的任何现有实体或组件数组。您必须重新创建这些数组。</p><p>以下示例定义了一个名为 SharedGrouping的共享组件和一个仅处理组字段设置为 1 的实体的系统。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">struct SharedGrouping : ISharedComponentData&#123;    public int Group;&#125;[RequireMatchingQueriesForUpdate]partial class ImpulseSystem : SystemBase&#123;    EntityQuery query;    protected override void OnCreate()    &#123;        query &#x3D; new EntityQueryBuilder(Allocator.Temp)            .WithAllRW&lt;ObjectPosition&gt;()            .WithAll&lt;Displacement, SharedGrouping&gt;()            .Build(this);    &#125;    protected override void OnUpdate()    &#123;        &#x2F;&#x2F; Only iterate over entities that have the SharedGrouping data set to 1        query.SetSharedComponentFilter(new SharedGrouping &#123; Group &#x3D; 1 &#125;);        var positions &#x3D; query.ToComponentDataArray&lt;ObjectPosition&gt;(Allocator.Temp);        var displacements &#x3D; query.ToComponentDataArray&lt;Displacement&gt;(Allocator.Temp);        for (int i &#x3D; 0; i &lt; positions.Length; i++)            positions[i] &#x3D; new ObjectPosition            &#123;                Value &#x3D; positions[i].Value + displacements[i].Value            &#125;;    &#125;&#125;</code></pre></div></figure></p><h4 id="使用更改过滤器">使用更改过滤器</h4><p>如果您只需要在组件值更改时更新实体，请使用 SetChangedVersionFilter方法将该组件添加到 EntityQuery 过滤器。例如，以下 EntityQuery仅包含来自另一个系统已写入 Translation 组件的块的实体：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">EntityQuery query;protected override void OnCreate()&#123;    query &#x3D; new EntityQueryBuilder(Allocator.Temp)        .WithAllRW&lt;LocalToWorld&gt;()        .WithAll&lt;ObjectPosition&gt;()        .Build(this);    query.SetChangedVersionFilter(typeof(ObjectPosition));&#125;</code></pre></div></figure><br />为了提高效率，更改过滤器适用于整个原型块，而不是单个实体。更改过滤器还只检查声明对组件进行写访问的系统是否已运行，而不检查它是否更改了任何数据。例如，如果可以写入该组件类型的另一个作业访问该块，则更改过滤器将包括该块中的所有实体。这就是为什么您应该始终声明对不需要修改的组件的只读访问权限。</p><h3 id="按启用组件过滤">按启用组件过滤</h3><p>启用组件允许在运行时启用和禁用单个实体上的组件。禁用实体上的组件不会将该实体移动到新的原型中，但出于EntityQuery 匹配的目的，实体将被视为没有组件。具体来说：</p><p>如果一个实体禁用了组件 T，它将不会匹配需要组件 T 的查询（使用WithAll<T>()）。<br />如果实体禁用了组件 T，它将匹配排除组件 T 的查询（使用WithNone<T>()）。<br />大多数 EntityQuery 操作（例如 ToEntityArray 和CalculateEntityCount）会自动过滤掉其可启用组件会导致它们与查询不匹配的实体。要禁用此过滤，请使用这些操作的IgnoreFilter 变体，或在查询创建时传递EntityQueryOptions.IgnoreComponentEnabledState。</p><p>有关更多详细信息，请参阅启用的组件文档。</p><h3 id="合并查询">合并查询</h3><p>要有效地将多个查询合并为一个，您可以创建一个包含多个查询描述的查询。生成的查询与匹配任何提供的查询描述的原型相匹配。本质上，组合查询匹配查询描述的并集。以下示例选择包含ObjectRotation 组件或 ObjectRotationSpeed 组件（或两者）的任何原型：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">EntityQuery query &#x3D; new EntityQueryBuilder(Allocator.Temp)    .WithAllRW&lt;ObjectRotation&gt;()    &#x2F;&#x2F; Start a new query description    .AddAdditionalQuery()    .WithAllRW&lt;ObjectRotationSpeed&gt;()    .Build(this);</code></pre></div></figure><h3 id="执行查询">执行查询</h3><p>通常，您在安排使用它的作业时执行实体查询。您还可以调用返回实体、组件或原型块数组的EntityQuery 方法之一：</p><p>ToEntityArray：返回所选实体的数组。<br />ToComponentDataArray：返回所选实体的 T 类型组件的数组。<br />CreateArchetypeChunkArray：返回包含所选实体的所有块。因为查询对原型、共享组件值和更改过滤器进行操作，这些对于块中的所有实体都是相同的，所以存储在返回的块集中的实体集与ToEntityArray 返回的实体集相同。<br />上述方法的异步版本也可用，它安排一个作业来收集请求的数据。其中一些变体必须返回NativeList 而不是 NativeArray 才能支持可启用的组件。请参阅ToEntityListAsync、ToComponentDataListAsync 和CreateArchetypeChunkArrayAsync。</p><h3 id="编辑器中的查询">编辑器中的查询</h3><p>在编辑器中，以下图标代表查询：。当您使用特定的实体窗口和检查器时，您会看到这一点。您还可以使用“查询”窗口查看与所选查询匹配的组件和实体。</p><h2 id="使用-entitycommandbuffer-安排数据更改">使用 EntityCommandBuffer安排数据更改</h2><p>要对实体数据更改进行排队而不是立即执行更改，您可以使用EntityCommandBuffer结构，它创建一个线程安全的命令缓冲区。如果您想在作业完成时推迟任何结构更改，这将很有用。</p><h3 id="entitycommandbuffer-方法">EntityCommandBuffer 方法</h3><p>您可以使用 EntityCommandBuffer 中的方法来记录命令，这些方法反映了EntityManager 的一些方法，例如：</p><ul><li>CreateEntity(EntityArchetype)：创建具有指定原型的新实体。</li><li>DestroyEntity(Entity)：销毁实体。</li><li>SetComponent<T>(Entity, T)：为实体上类型 T 的组件设置值。</li><li>AddComponent<T>(Entity)：将类型 T 的组件添加到实体。</li><li>RemoveComponent<T>(EntityQuery)：从匹配查询的所有实体中移除类型 T的组件。<br />Unity 仅在调用主线程上的 Playback 方法时才将更改记录在EntityCommandBuffer中。如果您尝试在播放后记录任何对命令缓冲区的进一步更改，Unity会抛出异常。</li></ul><p>EntityCommandBuffer有一个作业安全句柄，类似于本机容器。如果您尝试对使用命令缓冲区的未完成计划作业执行以下任何操作，安全检查会抛出异常：</p><ul><li>通过其 AddComponent、Playback、Dispose 或其他方法访问EntityCommandBuffer。</li><li>安排另一个访问相同 EntityCommandBuffer的作业，除非新作业依赖于已安排的作业。</li></ul><h3 id="在单线程作业中使用-entitycommandbuffer">在单线程作业中使用EntityCommandBuffer</h3><p>Unity无法在作业中执行结构更改，因此您可以使用实体的命令缓冲区来推迟结构更改，直到Unity 完成作业。例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">&#x2F;&#x2F; ... in a system update&#x2F;&#x2F; You don&#39;t specify a size because the buffer will grow as needed.EntityCommandBuffer ecb &#x3D; new EntityCommandBuffer(Allocator.TempJob);&#x2F;&#x2F; The ECB is captured by the ForEach job.&#x2F;&#x2F; Until completed, the job owns the ECB&#39;s job safety handle.Entities    .ForEach((Entity e, in FooComp foo) &#x3D;&gt;    &#123;        if (foo.Value &gt; 0)        &#123;            &#x2F;&#x2F; Record a command that will later add            &#x2F;&#x2F; BarComp to the entity.            ecb.AddComponent&lt;BarComp&gt;(e);        &#125;    &#125;).Schedule();this.Dependency.Complete();&#x2F;&#x2F; Now that the job is completed, you can enact the changes.&#x2F;&#x2F; Note that Playback can only be called on the main thread.ecb.Playback(this.EntityManager);&#x2F;&#x2F; You are responsible for disposing of any ECB you create.ecb.Dispose();</code></pre></div></figure><h3 id="在并行作业中使用-entitycommandbuffer">在并行作业中使用EntityCommandBuffer</h3><p>如果要在并行作业中使用实体命令缓冲区，请使用EntityCommandBuffer.ParallelWriter，它以线程安全的方式并发记录到命令缓冲区：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">EntityCommandBuffer ecb &#x3D; new EntityCommandBuffer(Allocator.TempJob);&#x2F;&#x2F; Methods of this writer record commands to &#x2F;&#x2F; the EntityCommandBuffer in a thread-safe way.EntityCommandBuffer.ParallelWriter parallelEcb &#x3D; ecb.AsParallelWriter();</code></pre></div></figure></p><blockquote><p>note<br />只有记录需要线程安全才能并发。回放在主线程上始终是单线程的。</p></blockquote><h4 id="确定性回放">确定性回放</h4><p>因为命令的记录是跨线程拆分的，所以记录命令的顺序取决于作业调度，因此是不确定的。</p><p>确定性并不总是必不可少的，但产生确定性结果的代码更容易调试。还有一些网络场景需要在不同机器上获得一致的结果。但是，确定性会对性能产生影响，因此您可能需要在某些项目中接受不确定性。</p><p>您无法避免不确定的录制顺序，但可以通过以下方式确定命令的播放顺序：</p><ol type="1"><li>每个命令记录一个“排序键”int作为第一个参数传递给每个命令方法。您必须调用 lambda 参数entityInQueryIndex，否则 Entities.ForEach 将无法识别 int。</li><li>在播放时，在执行命令之前按命令的排序键对命令进行排序。<br />只要记录的排序键独立于调度，排序就可以确定播放顺序。</li></ol><p>在并行作业中，每个实体所需的排序键是一个数字，它与作业查询中的该实体具有固定且唯一的关联。</p><p>并行作业中提供的 entityInQueryIndex值满足这些条件。在与作业查询匹配的原型块列表中，实体具有以下索引：</p><ul><li>第一个块的第一个实体有 entityInQueryIndex 0</li><li>第一个块的第二个实体有 entityInQueryIndex 1</li><li>第二个块的第一个实体有一个entityInQueryIndex，它是第一个块的计数</li><li>第三个块的第一个实体有一个entityInQueryIndex，它是前两个块的计数之和</li></ul><p>entityInQueryIndex 始终遵循此模式。</p><p>以下示例代码显示了并行作业中使用的实体命令缓冲区：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">&#x2F;&#x2F; ... in a system updateEntityCommandBuffer ecb &#x3D; new EntityCommandBuffer(Allocator.TempJob);&#x2F;&#x2F; We need to write to the ECB concurrently across threads.EntityCommandBuffer.ParallelWriter ecbParallel &#x3D; ecb.AsParallelWriter();&#x2F;&#x2F; The entityInQueryIndex is unique for each entity and will be&#x2F;&#x2F; consistent for each particular entity regardless of scheduling.Entities    .ForEach((Entity e, int entityInQueryIndex, in FooComp foo) &#x3D;&gt; &#123;        if (foo.Value &gt; 0)        &#123;            &#x2F;&#x2F; The first arg is the &#39;sort key&#39; recorded with the command.            ecbParallel.AddComponent&lt;BarComp&gt;(entityInQueryIndex, e);        &#125;    &#125;).Schedule();&#x2F;&#x2F; Playback is single-threaded as normal.this.Dependency.Complete();&#x2F;&#x2F; To ensure deterministic playback order,&#x2F;&#x2F; the commands are first sorted by their sort keys.ecb.Playback(this.EntityManager);ecb.Dispose();</code></pre></div></figure></p><h3 id="重用-entitycommandbuffer-实例">重用 EntityCommandBuffer实例</h3><p>最好的做法是为每个作业提供自己的命令缓冲区。这是因为与在单个命令缓冲区中记录相同的命令相比，将一组命令记录到多个命令缓冲区的开销很小。</p><p>但是，您可以在非并行作业中重用相同的EntityCommandBuffer，只要这些作业在调度中不重叠即可。如果您在并行作业中重复使用EntityCommandBuffer实例，这可能会导致播放中命令的意外排序顺序，除非每个作业的排序键位于不同的范围内。</p><h3 id="多重回放">多重回放</h3><p>如果多次调用 Playback 方法，它会抛出异常。为避免这种情况，请使用PlaybackPolicy.MultiPlayback 选项创建一个 EntityCommandBuffer实例：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">&#x2F;&#x2F; ... in a system updateEntityCommandBuffer ecb &#x3D;        new EntityCommandBuffer(Allocator.TempJob, PlaybackPolicy.MultiPlayback);&#x2F;&#x2F; ... record commandsecb.Playback(this.EntityManager);&#x2F;&#x2F; Additional playbacks are OK because this ECB is MultiPlayback.ecb.Playback(this.EntityManager);ecb.Dispose();</code></pre></div></figure><br />如果您想重复生成一组实体，则多重播放很有用。为此，使用EntityCommandBuffer创建并配置一组新实体，然后重复播放以重新生成另一组匹配的实体。</p><h3 id="在主线程上使用-entitycommandbuffer">在主线程上使用EntityCommandBuffer</h3><p>您可以在主线程上记录命令缓冲区更改。这在以下情况下很有用：</p><ul><li>延迟您的更改。</li><li>多次回放一组更改。</li><li>在一个统一的地方回放很多变化。这比将更改散布在框架的不同部分更有效。</li></ul><p>每个结构更改操作都会触发一个同步点，这意味着该操作必须等待部分或所有计划作业完成。如果将结构更改组合到命令缓冲区中，则帧的同步点会更少。</p><h3 id="使用-entitycommandbuffersystem-自动播放和处理命令缓冲区">使用EntityCommandBufferSystem 自动播放和处理命令缓冲区</h3><p>您可以使用 EntityCommandBufferSystem回放和处理命令缓冲区，而不是自己手动执行。去做这个：</p><ol type="1"><li>获取要进行播放的 EntityCommandBuffer 系统的实例。</li><li>通过系统创建一个 EntityCommandBuffer 实例。</li><li>安排一个将命令写入 EntityCommandBuffer 的作业。</li><li>注册系统完成的预定作业。</li></ol><p>例如：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">&#x2F;&#x2F; ... in a system&#x2F;&#x2F; Assume an EntityCommandBufferSystem exists named FooECBSystem.EntityCommandBufferSystem sys &#x3D;        this.World.GetExistingSystemManaged&lt;FooECBSystem&gt;();&#x2F;&#x2F; Create a command buffer that will be played back&#x2F;&#x2F; and disposed by MyECBSystem.EntityCommandBuffer ecb &#x3D; sys.CreateCommandBuffer();&#x2F;&#x2F; A ForEach with no argument to Schedule implicitly&#x2F;&#x2F; assigns its returned JobHandle to this.DependencyEntities    .ForEach((Entity e, in FooComp foo) &#x3D;&gt; &#123;        &#x2F;&#x2F; ... record to the ECB    &#125;).Schedule();&#x2F;&#x2F; Register the job so that it gets completed by the ECB system.sys.AddJobHandleForProducer(this.Dependency);</code></pre></div></figure></p><div class="note note-waring">            <p>不要手动回放和处置 EntityCommandBufferSystem 创建的EntityCommandBuffer。 EntityCommandBufferSystem 为您完成这两件事。</p>          </div><p>在每次更新中，一个 EntityCommandBufferSystem：</p><ol type="1"><li>完成所有已注册的作业，以确保他们已完成录制）。</li><li>以创建它们的相同顺序播放通过系统创建的所有实体命令缓冲区。</li><li>处理 EntityCommandBuffer。</li></ol><h4 id="默认-entitycommandbuffersystem-系统">默认EntityCommandBufferSystem 系统</h4><p>默认世界具有以下默认 EntityCommandBufferSystem 系统：</p><ul><li>BeginInitializationEntityCommandBufferSystem</li><li>EndInitializationEntityCommandBufferSystem</li><li>BeginSimulationEntityCommandBufferSystem</li><li>EndSimulationEntityCommandBufferSystem</li><li>BeginPresentationEntityCommandBufferSystem</li></ul><p>因为在 Unity 将渲染数据交给渲染器之后，帧中不会发生结构变化，所以没有EndPresentationEntityCommandBufferSystem 系统。您可以改用BeginInitializationEntityCommandBufferSystem：一帧的结尾是下一帧的开始。</p><p>这些更新在标准系统组的开头和结尾。有关详细信息，请参阅有关系统更新顺序的文档。</p><p>对于大多数用例，默认系统应该足够了，但如果需要，您可以创建自己的EntityCommandBufferSystem：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">&#x2F;&#x2F; You should specify where exactly in the frame&#x2F;&#x2F; that the ECB system should update.[UpdateInGroup(typeof(SimulationSystemGroup))][UpdateAfter(typeof(FooSystem))]public class MyECBSystem : EntityCommandBufferSystem &#123;    &#x2F;&#x2F; This class is intentionally empty. There is generally no    &#x2F;&#x2F; reason to put any code in an EntityCommandBufferSystem.&#125;</code></pre></div></figure><h3 id="延迟实体">延迟实体</h3><p>EntityCommandBuffer 方法 CreateEntity 和 Instantiate记录创建实体的命令。这些方法只记录命令，不创建实体。因此，它们返回带有负索引的实体值，代表尚不存在的占位符实体。这些占位符实体值仅在同一ECB 的记录命令中有意义。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">&#x2F;&#x2F; ... in a systemEntityCommandBuffer ecb &#x3D; new EntityCommandBuffer(Allocator.TempJob);Entity placeholderEntity &#x3D; ecb.CreateEntity();&#x2F;&#x2F; Valid to use placeholderEntity in later commands of same ECB.ecb.AddComponent&lt;FooComp&gt;(placeholderEntity);&#x2F;&#x2F; The real entity is created, and&#x2F;&#x2F; FooComp is added to the real entity.ecb.Playback(this.EntityManager);&#x2F;&#x2F; Exception! The placeholderEntity has no meaning outside&#x2F;&#x2F; the ECB which created it, even after playback.this.EntityManager.AddComponent&lt;BarComp&gt;(placeholderEntity);ecb.Dispose();</code></pre></div></figure><br />AddComponent、SetComponent 或 SetBuffer 命令中记录的值可能具有 Entity字段。在回放中，Unity将这些组件或缓冲区中的任何占位符实体值重新映射到相应的实际实体。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">&#x2F;&#x2F; ... in a systemEntityCommandBuffer ecb &#x3D; new EntityCommandBuffer(Allocator.TempJob);&#x2F;&#x2F; For all entities with a FooComp component...Entities    .WithAll&lt;FooComp&gt;()    .ForEach((Entity e) &#x3D;&gt;    &#123;        &#x2F;&#x2F; In playback, an actual entity will be created        &#x2F;&#x2F; that corresponds to this placeholder entity.        Entity placeholderEntity &#x3D; ecb.CreateEntity();        &#x2F;&#x2F; (Assume BarComp has an Entity field called TargetEnt.)        BarComp bar &#x3D; new BarComp &#123; TargetEnt &#x3D; placeholderEntity &#125;;        &#x2F;&#x2F; In playback, TargetEnt will be assigned the        &#x2F;&#x2F; actual Entity that corresponds to placeholderEntity.        ecb.AddComponent(e, bar);    &#125;).Run();&#x2F;&#x2F; After playback, each entity with FooComp now has a&#x2F;&#x2F; BarComp component whose TargetEnt references a new entity.ecb.Playback(this.EntityManager);ecb.Dispose();</code></pre></div></figure></p><h3 id="在-entities.foreach-方法中使用命令缓冲区">在 Entities.ForEach方法中使用命令缓冲区</h3><p>要在 Entities.ForEach 方法中使用命令缓冲区，请将 EntityCommandBuffer参数传递给 lambda 表达式本身。仅支持一小部分 EntityCommandBuffer方法，它们具有 [SupportedInEntitiesForEach] 属性：</p><ul><li>Entity Instantiate(实体实体)</li><li>void DestroyEntity(实体实体)</li><li>void AddComponent<T>(Entity e, T component) where T : unmanaged,IComponentData</li><li>void SetComponent<T>(Entity e, T component) where T : unmanaged,IComponentData</li><li>void RemoveComponent<T>(实体 e)<br />例如，以下代码执行此操作：</li></ul><ol type="1"><li>它检查每个实体以查看其 HealthLevel 是否为 0。</li><li>如果为真，它会记录一条销毁实体的命令。</li><li>它还指定 EndSimulationEntityCommandBufferSystem 应该回放命令。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public struct HealthLevel : IComponentData&#123;    public int Value;&#125;Entities    .WithDeferredPlaybackSystem&lt;EndSimulationEntityCommandBufferSystem&gt;    .ForEach(        (Entity entity, EntityCommandBuffer buffer, HealthLevel healthLevel) &#x3D;&gt;         &#123;            if (healthLevel &#x3D;&#x3D; 0)            &#123;                buffer.DestroyEntity(entity);            &#125;        &#125;    ).ScheduleParallel();</code></pre></div></figure><br />当您在 ForEach()函数中使用这些方法中的任何一种时，编译器会在运行时生成创建、填充、回放和处理EntityCommandBuffer 实例或 EntityCommandBuffer.ParallelWriter实例所需的代码（如果调用了 ScheduleParallel()） .</li></ol><p>在 ForEach() 之外调用这些方法会导致异常。</p><h4 id="在-entities.foreach-中回放-entitycommandbuffer">在Entities.forEach 中回放 EntityCommandBuffer</h4><p>要将 EntityCommandBuffer 参数传递给 ForEach()函数，您还必须调用以下方法之一来指定何时回放命令：</p><ul><li>延迟回放：调用 WithDeferredPlaybackSystem<T>()，其中 T标识回放命令的实体命令缓冲区系统。它必须是从 EntityCommandBufferSystem派生的类型。</li><li>立即回放：在 ForEach() 函数完成所有迭代后立即调用WithImmediatePlayback() 执行实体命令。您只能将 WithImmediatePlayback()与 Run() 一起使用。</li></ul><p>编译器自动生成代码来创建和处理任何 EntityCommandBuffer 实例。</p><h2 id="查找任意数据">查找任意数据</h2><p>访问和修改数据的最有效方法是使用具有实体查询和作业的系统。这以最高效的方式利用CPU资源，内存缓存未命中率最低。理想情况下，您应该使用最有效、最快的路径来执行大量数据转换。但是，有时您可能需要在程序的任意位置访问任意实体的任意组件。</p><p>您可以在实体的 IComponentData及其动态缓冲区中查找数据。您查找数据的方式取决于您的代码是使用Entities.ForEach、IJobEntityBatch作业，还是在系统中执行的主线程上的其他一些方法。</p><h3 id="在系统中查找实体数据">在系统中查找实体数据</h3><p>要从系统的 Entities.ForEach 或 Job.WithCode方法中查找存储在任意实体组件中的数据，请使用 GetComponent<T>(Entity)</p><p>例如，以下代码使用 GetComponent<T>(Entity) 获取 Target组件，该组件具有标识要定位的实体的实体字段。然后它将跟踪实体旋转到它们的目标：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">[RequireMatchingQueriesForUpdate]public partial class TrackingSystem : SystemBase&#123;    protected override void OnUpdate()    &#123;        float deltaTime &#x3D; SystemAPI.Time.DeltaTime;        Entities            .ForEach((ref Rotation orientation,            in LocalToWorld transform,            in Target target) &#x3D;&gt;            &#123;                &#x2F;&#x2F; Check to make sure the target Entity still exists and has                &#x2F;&#x2F; the needed component                if (!HasComponent&lt;LocalToWorld&gt;(target.entity))                    return;                &#x2F;&#x2F; Look up the entity data                LocalToWorld targetTransform &#x3D; GetComponent&lt;LocalToWorld&gt;(target.entity);                float3 targetPosition &#x3D; targetTransform.Position;                &#x2F;&#x2F; Calculate the rotation                float3 displacement &#x3D; targetPosition - transform.Position;                float3 upReference &#x3D; new float3(0, 1, 0);                quaternion lookRotation &#x3D; quaternion.LookRotationSafe(displacement, upReference);                orientation.Value &#x3D; math.slerp(orientation.Value, lookRotation, deltaTime);            &#125;)            .ScheduleParallel();    &#125;&#125;</code></pre></div></figure><br />如果要访问存储在动态缓冲区中的数据，还需要在 SystemBase 的 OnUpdate方法中声明一个 BufferLookup 类型的局部变量。然后，您可以在 lambda表达式中捕获局部变量。例如：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public struct BufferData : IBufferElementData&#123;    public float Value;&#125;[RequireMatchingQueriesForUpdate]public partial class BufferLookupSystem : SystemBase&#123;    protected override void OnUpdate()    &#123;        BufferLookup&lt;BufferData&gt; buffersOfAllEntities            &#x3D; this.GetBufferLookup&lt;BufferData&gt;(true);        Entities            .ForEach((ref Rotation orientation,            in LocalToWorld transform,            in Target target) &#x3D;&gt;            &#123;                &#x2F;&#x2F; Check to make sure the target Entity with this buffer type still exists                if (!buffersOfAllEntities.HasBuffer(target.entity))                    return;                &#x2F;&#x2F; Get a reference to the buffer                DynamicBuffer&lt;BufferData&gt; bufferOfOneEntity &#x3D; buffersOfAllEntities[target.entity];                &#x2F;&#x2F; Use the data in the buffer                float avg &#x3D; 0;                for (var i &#x3D; 0; i &lt; bufferOfOneEntity.Length; i++)                &#123;                    avg +&#x3D; bufferOfOneEntity[i].Value;                &#125;                if (bufferOfOneEntity.Length &gt; 0)                    avg &#x2F;&#x3D; bufferOfOneEntity.Length;            &#125;)            .ScheduleParallel();    &#125;&#125;</code></pre></div></figure></p><h3 id="在作业中查找实体数据">在作业中查找实体数据</h3><p>要在 IJobEntityBatch等作业结构中随机访问组件数据，请使用以下类型之一：</p><ul><li>组件查找</li><li>缓冲区查找<br />这些类型获得一个类似于数组的组件接口，由 Entity 对象索引。</li></ul><p>要使用它们，请声明一个类型为 ComponentLookup 或 BufferLookup的字段，设置该字段的值，然后安排作业。</p><p>例如，您可以使用 ComponentLookup 字段来查找实体的世界位置：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">[ReadOnly]public ComponentLookup&lt;LocalToWorld&gt; EntityPositions;</code></pre></div></figure></p><div class="note note-info">            <p>此声明使用 ReadOnly 属性。您应该始终将 ComponentLookup对象声明为只读，除非您想写入您访问的组件。</p>          </div><p>以下示例说明了如何设置数据字段和安排作业：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">protected override void OnUpdate()&#123;    var job &#x3D; new ChaserSystemJob();    &#x2F;&#x2F; Set non-ECS data fields    job.deltaTime &#x3D; SystemAPI.Time.DeltaTime;    &#x2F;&#x2F; Schedule the job using Dependency property    Dependency &#x3D; job.ScheduleParallel(query, this.Dependency);&#125;</code></pre></div></figure><br />要查找组件的值，请在作业的 Execute 方法中使用实体对象：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">                float3 targetPosition &#x3D; entityPosition.Position;#if !ENABLE_TRANSFORM_V1                float3 chaserPosition &#x3D; transform.Value.Position;#else                float3 chaserPosition &#x3D; position.Value;#endif                float3 displacement &#x3D; targetPosition - chaserPosition;                float3 newPosition &#x3D; chaserPosition + displacement * deltaTime;#if !ENABLE_TRANSFORM_V1                transform.Value.Position &#x3D; newPosition;#else                position &#x3D; new Translation &#123; Value &#x3D; newPosition &#125;;#endif</code></pre></div></figure><br />以下完整示例显示了一个系统，该系统将具有目标字段的实体移动到目标的当前位置：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">    [RequireMatchingQueriesForUpdate]    public partial class MoveTowardsEntitySystem : SystemBase    &#123;        private EntityQuery query;        [BurstCompile]        private partial struct MoveTowardsJob : IJobEntity        &#123;            &#x2F;&#x2F; Read-only data stored (potentially) in other chunks            [ReadOnly]            public ComponentLookup&lt;LocalToWorld&gt; EntityPositions;            &#x2F;&#x2F; Non-entity data            public float deltaTime;#if !ENABLE_TRANSFORM_V1            public void Execute(ref LocalToWorldTransform transform, in Target target, in LocalToWorld entityPosition)#else            public void Execute(Translation position, in Target target, in LocalToWorld entityPosition)#endif            &#123;                &#x2F;&#x2F; Get the target Entity object                Entity targetEntity &#x3D; target.entity;                &#x2F;&#x2F; Check that the target still exists                if (!EntityPositions.HasComponent(targetEntity))                    return;                &#x2F;&#x2F; Update translation to move the chasing enitity toward the target                float3 targetPosition &#x3D; entityPosition.Position;#if !ENABLE_TRANSFORM_V1                float3 chaserPosition &#x3D; transform.Value.Position;                float3 displacement &#x3D; targetPosition - chaserPosition;                transform.Value.Position &#x3D; chaserPosition + displacement * deltaTime;#else                float3 chaserPosition &#x3D; position.Value;                float3 displacement &#x3D; targetPosition - chaserPosition;                position &#x3D; new Translation                &#123;                    Value &#x3D; chaserPosition + displacement * deltaTime                &#125;;#endif            &#125;        &#125;        protected override void OnCreate()        &#123;            &#x2F;&#x2F; Select all entities that have Translation and Target Component            query &#x3D; this.GetEntityQuery                (#if !ENABLE_TRANSFORM_V1                    typeof(LocalToWorldTransform),#else                    typeof(Translation),#endif                    ComponentType.ReadOnly&lt;Target&gt;()                );        &#125;        protected override void OnUpdate()        &#123;            &#x2F;&#x2F; Create the job            var job &#x3D; new MoveTowardsJob();            &#x2F;&#x2F; Set the component data lookup field            job.EntityPositions &#x3D; GetComponentLookup&lt;LocalToWorld&gt;(true);            &#x2F;&#x2F; Set non-ECS data fields            job.deltaTime &#x3D; SystemAPI.Time.DeltaTime;            &#x2F;&#x2F; Schedule the job using Dependency property            Dependency &#x3D; job.ScheduleParallel(query, Dependency);        &#125;    &#125;</code></pre></div></figure></p><h3 id="数据访问错误">数据访问错误</h3><p>如果您查找的数据与您要在作业中读取和写入的数据重叠，则随机访问可能会导致竞争条件。</p><p>如果您确定要直接读取或写入的实体数据与要随机读取或写入的特定实体数据之间没有重叠，则可以使用NativeDisableParallelForRestriction 属性标记访问器对象。</p><h2 id="写入组">写入组</h2><p>写入组为一个系统提供了一种覆盖另一个系统的机制，即使您无法更改另一个系统。</p><p>一种常见的 ECS模式是系统读取一组输入组件并将其写入另一个组件作为其输出。但是，您可能希望覆盖系统的输出，并使用基于不同输入集的不同系统来更新输出组件。</p><p>目标组件类型的写入组由 ECS 将 WriteGroup属性应用于的所有其他组件类型组成，并以该目标组件类型作为参数。作为系统创建者，您可以使用写入组，以便您的系统用户可以排除您的系统将以其他方式选择和处理的实体。这种过滤机制允许系统用户根据自己的逻辑为排除的实体更新组件，同时让您的系统在其余部分照常运行。</p><h3 id="使用写组">使用写组</h3><p>要使用写入组，您必须对系统中的查询使用写入组过滤器选项。这从查询中排除所有实体，这些实体具有来自查询中可写的任何组件的写入组的组件。</p><p>要覆盖使用写入组的系统，请将您自己的组件类型标记为该系统输出组件的写入组的一部分。原始系统忽略任何具有您的组件的实体，您可以使用您自己的系统更新这些实体的数据。</p><h3 id="编写组示例">编写组示例</h3><p>在此示例中，您使用外部包根据角色的健康状况为游戏中的所有角色着色。为此，包中有两个组件：HealthComponent和 ColorComponent；</p><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public struct HealthComponent : IComponentData&#123;   public int Value;&#125;public struct ColorComponent : IComponentData&#123;   public float4 Value;&#125;</code></pre></div></figure><p>包中还有两个系统：</p><ol type="1"><li>ComputeColorFromHealthSystem，它从 HealthComponent 读取并写入ColorComponent</li><li>RenderWithColorComponent，从 ColorComponent 读取<br />为了表示玩家何时使用能量提升并且他们的角色变得无敌，您将InvincibleTagComponent附加到角色的实体。在这种情况下，角色的颜色应该更改为单独的不同颜色，而上面的示例不适用。</li></ol><p>您可以创建自己的系统来覆盖 ColorComponent 值，但理想情况下ComputeColorFromHealthSystem 不会计算实体的颜色。它应该忽略任何具有InvincibleTagComponent的实体。当屏幕上有成千上万的玩家时，这就变得更加重要。</p><p>这个系统来自另一个不知道 InvincibleTagComponent的包，所以这是写组有用的时候。当您知道它计算的值无论如何都会被覆盖时，它允许系统忽略查询中的实体。您需要做两件事来支持这一点：</p><ol type="1"><li><p>将 InvincibleTagComponent 标记为 ColorComponent写入组的一部分：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">[WriteGroup(typeof(ColorComponent))]struct InvincibleTagComponent : IComponentData &#123;&#125;</code></pre></div></figure><br />ColorComponent 的写入组由所有组件类型组成，这些组件类型具有以typeof(ColorComponent) 作为参数的 WriteGroup 属性。</p></li><li><p>ComputeColorFromHealthSystem必须明确支持写组。为此，系统需要为其所有查询指定EntityQueryOptions.FilterWriteGroup 选项，如下所示：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">...protected override void OnUpdate() &#123;Entities    .WithName(&quot;ComputeColor&quot;)    .WithEntityQueryOptions(EntityQueryOptions.FilterWriteGroup) &#x2F;&#x2F; support write groups    .ForEach((ref ColorComponent color, in HealthComponent health) &#x3D;&gt; &#123;        &#x2F;&#x2F; compute color here    &#125;).ScheduleParallel();&#125;...</code></pre></div></figure><br />执行时，会发生以下情况：</p></li><li><p>系统检测到你写入 ColorComponent 因为它是一个引用参数</p></li><li><p>它查找 ColorComponent 的写入组并在其中找到InvincibleTagComponent</p></li><li><p>它排除了所有具有 InvincibleTagComponent 的实体</p></li></ol><p>好处是，这允许系统根据系统未知的类型排除实体，并且可能存在于不同的包中。</p><div class="note note-info">            <p>有关更多示例，请参阅 Unity.Transforms代码，它为其更新的每个组件使用写入组，包括 LocalToWorld。</p>          </div><h3 id="创建写入组">创建写入组</h3><p>要创建写入组，请将 WriteGroup属性添加到写入组中每个组件类型的声明中。 WriteGroup属性采用一个参数，即组中组件用于更新的组件类型。单个组件可以是多个写入组的成员。</p><p>例如，如果您的系统在实体上存在组件 A 或 B 时写入组件 W，那么您可以为W 定义一个写入组，如下所示：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public struct W : IComponentData&#123;   public int Value;&#125;[WriteGroup(typeof(W))]public struct A : IComponentData&#123;   public int Value;&#125;[WriteGroup(typeof(W))]public struct B : IComponentData&#123;   public int Value;&#125;</code></pre></div></figure><br />您没有将写入组的目标（上例中的组件 W）添加到它自己的写入组。</p><h3 id="启用写组过滤">启用写组过滤</h3><p>要启用写入组过滤，请在您的作业上设置 FilterWriteGroups 标志：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class AddingSystem : SystemBase&#123;   protected override void OnUpdate() &#123;      Entities          &#x2F;&#x2F; support write groups by setting EntityQueryOptions         .WithEntityQueryOptions(EntityQueryOptions.FilterWriteGroup)          .ForEach((ref W w, in B b) &#x3D;&gt; &#123;            &#x2F;&#x2F; perform computation here         &#125;).ScheduleParallel();&#125;&#125;</code></pre></div></figure><br />对于查询描述对象，在创建查询时设置标志：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class AddingSystem : SystemBase&#123;   private EntityQuery m_Query;   protected override void OnCreate()   &#123;       var queryDescription &#x3D; new EntityQueryDesc       &#123;           All &#x3D; new ComponentType[] &#123;              ComponentType.ReadWrite&lt;W&gt;(),              ComponentType.ReadOnly&lt;B&gt;()           &#125;,           Options &#x3D; EntityQueryOptions.FilterWriteGroup       &#125;;       m_Query &#x3D; GetEntityQuery(queryDescription);   &#125;   &#x2F;&#x2F; Define IJobEntityBatch struct and schedule...&#125;</code></pre></div></figure><br />当您在查询中启用写入组过滤时，该查询会将可写组件的写入组中的所有组件添加到查询的None 列表中，除非您明确将它们添加到 All 或 Any列表中。因此，如果查询明确需要来自特定写入组的实体上的每个组件，则查询只会选择该实体。如果实体具有来自该写入组的一个或多个附加组件，则查询将拒绝它。</p><p>在上面的示例代码中，查询：</p><ul><li>排除具有组件 A 的任何实体，因为 W 是可写的并且 A 是 W的写入组的一部分。</li><li>不排除具有组件 B 的任何实体。即使 B 是 W 的写入组的一部分，它也在All 列表中明确指定。</li></ul><h3 id="覆盖另一个使用写入组的系统">覆盖另一个使用写入组的系统</h3><p>如果系统在其查询中使用写组过滤，您可以使用自己的系统覆盖该系统并写入那些组件。要覆盖系统，请将您自己的组件添加到其他系统写入的组件的写入组中。</p><p>因为写组过滤排除了查询未明确要求的写组中的任何组件，所以其他系统会忽略任何具有您的组件的实体。</p><p>例如，如果您想通过指定旋转的角度和轴来设置实体的方向，您可以创建一个组件和一个系统来将角度和轴值转换为四元数并将其写入Unity.Transforms.Rotation零件。</p><p>为了防止 Unity.Transforms 系统更新Rotation，无论除您之外的其他组件是否存在，您都可以将您的组件放在Rotation 的写入组中：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;using Unity.Collections;using Unity.Entities;using Unity.Transforms;using Unity.Mathematics;[Serializable][WriteGroup(typeof(Rotation))]public struct RotationAngleAxis : IComponentData&#123;   public float Angle;   public float3 Axis;&#125;</code></pre></div></figure><br />然后，您可以无竞争地使用 RotationAngleAxis 组件更新任何实体：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using Unity.Burst;using Unity.Entities;using Unity.Jobs;using Unity.Collections;using Unity.Mathematics;using Unity.Transforms;public class RotationAngleAxisSystem : SystemBase&#123;   protected override void OnUpdate()   &#123;      Entities.ForEach((ref Rotation destination, in RotationAngleAxis source) &#x3D;&gt;      &#123;         destination.Value              &#x3D; quaternion.AxisAngle(math.normalize(source.Axis), source.Angle);      &#125;).ScheduleParallel();   &#125;&#125;</code></pre></div></figure></p><h3 id="扩展另一个使用写组的系统">扩展另一个使用写组的系统</h3><p>如果你想扩展另一个系统而不是覆盖它，或者如果你想让未来的系统覆盖或扩展你的系统，那么你可以在你自己的系统上启用写组过滤。但是，当您这样做时，默认情况下两个系统都不会处理任何组件组合。您必须明确查询和处理每个组合。</p><p>在前面的示例中，它定义了一个写入组，其中包含以组件 W 为目标的组件 A和 B。如果将名为 C 的新组件添加到写入组，那么知道 C的新系统可以查询包含的实体C，这些实体是否也有组件 A 或 B 并不重要。</p><p>但是，如果新系统还启用了写组过滤，那就不再是这样了。如果您只需要组件C，则写入组过滤会排除任何具有 A 或 B的实体。相反，您必须显式查询每个有意义的组件组合。</p><div class="note note-info">            <p>您可以在适当的时候使用查询的 Any 子句。</p>          </div><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">var query &#x3D; new EntityQueryDesc&#123;    All &#x3D; new ComponentType[] &#123;       ComponentType.ReadOnly&lt;C&gt;(),        ComponentType.ReadWrite&lt;W&gt;()    &#125;,    Any &#x3D; new ComponentType[] &#123;       ComponentType.ReadOnly&lt;A&gt;(),        ComponentType.ReadOnly&lt;B&gt;()    &#125;,    Options &#x3D; EntityQueryOptions.FilterWriteGroup&#125;;</code></pre></div></figure><p>如果有任何实体包含未明确提及的写入组中的组件组合，则写入写入组目标的系统及其过滤器不会处理它们。但是，如果存在任何这些类型的实体，则很可能是程序中的逻辑错误，它们不应该存在。</p><h2 id="版本号">版本号</h2><p>您可以使用 ECS架构各部分的版本号（也称为世代）来检测潜在的变化并实施有效的优化策略，例如在数据自应用程序的最后一帧以来未发生变化时跳过处理。对实体执行快速版本检查以提高应用程序的性能非常有用。</p><p>此页面概述了 ECS 使用的所有不同版本号，以及导致它们更改的条件。</p><h3 id="版本号结构">版本号结构</h3><p>所有版本号都是 32位有符号整数。它们总是增加，除非它们环绕：有符号整数溢出是 C#中定义的行为。这意味着要比较版本号，您应该使用（不）相等运算符，而不是关系运算符。</p><p>例如，检查 VersionB 是否比 VersionA更新的正确方法是使用以下内容：<br /><figure><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">bool VersionBIsMoreRecent &#x3D; (VersionB - VersionA) &gt; 0;</code></pre></div></figure><br />无法保证版本号增加多少。</p><h3 id="实体版本号">实体版本号</h3><p>EntityId 包含索引和版本号。因为 ECS回收索引，所以每次实体销毁实体时它都会增加 EntityManager中的版本号。如果在 EntityManager 中查找 EntityId时版本号不匹配，则意味着引用的实体不再存在。</p><p>例如，在您通过 EntityId获取一个单位正在跟踪的敌人的位置之前，您可以调用ComponentDataFromEntity.Exists。这使用版本号来检查实体是否仍然存在。</p><h3 id="世界版本号">世界版本号</h3><p>ECS每创建或销毁一个管理器（如系统），就会增加一个世界的版本号。</p><h3 id="作业组件系统版本号">作业组件系统版本号</h3><p>EntityDataManager.GlobalVersion在每次作业组件系统更新之前都会增加。</p><p>您应该将此版本号与 System.LastSystemVersion结合使用。这会在每次作业组件系统更新后获取EntityDataManager.GlobalVersion 的值。</p><p>您应该将此版本号与 Chunk.ChangeVersion[] 结合使用。</p><h4 id="块.changeversion">块.ChangeVersion</h4><p>对于原型中的每个组件类型，此数组包含 EntityDataManager.GlobalVersion的值，在组件数组最后一次被访问为在此块中可写时。这并不能保证任何事情都发生了变化，只是它可能已经发生了变化。</p><p>您不能以可写方式访问共享组件，即使也为这些组件存储了版本号：它没有任何用处。</p><p>当您在 Entities.ForEach 构造中使用 WithChangeFilter() 方法时，ECS将该特定组件的 Chunk.ChangeVersion 与 System.LastSystemVersion进行比较，并且它仅处理其组件数组在系统上次开始运行后被访问为可写的块。</p><p>例如，如果保证一组单位的生命值数量自上一帧以来没有变化，则可以跳过检查这些单位是否应更新其损坏模型。</p><h3 id="非共享组件版本号">非共享组件版本号</h3><p>对于每个非共享组件类型，每当涉及该类型的迭代器变得无效时，ECS都会增加 EntityManager.m_ComponentTypeOrderVersion[]版本号。换句话说，任何可能修改该类型数组（不是实例）的东西。</p><p>例如，如果您有特定组件标识的静态对象和每个块的边界框，则只需在该组件的类型顺序版本更改时更新这些边界框。</p><h3 id="共享组件版本号">共享组件版本号</h3><p>当存储在引用共享组件的块中的实体发生任何结构更改时，SharedComponentDataManager.m_S​​haredComponentVersion[]版本号会增加。</p><p>例如，如果您为每个共享组件保留一个实体计数，您可以依靠该版本号仅在相应版本号更改时重做每个计数。</p><h1 id="组件的使用">组件的使用</h1><p>组件代表实体组件系统 (ECS)架构中的数据。实体将组件关联在一起，系统提供可以读取和写入组件数据的逻辑。本节介绍ECS 组件并说明如何使用它们。<br />| 标题 | 描述 |<br />| —————- | ———————————— |<br />| 组件类型 | 了解不同的组件类型以及如何使用它们。 |<br />| 向实体添加组件 | 使用 C# 脚本从实体添加组件。 |<br />| 从实体中移除组件 | 使用 C# 脚本从实体中移除组件。 |<br />| 读取和写入组件值 | 使用 C# 脚本读取或写入组件值。 |</p><h2 id="组件类型">组件类型</h2><div class="note note-info">            <p>TODO</p>          </div><h2 id="向实体添加组件">向实体添加组件</h2><div class="note note-info">            <p>TODO</p>          </div><h2 id="从实体中移除组件">从实体中移除组件</h2><div class="note note-info">            <p>TODO</p>          </div><h2 id="读取和写入组件值">读取和写入组件值</h2><div class="note note-info">            <p>TODO</p>          </div><h1 id="实体包中的脚本">实体包中的脚本</h1><p>本节包含有关在实体中编写脚本时的最佳实践的信息，以及您可以在脚本中使用的一些功能。</p><table><thead><tr class="header"><th>标题</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>使用方面组织代码</td><td>使用方面将实体组件的子集组合到单个 C# 结构中。</td></tr><tr class="even"><td>Blob 资产</td><td>有关 blob资产的信息，这些资产是针对流式处理优化的二进制数据片段。</td></tr><tr class="odd"><td>在运行时加载场景</td><td>关于实体如何加载场景的信息。</td></tr><tr class="even"><td>转换系统</td><td>有关转换如何在实体中工作的信息。</td></tr></tbody></table><h2 id="使用-baking-转换数据">使用 Baking 转换数据</h2><div class="note note-info">            <p>TODO</p>          </div><h2 id="使用方面组织代码">使用方面组织代码</h2><div class="note note-info">            <p>TODO</p>          </div><h2 id="转换系统">转换系统</h2><div class="note note-info">            <p>TODO</p>          </div><h2 id="blob-资产">Blob 资产</h2><div class="note note-info">            <p>TODO</p>          </div><h2 id="在运行时加载场景">在运行时加载场景</h2><div class="note note-info">            <p>TODO</p>          </div><h1 id="在编辑器中工作">在编辑器中工作</h1><p>您可以在特定于实体的编辑器窗口中查看有关项目中 ECS元素的信息。手册这一部分中的文档概述了编辑器中可用的窗口、检查器和工作流。用户手册的这一部分包含以下信息：<br />| 标题 | 描述 |<br />| ——————– | ———————————————- |<br />| 实体首选项参考 | 首选项窗口中实体特定属性的参考。 |<br />| 使用创作和运行时数据 | 有关编辑器中不同数据模式的信息。 |<br />| 实体窗口 | 编辑器中各种窗口的参考，包括实体层次结构窗口。 |<br />| 实体Inspectors | 有关特定于实体的检查员的信息。 |</p><h2 id="实体首选项参考">实体首选项参考</h2><div class="note note-info">            <p>TODO</p>          </div><h2 id="使用创作和运行时数据">使用创作和运行时数据</h2><div class="note note-info">            <p>TODO</p>          </div><h2 id="实体窗口">实体窗口</h2><div class="note note-info">            <p>TODO</p>          </div><h2 id="实体inspectors">实体Inspectors</h2><div class="note note-info">            <p>TODO</p>          </div><h1 id="性能和调试">性能和调试</h1><p>本节包含有关可用于衡量项目性能的工具以及如何调试它的信息。<br />| 标题 | 描述 |<br />| ————————- | ———————————————— |<br />| Entities Profiler modules | 有关 Unity Profiler中内置的特定实体模块的信息。 |<br />| Entities Journaling | 使用 Entities Journaling 来调试您的项目。 |</p><h2 id="entities-profiler-modules">Entities Profiler modules</h2><div class="note note-info">            <p>TODO</p>          </div><h2 id="entities-journaling">Entities Journaling</h2><div class="note note-info">            <p>TODO</p>          </div>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Entities</tag>
      
      <tag>ECS</tag>
      
      <tag>DOTS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode远程容器开发</title>
    <link href="/2022/11/10/vscode-remote-containers/"/>
    <url>/2022/11/10/vscode-remote-containers/</url>
    
    <content type="html"><![CDATA[<p>之前在折腾HomeAssistant集成开发时接触到了VSCode的容器内开发，即使用容器构建开发环境，简化不同机器的开发环境的部署，确保团队环境一直，同时也方便了后修的测试。果然Docker是越用越爽。<br /><span id="more"></span><br />再加上vscode的远程ssh连接模式，可以在不同的机器上统一连接到家中的服务器上，再使用这台机器去构建Docker容器，确保可在任意电脑上仅需安装vscode，就可以拥有统一的开发环境，这里就以hexo为例，记录下踩的那些坑。</p><h1 id="插件安装">插件安装</h1><p>一共两个<br /><code>Remote Development</code><br /><code>DEV containers</code></p><h1 id="配置建立">配置建立</h1><p>项目根目录下创建<code>.devcontiner</code>文件夹，然后是<code>devcontiner.json</code>配置文件，这里详细的配置参照<ahref="https://containers.dev/implementors/json_reference/">containers.dev的文档</a>，下面贴出这里使用的配置<br /><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;    &quot;name&quot;: &quot;Hexo blog&quot;,    &quot;dockerFile&quot;: &quot;Dockerfile&quot;,    &quot;appPort&quot;: 4000,    &quot;containerUser&quot;: &quot;node&quot;,    &quot;extensions&quot;: [    ],    &quot;shutdownAction&quot;: &quot;stopContainer&quot;,    &quot;postCreateCommand&quot;: &quot;npm install;hexo s&quot;,    &quot;runArgs&quot;: [        &quot;--network&#x3D;nginxproxynet&quot;,        &quot;--net-alias&#x3D;hexoDev&quot;    ]&#125;</code></pre></div></figure></p><figure><div class="code-wrapper"><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker">FROM node:ltsRUN npm install -g hexo-cli</code></pre></div></figure><p>这里在运行参数里配置了网络和别名，方便之后做反代，但后来发现不需要，vscode自带了一个功能，可以映射容器内的任意端口到本机（也就是vscode运行的机器，不是Docker服务器），猜测是用ssh隧道实现的。<br />这里有几个坑要注意，</p><ul><li>注意容器内用户和外部项目文件的用户一致，很多容器默认是root用户，我这里外面项目的用管理员账户，这会导致权限混乱，所以这里配置了<code>"containerUser": "node"</code>node是这个镜像的默认管理员用户id为1000</li><li>创建容器后，内部的git没有复制外部的私钥，导致私有仓库无法上传，所以这里git下载和提交还是在容器外进行的</li><li><code>"appPort": 4000</code>，这里指的docker自身的端口映射，但默认vscode是只映射到127.0.0.1上，远程访问还是不方便，而且这里修改<code>local port host</code>为<code>allInterfaces</code>在远程容器内也是无效的，具体看这个<ahref="https://github.com/microsoft/vscode-remote-release/issues/6445">issues</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>vscode</tag>
      
      <tag>远程容器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker部署stable-diffusion-webui</title>
    <link href="/2022/11/09/stable-diffusion-webui-docker/"/>
    <url>/2022/11/09/stable-diffusion-webui-docker/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍">介绍</h1><p>stable-diffusion无疑是现在最热门的AI绘画模型了，stable-diffusion-webui提供了一个简单的通过web图形化调用的方法，但可惜没有提供对应的docker镜像，这里就尝试构建一个，方便之后的使用和分享。<br /><span id="more"></span></p><h1 id="搭建">搭建</h1><p>环境是一台ubuntu22.04服务器，配一张3070显卡。<br />docker安装以及显卡驱动的安装就省略吧。<br />从安装NVIDIA Container Toolkit开始。<br />按照nvidia的<ahref="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html">指南</a></p><h2 id="设置软件包存储库和-gpg-密钥">设置软件包存储库和 GPG 密钥：</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">distribution&#x3D;$(. &#x2F;etc&#x2F;os-release;echo $ID$VERSION_ID) \      &amp;&amp; curl -fsSL https:&#x2F;&#x2F;nvidia.github.io&#x2F;libnvidia-container&#x2F;gpgkey | sudo gpg --dearmor -o &#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;nvidia-container-toolkit-keyring.gpg \      &amp;&amp; curl -s -L https:&#x2F;&#x2F;nvidia.github.io&#x2F;libnvidia-container&#x2F;$distribution&#x2F;libnvidia-container.list | \            sed &#39;s#deb https:&#x2F;&#x2F;#deb [signed-by&#x3D;&#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;nvidia-container-toolkit-keyring.gpg] https:&#x2F;&#x2F;#g&#39; | \            sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;nvidia-container-toolkit.list</code></pre></div></figure><h2 id="apt安装">apt安装</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt-get updatesudo apt-get install -y nvidia-docker2sudo systemctl restart docker</code></pre></div></figure><h2 id="测试">测试</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo docker run --rm --gpus all nvidia&#x2F;cuda:11.0.3-base-ubuntu20.04 nvidia-smi</code></pre></div></figure><p>能看到nvidia-smi就算成功了<br /><img src="nvsmi.png" alt="nvidia-smi" /></p><h1 id="搭建docker镜像">搭建docker镜像</h1><p>基础镜像就选择 nvidia/cuda:11.3.1-devel-ubuntu20.04<br />然后坑就来了</p><h2 id="cuda版本">cuda版本</h2><p>因为webUI默认使用的torch是<code>pip install torch==1.12.1+cu113 --extra-index-url https://download.pytorch.org/whl/cu113</code>,所以这里要选择对应的11.3版本的cuda。</p><h2 id="用户要求非root">用户要求非root</h2><p>WebUI脚本里去限制了root用户启动，这里在dockerFile里创建非root用户来启动<br /><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">groupadd -r admin &amp;&amp; useradd -r -g admin -m admin \    &amp;&amp; mkdir &#x2F;workdir &amp;&amp; chown admin:admin &#x2F;workdir</code></pre></div></figure><br />别忘了赋予相应的权限。</p><h2 id="网络代理">网络代理</h2><p>很多库和git仓库都要去下载，要设置好对应的代理，如果想打包时就使用代理，可以在~/.docker/config.json中配置<br /><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123; &quot;proxies&quot;: &#123;   &quot;default&quot;:   &#123;     &quot;httpProxy&quot;: &quot;http:&#x2F;&#x2F;192.168.31.5:7890&quot;,     &quot;httpsProxy&quot;: &quot;http:&#x2F;&#x2F;192.168.31.5:7890&quot;,     &quot;noProxy&quot;: &quot;127.0.0.0&#x2F;8,localhost&quot;   &#125; &#125;&#125;</code></pre></div></figure></p><h2 id="python版本">python版本</h2><p>虽然要求是3.10，但实测3.8也是可以的，但再低3.6好像就不行了。</p><h2 id="gpu配置">GPU配置</h2><p>docker-compose.yml中配置<br /><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">deploy:  resources:    reservations:      devices:        - capabilities: [gpu]</code></pre></div></figure></p><h2 id="dockerfile中使用python-venv">dockerfile中使用Python-venv</h2><p>方便起见，shell选用bash<br /><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">SHELL [&quot;&#x2F;bin&#x2F;bash&quot;, &quot;-c&quot;]</code></pre></div></figure><br />这里Dockerfile中的每一行 RUN 都是一个不同的过程。如果分开写，比如<br /><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">RUN source venv&#x2F;bin&#x2F;activateRUN pip install opencv-python-headless</code></pre></div></figure><br />是没有效果的。<br />一定要连在一起<br /><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">RUN source venv&#x2F;bin&#x2F;activate &amp;&amp; pip install opencv-python-headless</code></pre></div></figure></p><h1 id="dockerfile">Dockerfile</h1><figure><div class="code-wrapper"><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker">FROM nvidia&#x2F;cuda:11.3.1-devel-ubuntu20.04SHELL [&quot;&#x2F;bin&#x2F;bash&quot;, &quot;-c&quot;]RUN apt-get update \    &amp;&amp; apt-get install git wget python3 python3-venv python3-pip -y \    &amp;&amp; groupadd -r admin &amp;&amp; useradd -r -g admin -m admin \    &amp;&amp; mkdir &#x2F;workdir &amp;&amp; chown admin:admin &#x2F;workdirUSER adminWORKDIR &#x2F;workdirRUN git clone https:&#x2F;&#x2F;github.com&#x2F;AUTOMATIC1111&#x2F;stable-diffusion-webui.gitCOPY model.ckpt &#x2F;workdir&#x2F;stable-diffusion-webui&#x2F;models&#x2F;Stable-diffusion&#x2F;WORKDIR &#x2F;workdir&#x2F;stable-diffusion-webuiENV PYTHONUNBUFFERED&#x3D;1RUN .&#x2F;webui.sh --skip-torch-cuda-test --exitRUN source venv&#x2F;bin&#x2F;activate &amp;&amp; pip install opencv-python-headlessCMD .&#x2F;webui.sh --listen</code></pre></div></figure><ul><li>这里的model.ckpt可以去<ahref="https://huggingface.co/models?other=stable-diffusion">huggingface</a>下载，选择合适的stable-diffusion模型即可。</li><li><code>RUN ./webui.sh --skip-torch-cuda-test --exit</code>这里是把第一的初始化（安装依赖、下载仓库）也放到镜像中了</li><li>默认只监听127.0.0.1，添加–listen以监听0.0.0.0，默认端口是7860，这里也通过nginx反代出去了。</li></ul><figure><img src="sd.png" alt="nginx反代" /><figcaption aria-hidden="true">nginx反代</figcaption></figure><h1 id="docker-compose">docker-compose</h1><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">version: &quot;2.3&quot;services:  app:    image: stable-diffusion-webui-docker:0.1    container_name: stable-diffusion-webui    runtime: nvidia    environment:      - HTTP_PROXY&#x3D;http:&#x2F;&#x2F;clash:7890      - HTTPS_PROXY&#x3D;http:&#x2F;&#x2F;clash:7890      - no_proxy&#x3D;localhost,127.0.0.1,::1    deploy:      resources:        reservations:          devices:            - capabilities: [gpu]networks:  default:    external: true    name: nginxproxynet</code></pre></div></figure><p>这里也可以选择配置volume，方便之后的替换模型<br /><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">volumes:  - .&#x2F;Stable-diffusion:&#x2F;workdir&#x2F;stable-diffusion-webui&#x2F;models&#x2F;Stable-diffusion</code></pre></div></figure></p><h1 id="测试-1">测试</h1><p>最后随便在网上找点提示词试一试，模型权重就用<ahref="https://huggingface.co/runwayml/stable-diffusion-v1-5">runwayml/stable-diffusion-v1-5</a>，</p><figure><img src="00000-3294290500-portrait%20phot___.png"alt="“portrait photo of a old man crying, Tattles, sitting on bed, guages in ears, looking away, serious eyes, 50mm portrait photography, hard rim lighting photography–beta –ar 2:3 –beta –upbeta”" /><figcaption aria-hidden="true">“portrait photo of a old man crying,Tattles, sitting on bed, guages in ears, looking away, serious eyes,50mm portrait photography, hard rim lighting photography–beta –ar 2:3–beta –upbeta”</figcaption></figure><figure><img src="00002-535329683-temple%20in%20ruin___.png"alt="“temple in ruines, forest, stairs, columns, cinematic, detailed, atmospheric, epic, concept art, Matte painting, background, mist, photo-realistic, concept art, volumetric light, cinematic epic + rule of thirds octane render, 8k, corona render, movie concept art, octane render, cinematic, trending on artstation, movie concept art, cinematic composition , ultra-detailed, realistic , hyper-realistic , volumetric lighting, 8k –ar 2:3 –test –uplight”" /><figcaption aria-hidden="true">“temple in ruines, forest, stairs,columns, cinematic, detailed, atmospheric, epic, concept art, Mattepainting, background, mist, photo-realistic, concept art, volumetriclight, cinematic epic + rule of thirds octane render, 8k, corona render,movie concept art, octane render, cinematic, trending on artstation,movie concept art, cinematic composition , ultra-detailed, realistic ,hyper-realistic , volumetric lighting, 8k –ar 2:3 –test–uplight”</figcaption></figure><p>再整个二刺螈的模型权重试试<ahref="https://huggingface.co/hakurei/waifu-diffusion-v1-3">waifu-diffusion-v1-3</a></p><figure><img src="00003-2351788143-best%20quality___.png"alt="“best quality,highly detailed,masterpiece,ultra-detailed,absurdres,artbook,8k_wallpaper,an extremely delicate and beautiful,detailed light,ultra-detailed,anime face,extremely_detailed_eyes_and_face,gorgeous,beautiful detailed eyes,illustration,medium breast,solo,bishoujo,St. Louis_azur lane，cosplay，blue hair，Side single ponytail hair,claret eyes”" /><figcaption aria-hidden="true">“best quality,highlydetailed,masterpiece,ultra-detailed,absurdres,artbook,8k_wallpaper,anextremely delicate and beautiful,detailed light,ultra-detailed,animeface,extremely_detailed_eyes_and_face,gorgeous,beautiful detailedeyes,illustration,medium breast,solo,bishoujo,St. Louis_azurlane，cosplay，blue hair，Side single ponytail hair,clareteyes”</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>stable-diffusion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>unity Accelerator docker compose</title>
    <link href="/2022/11/09/unityAcc/"/>
    <url>/2022/11/09/unityAcc/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍">介绍</h1><p>不多介绍了，简单来说就是为了避免团队中大家重复导入资源占用时间，搞个局域网内的缓存。<br />这样只要有一个人导入了资源，其他人再导入时就可以直接从服务器拿，节省时间。<br /><span id="more"></span><br />具体看<ahref="https://docs.unity3d.com/2022.1/Documentation/Manual/UnityAccelerator.html">官方介绍</a><br />贴一个docker-compose.yml</p><h1 id="docker-compose.yml">docker-compose.yml</h1><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">version: &#39;3&#39;services:  unityAcc:    image: unitytechnologies&#x2F;accelerator    container_name: unityAcc    volumes:      -  .&#x2F;agent:&#x2F;agent    restart: always    environment:      - USER&#x3D;user      - PASSWORD&#x3D;password    ports:      - 10080:10080networks:  default:    external: true    name: nginxproxynet</code></pre></div></figure><p>这里没有暴露管理页面的80或443端口，而是统一放到nginx反向代理网络中，方便之后做反代。<br />本来打算10080端口也做反代的，但unity客户端不支持更改其他端口，只能这样暴露出来了。</p><figure><img src="uacc.png" alt="反向代理设置" /><figcaption aria-hidden="true">反向代理设置</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>Accelerator</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>屏幕空间反射 VR (URP)</title>
    <link href="/2022/11/08/SSR-URP-In-VR/"/>
    <url>/2022/11/08/SSR-URP-In-VR/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>之前的那个VR中采用复用阴影贴图的方式，用独立的相机渲染反射贴图还是有很多不足，因为是复用的阴影贴图，如果镜子中的物体没有在正常相机内有阴影的话，镜子中也不会有阴影。<br /><span id="more"></span><br />所以还是想尝试一下SSR即平面空间反射在VR单通道模式下的实现。</p><figure><img src="ssr01.png" alt="屏幕空间反射" /><figcaption aria-hidden="true">屏幕空间反射</figcaption></figure><h1 id="分析">分析</h1><p>目前URP还没有原生支持SSR，也不想再重复造一次轮子了，这里先选用ShinySSRR作为基础的SSR，在它的基础上适配VR。</p><p>直接在单通道下使用测试一下，理所当然的当然失败了。<br />先简单看一下它原生的方式，大体分为几个步骤。</p><figure><img src="ssrr.png" alt="ShinySSRR" /><figcaption aria-hidden="true">ShinySSRR</figcaption></figure><ul><li>首先是通过要反射的物体的顶点和法线去计算每个像素的反射方向，然后通过深度图不停的去步进采样，得到最终要采样的像素的UV。同时这里记录了每个像素的粗糙度。</li><li>通过上面得到的UV，去采样一次屏幕颜色</li><li>经典的Kawase模糊去模糊反射贴图</li><li>最后依据设定的模糊程度和粗糙度再去采样对应的模糊程度的贴图，与现有的颜色相混合。</li></ul><h1 id="填坑">填坑</h1><p>这里的问题就出在第一步的步进上面，它是在屏幕空间去步进的（不知道该怎么表述这一点，它的步进、碰撞判定，全是在屏幕空间）。至于为什么能直接在屏幕空间去步进，还没有完全理解。但因为单通道的特殊性，单通道的相机的PV矩阵在这种情况下是不正确的。于是还是改为了在视角空间下去步进。<br />对比发现，相同的迭代步数，确实不如直接在屏幕空间步进的效果好。</p><p>当然这里它做了很多优化，比如从近平面去截取，依据起点和终点的像素距离去降低迭代次数等等。</p><figure><img src="ssrs.png" alt="迭代部分代码" /><figcaption aria-hidden="true">迭代部分代码</figcaption></figure><h1 id="occlusion">Occlusion</h1><p>因为VR中的实际显示面积并不是一个矩形，而是一个类似圆</p><figure><img src="oc.png" alt="Occlusion" /><figcaption aria-hidden="true">Occlusion</figcaption></figure><p>这恰好弥补了ssr边缘位置的缺陷，所以ssr在VR中实际的观感还是不错的。<br />但因为这毕竟不是原生支持的ssr，在与urp自带的lit着色器搭配使用时，并不能和urp自身的反射融合的很好（HDRP非VR模式下的SSR就可以根据当前像素是否能从SSR中获取反射而决定要不要使用反射探针）。还需要一些刻意的调整以防止和反射探针混淆。</p><h1 id="法线来源">法线来源</h1><p>这里除了使用插件原生的从模型顶点和法线贴图生成法线，也可以直接使用URP自带的NormalTexture，打开SSAO即可。所以SSR和延迟管线才是绝配，但又因为延迟管线无法使用SMAA，所以这里只能舍弃延迟管线了。<br />使用NormalTexture还有一大好处是可以支持任何在shaderGraph中生成的shader。比如这里的用flipbook和视差贴图做的石子地面就可以和SSR无缝衔接起来。</p>]]></content>
    
    
    <categories>
      
      <category>渲染</category>
      
    </categories>
    
    
    <tags>
      
      <tag>URP</tag>
      
      <tag>VR</tag>
      
      <tag>反射</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>体积云复刻</title>
    <link href="/2022/07/14/Cloud/"/>
    <url>/2022/07/14/Cloud/</url>
    
    <content type="html"><![CDATA[<p>体积云复刻。<br />在unity中复刻了这个ShaderToy中的效果。添加了视角的移动以及平面的反射。<br /><a href="https://www.shadertoy.com/view/XslGRr">Clouds by iq</a></p><span id="more"></span><p class="note note-primary">wasd qe移动 鼠标右键旋转</p><div id="threeShader"style="position: relative; width: 100%; height: 0px; padding-bottom: 75%;"><iframe src="/static/Cloud/index.html" allowfullscreen="true" name="ThreeJSFrame" title="ThreeJSFrame" style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px; border: none;"></iframe></div><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">Shader &quot;KM&#x2F;Cloud&quot;&#123;    Properties    &#123;        iChannel0(&quot;iChannel0&quot;, 2D) &#x3D; &quot;black&quot; &#123;&#125;        iChannel1(&quot;iChannel1&quot;, 2D) &#x3D; &quot;black&quot; &#123;&#125;        _StepTime(&quot;_StepTime&quot;, Range(0,10)) &#x3D; 1        [HDR] LightColor(&quot;LightColor&quot;, Color) &#x3D; (1.0, 0.95, 0.8)        [HDR] DarkColor(&quot;DarkColor&quot;, Color) &#x3D; (0.25, 0.3, 0.35)        [HDR] Color01(&quot;Color01&quot;, Color) &#x3D;  (1.0, 0.6, 0.3)        [HDR] Color02(&quot;Color02&quot;, Color) &#x3D;  (0.91, 0.98, 1.05)        height(&quot;height&quot;, Range(0,2)) &#x3D;  1.5        hd(&quot;hd&quot;, Range(0,2)) &#x3D;  1.75        index(&quot;index&quot;, Range(-2,2)) &#x3D;  -1        sunDiff(&quot;sunDiff&quot;, Range(0,10)) &#x3D;  0.3        skyIndex(&quot;skyIndex&quot;, Range(-0.003,0)) &#x3D;  -0.003    &#125;    SubShader    &#123;        Tags        &#123;            &quot;RenderType&quot;&#x3D;&quot;Transparent&quot; &quot;RenderPeipeline&quot; &#x3D; &quot;UniversalPepeline&quot; &quot;Queue&quot;&#x3D;&quot;Transparent&quot;        &#125;        LOD 100        Pass        &#123;            name &quot;ShaderToy&quot;            blend one zero            ZWrite off            ZTest always            Cull off            HLSLPROGRAM            #pragma  vertex vert            #pragma  fragment frag            #define iTime   (0.5*_Time.y%100)            #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;            #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Lighting.hlsl&quot;            TEXTURE2D_X(iChannel0);            SAMPLER(sampler_iChannel0);            TEXTURE2D_X(iChannel1);            SAMPLER(sampler_iChannel1);            CBUFFER_START(UnityPerMaterial)            float4 iChannel1_TexelSize;            float4 LightColor;            float4 DarkColor;            float4 Color01;            float4 Color02;            float height;            float hd;            float index;            float sunDiff;            float skyIndex;                        float _StepTime;            CBUFFER_END            &#x2F;&#x2F;            &#x2F;&#x2F; Copyright Inigo Quilez, 2013 - https:&#x2F;&#x2F;iquilezles.org&#x2F;            &#x2F;&#x2F; I am the sole copyright owner of this Work.            &#x2F;&#x2F; You cannot host, display, distribute or share this Work in any form,            &#x2F;&#x2F; including physical and digital. You cannot use this Work in any            &#x2F;&#x2F; commercial or non-commercial product, website or project. You cannot            &#x2F;&#x2F; sell this Work and you cannot mint an NFTs of it.            &#x2F;&#x2F; I share this Work for educational purposes, and you can link to it,            &#x2F;&#x2F; through an URL, proper attribution and unmodified screenshot, as part            &#x2F;&#x2F; of your educational material. If these conditions are too restrictive            &#x2F;&#x2F; please contact me and we&#39;ll definitely work it out.            &#x2F;&#x2F; Volumetric clouds. Not physically correct in any way -             &#x2F;&#x2F; it does the wrong extintion computations and also            &#x2F;&#x2F; works in sRGB instead of linear RGB color space. No            &#x2F;&#x2F; shadows are computed, no scattering is computed. It is            &#x2F;&#x2F; a volumetric raymarcher than samples an fBM and tweaks            &#x2F;&#x2F; the colors to make it look good.            &#x2F;&#x2F;            &#x2F;&#x2F; Lighting is done with only one extra sample per raymarch            &#x2F;&#x2F; step instead of using 3 to compute a density gradient,            &#x2F;&#x2F; by using this directional derivative technique:            &#x2F;&#x2F;            &#x2F;&#x2F; https:&#x2F;&#x2F;iquilezles.org&#x2F;articles&#x2F;derivative            &#x2F;&#x2F; 0: one 3d texture lookup            &#x2F;&#x2F; 1: two 2d texture lookups with hardware interpolation            &#x2F;&#x2F; 2: two 2d texture lookups with software interpolation            #define NOISE_METHOD 1            &#x2F;&#x2F; 0: no LOD            &#x2F;&#x2F; 1: yes LOD            #define USE_LOD 1            &#x2F;&#x2F; 0: sunset look            &#x2F;&#x2F; 1: bright look            #define LOOK 1            float noise(in float3 x)            &#123;                float3 p &#x3D; floor(x);                float3 f &#x3D; frac(x);                f &#x3D; f * f * (3.0 - 2.0 * f);                float2 uv &#x3D; (p.xy + float2(37.0, 239.0) * p.z) + f.xy;                float2 rg &#x3D; SAMPLE_TEXTURE2D_X_LOD(iChannel0, sampler_iChannel0, (uv + 0.5) &#x2F; 256.0, 0.0).yx;                return lerp(rg.x, rg.y, f.z) * 2.0 - 1.0;            &#125;            float map5(in float3 p)            &#123;                float3 q &#x3D; p - float3(0.0, 0.1, 1.0) * iTime;                float f;                f &#x3D; 0.50000 * noise(q);                q &#x3D; q * 2.02;                f +&#x3D; 0.25000 * noise(q);                q &#x3D; q * 2.03;                f +&#x3D; 0.12500 * noise(q);                q &#x3D; q * 2.01;                f +&#x3D; 0.06250 * noise(q);                q &#x3D; q * 2.02;                f +&#x3D; 0.03125 * noise(q);                return clamp(height +index* p.y  + hd * f, 0.0, 1.0);            &#125;            float map4(in float3 p)            &#123;                float3 q &#x3D; p - float3(0.0, 0.1, 1.0) * iTime;                float f;                f &#x3D; 0.50000 * noise(q);                q &#x3D; q * 2.02;                f +&#x3D; 0.25000 * noise(q);                q &#x3D; q * 2.03;                f +&#x3D; 0.12500 * noise(q);                q &#x3D; q * 2.01;                f +&#x3D; 0.06250 * noise(q);                return clamp(height +index* p.y  + hd * f, 0.0, 1.0);            &#125;            float map3(in float3 p)            &#123;                float3 q &#x3D; p - float3(0.0, 0.1, 1.0) * iTime;                float f;                f &#x3D; 0.50000 * noise(q);                q &#x3D; q * 2.02;                f +&#x3D; 0.25000 * noise(q);                q &#x3D; q * 2.03;                f +&#x3D; 0.12500 * noise(q);                return clamp(height +index* p.y   + hd * f, 0.0, 1.0);            &#125;            float map2(in float3 p)            &#123;                float3 q &#x3D; p - float3(0.0, 0.1, 1.0) * iTime;                float f;                f &#x3D; 0.50000 * noise(q);                q &#x3D; q * 2.02;                f +&#x3D; 0.25000 * noise(q);;                return clamp(height +index* p.y   + hd * f, 0.0, 1.0);            &#125;            static float3 sundir ;            #define MARCH(STEPS,MAPLOD) for(int i&#x3D;0; i&lt;STEPS; i++) &#123; t +&#x3D; max(0.06,0.05*t); float3 pos &#x3D; ro + t*rd;  if( sum.a&gt;0.99 ) continue; float den &#x3D; MAPLOD( pos ); if( den&gt;0.01 ) &#123; float dif &#x3D; clamp((den - MAPLOD(pos+sunDiff*sundir))&#x2F;0.6, 0.0, 1.0 ); float3 lin &#x3D; Color01 * dif + Color02; float4  col &#x3D; float4( lerp( LightColor.rgb, DarkColor, den ), den ); col.xyz *&#x3D; lin; col.xyz &#x3D; lerp( col.xyz, bgcol, 1.0-exp(skyIndex*t*t) ); col.w *&#x3D; 0.4; col.rgb *&#x3D; col.a; sum +&#x3D; col*(1.0-sum.a); &#125;  &#125;            float4 raymarch(in float3 ro, in float3 rd, in float3 bgcol, in int2 px)            &#123;                float4 sum &#x3D; (0.0);                                float2 uv &#x3D; (floor((px)) + 0.5) * iChannel1_TexelSize.xy;                float t &#x3D; 0.05 * SAMPLE_TEXTURE2D_X_LOD(iChannel1, sampler_iChannel1,uv, 0).x;                MARCH(40 * _StepTime, map5);                MARCH(40* _StepTime, map4);                MARCH(30* _StepTime, map3);                MARCH(30* _StepTime, map2);                return clamp(sum, 0.0, 1.0);            &#125;            float MAPLOD(float3 p)            &#123;                return map2(p);            &#125;            float4 test(int STEPS, in float3 ro, in float3 rd, in float3 bgcol)            &#123;                float4 sum &#x3D; (0.0);                float t &#x3D; 0.05*0.5;                                for (int i &#x3D; 0; i &lt; STEPS; i++)                &#123;                    t +&#x3D; max(0.06, 0.05 * t);                    float3 pos &#x3D; ro + t * rd;                    if (pos.y &lt; -3.0 || pos.y &gt; 2.0 || sum.a &gt; 0.99) continue;                    float den &#x3D; MAPLOD(pos);                    if (den &gt; 0.01)                    &#123;                        &#x2F;&#x2F; 沿光照方向的浓度差                        float dif &#x3D; clamp((den - MAPLOD(pos + sunDiff * sundir)) &#x2F; 0.6, 0.0, 1.0);                        &#x2F;&#x2F; 光照                        float3 lin &#x3D; Color01 * dif + Color02;                        &#x2F;&#x2F; 亮部和暗部颜色用浓度来Lerp                        float4 col &#x3D; float4(lerp(LightColor.xyz, DarkColor.xyz, den), den);                        col.xyz *&#x3D; lin;                        &#x2F;&#x2F; 和背景色随距离混合                        col.xyz &#x3D; lerp(col.xyz, bgcol, 1.0 - exp(-0.003 * t * t));                                                col.w *&#x3D; 0.4;                        col.rgb *&#x3D; col.a;                        sum +&#x3D; col * (1.0 - sum.a);                    &#125;                &#125;                                return sum;            &#125;            float4 render(in float3 ro, in float3 rd, in int2 px)            &#123;                &#x2F;&#x2F; background sky                         float sun &#x3D; clamp(dot(sundir, rd), 0.0, 1.0);                float3 col &#x3D; float3(0.6, 0.71, 0.75) - rd.y * 0.2 * float3(1.0, 0.5, 1.0) + 0.15 * 0.5;                col +&#x3D; 0.2 * float3(1.0, .6, 0.1) * pow(sun, 8.0);                &#x2F;&#x2F; clouds                        float4 res &#x3D; raymarch(ro, rd, col, px);                col &#x3D; col * (1.0 - res.w) + res.xyz;                &#x2F;&#x2F; sun glare                        col +&#x3D; float3(0.2, 0.08, 0.04) * pow(sun, 3.0);                &#x2F;&#x2F; col &#x3D; res.xyz;                return float4(col, 1.0);            &#125;            float3 mainImage(in float2 screen_pos)            &#123;                float2 uv &#x3D; screen_pos &#x2F; _ScreenParams;                &#x2F;&#x2F; camera                float3 ro &#x3D; _WorldSpaceCameraPos;                float3 rd &#x3D; ComputeWorldSpacePosition(uv, 0, UNITY_MATRIX_I_VP);                rd &#x3D; rd - ro;                rd &#x3D; normalize(rd);                return render(ro, rd, int2(screen_pos - 0.5));            &#125;                        struct Attributes            &#123;                float4 positionOS : POSITION;                float2 uv : TEXCOORD0;                UNITY_VERTEX_INPUT_INSTANCE_ID            &#125;;            struct Varyings            &#123;                float4 positionHCS : SV_POSITION;                float2 uv : TEXCOORD0;                float3 viewPos : TEXCOORD1;                UNITY_VERTEX_OUTPUT_STEREO            &#125;;            Varyings vert(Attributes input)            &#123;                Varyings output;                UNITY_SETUP_INSTANCE_ID(input);                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);                output.positionHCS &#x3D; float4(input.positionOS.xy, 0.5, 0.5);                output.viewPos &#x3D; mul(UNITY_MATRIX_I_P, output.positionHCS).xyz;                output.uv &#x3D; input.uv;                return output;            &#125;            half4 frag(Varyings input):SV_Target            &#123;                UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);                sundir &#x3D; GetMainLight().direction;                const float2 screen_pos &#x3D; input.positionHCS.xy;                float3 color &#x3D; mainImage(screen_pos);                &#x2F;&#x2F; post                return float4(color, 1.0);            &#125;            ENDHLSL        &#125;    &#125;&#125;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>渲染</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shader</tag>
      
      <tag>体积云</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Copy From Shader Toy</title>
    <link href="/2022/07/05/Copy-From-Shader-Toy/"/>
    <url>/2022/07/05/Copy-From-Shader-Toy/</url>
    
    <content type="html"><![CDATA[<p>在unity中复刻了这个ShaderToy中的效果。添加了视角的移动以及平面的反射。<br /><a href="https://www.shadertoy.com/view/Ms2SD1">Seascape” by AlexanderAlekseev aka TDM - 2014</a><br /><img src="water.jpg" alt="搭配平面反射后的水面效果" /></p><p class="note note-primary">wasd qe移动 鼠标右键旋转</p><div id="threeShader"style="position: relative; width: 100%; height: 0px; padding-bottom: 75%;"><iframe src="/static/ref-br/index.html" allowfullscreen="true" name="ThreeJSFrame" title="ThreeJSFrame" style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px; border: none;"></iframe></div>]]></content>
    
    
    <categories>
      
      <category>渲染</category>
      
    </categories>
    
    
    <tags>
      
      <tag>水面</tag>
      
      <tag>Shader</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebGL Brotli 压缩及vercel部署</title>
    <link href="/2022/07/04/WebGLBrotli/"/>
    <url>/2022/07/04/WebGLBrotli/</url>
    
    <content type="html"><![CDATA[<h1 id="unity-webgl-brotli压缩测试">Unity WebGL Brotli压缩测试</h1><p>各个静态网页代理配置的方式不一，以vercel举例。<br />需要在根目录下添加<code>vercel.json</code>文件，给已经被Unity用Br压缩过的文件重载或添加httpHeader。</p><p>Gzip也是一样，br改成gzip即可。<br /><span id="more"></span><br />因为GithubPage不支持修改httpHeader，所以只有通过<ahref="https://vercel.kuanmi.top/2022/07/04/WebGLBrotli/">vercel.kuanmi.top</a>访问此文章才能正常加载下面的unityWebGL。</p><p>最难受的是这里用的是一种<ahref="https://github.com/isaacs/node-glob#glob-primer">glob</a>的模式去匹配路径。<br />这和一般后端的正则有点出入，反复试错了半下午才弄好。</p><div id="threeShader"style="position: relative; width: 100%; height: 0px; padding-bottom: 75%;"><iframe src="/static/BR/index.html" allowfullscreen="true" name="ThreeJSFrame" title="ThreeJSFrame" style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px; border: none;"></iframe></div><h1 id="vercel.json">vercel.json</h1><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;    &quot;headers&quot;: [        &#123;            &quot;source&quot;: &quot;&#x2F;static&#x2F;BR&#x2F;Build&#x2F;(.*)\\.data\\.br&quot;,            &quot;headers&quot;: [                &#123;                    &quot;key&quot;: &quot;Content-Encoding&quot;,                    &quot;value&quot;: &quot;br&quot;                &#125;,                &#123;                    &quot;key&quot;: &quot;Content-Type&quot;,                    &quot;value&quot;: &quot;application&#x2F;octet-stream&quot;                &#125;            ]        &#125;,        &#123;            &quot;source&quot;: &quot;&#x2F;static&#x2F;BR&#x2F;Build&#x2F;(.*)\\.js\\.br&quot;,            &quot;headers&quot;: [                &#123;                    &quot;key&quot;: &quot;Content-Encoding&quot;,                    &quot;value&quot;: &quot;br&quot;                &#125;,                &#123;                    &quot;key&quot;: &quot;Content-Type&quot;,                    &quot;value&quot;: &quot;application&#x2F;javascript&quot;                &#125;            ]        &#125;,        &#123;            &quot;source&quot;: &quot;&#x2F;static&#x2F;BR&#x2F;Build&#x2F;(.*)\\.wasm\\.br&quot;,            &quot;headers&quot;: [                &#123;                    &quot;key&quot;: &quot;Content-Encoding&quot;,                    &quot;value&quot;: &quot;br&quot;                &#125;,                &#123;                    &quot;key&quot;: &quot;Content-Type&quot;,                    &quot;value&quot;: &quot;application&#x2F;wasm&quot;                &#125;            ]        &#125;    ]&#125;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WebGL</tag>
      
      <tag>Brotli</tag>
      
      <tag>vercel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LoadShaderToy</title>
    <link href="/2022/07/04/LoadShaderToy/"/>
    <url>/2022/07/04/LoadShaderToy/</url>
    
    <content type="html"><![CDATA[<p>从ShaderToy复制一个简单的无贴图shader（或者使用最下面的），粘贴到下面，然后加载。</p><span id="more"></span><div id="threeShader"style="position: relative; width: 100%; height: 0px; padding-bottom: 120%;"><iframe src="/static/LoadShaderToy/index.html" name="ThreeJSFrame" title="ThreeJSFrame" style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px; border: none;"></iframe></div><figure><div class="code-wrapper"><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl">&#x2F;&#x2F; http:&#x2F;&#x2F;mathworld.wolfram.com&#x2F;HeartSurface.htmlfloat f(vec3 p) &#123;    vec3 pp &#x3D; p * p;    vec3 ppp &#x3D; pp * p;    float a &#x3D; pp.x + 2.25 * pp.y + pp.z - 1.0;    return a * a * a - (pp.x + 0.1125 * pp.y) * ppp.z;&#125;&#x2F;&#x2F; Bisection solver for yfloat h(float x, float z) &#123;    float a &#x3D; 0.0, b &#x3D; 0.75, y &#x3D; 0.5;    for (int i &#x3D; 0; i &lt; 10; i++) &#123;        if (f(vec3(x, y, z)) &lt;&#x3D; 0.0)            a &#x3D; y;        else            b &#x3D; y;        y &#x3D; (a + b) * 0.5;    &#125;    return y;&#125;&#x2F;&#x2F; Analytical gradient&#x2F;&#x2F; (-2 x z^3+6 x (-1.+x^2+2.25 y^2+z^2)^2) &#x2F;&#x2F; (-0.225 y z^3+13.5 y (-1.+x^2+2.25 y^2+z^2)^2)&#x2F;&#x2F; (z (-3 x^2 z-0.3375 y^2 z+6 (-1.+x^2+2.25 y^2+z^2)^2))vec3 normal(vec2 p) &#123;    vec3 v &#x3D; vec3(p.x, h(p.x, p.y), p.y);    vec3 vv &#x3D; v * v;    vec3 vvv &#x3D; vv * v;    float a &#x3D; -1.0 + dot(vv, vec3(1, 2.25, 1));   a *&#x3D; a;      return normalize(vec3(        -2.0 * v.x * vvv.z +  6.0 * v.x * a,      -0.225 * v.y * vvv.z + 13.5 * v.y * a,      v.z * (-3.0 * vv.x * v.z - 0.3375 * vv.y * v.z + 6.0 * a)));&#125;void mainImage( out vec4 fragColor, in vec2 fragCoord ) &#123;vec3 p &#x3D; vec3((2.0 * fragCoord.xy - iResolution.xy) &#x2F; min(iResolution.y, iResolution.x), 0);        float s &#x3D; sin(iTime * 5.0);    s *&#x3D; s;    s *&#x3D; s;    s *&#x3D; 0.1;    vec3 tp &#x3D; p * vec3(1.0 + s, 1.0 - s, 0.0) * 2.0;        vec3 c;    if (f(tp.xzy) &lt;&#x3D; 0.0) &#123;        vec3 n &#x3D; normal(tp.xy);        float diffuse &#x3D; dot(n, normalize(vec3(-1, 1, 1))) * 0.5 + 0.5;        float specular &#x3D; pow(max(dot(n, normalize(vec3(-1, 2, 1))), 0.0), 64.0);        float rim &#x3D; 1.0 - dot(n, vec3(0.0, 1.0, 0.0));        c &#x3D; diffuse * vec3(1.0, 0, 0) + specular * vec3(0.8) + rim * vec3(0.5);    &#125;else        c &#x3D; vec3(1.0, 0.8, 0.7 - 0.07 * p.y) * (1.0 - 0.15 * length(p));    fragColor &#x3D; vec4(c, 1);&#125;</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>渲染</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ShaderToy</tag>
      
      <tag>ThreeJS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UnityWebGL 测试</title>
    <link href="/2022/07/02/UnityWebGLTest/"/>
    <url>/2022/07/02/UnityWebGLTest/</url>
    
    <content type="html"><![CDATA[没有使用压缩的版本，与使用了<ahref="/2022/07/04/WebGLBrotli/">Brotli压缩</a>对比。<br /><span id="more"></span><br /><div id="threeShader"style="position: relative; width: 100%; height: 0px; padding-bottom: 75%;"><iframe src="/static/URPWebGL/index.html" allowfullscreen="true" name="ThreeJSFrame" title="ThreeJSFrame" style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px; border: none;"></iframe></div>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WebGL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello ThreeJS</title>
    <link href="/2022/07/02/HelloThreeJS/"/>
    <url>/2022/07/02/HelloThreeJS/</url>
    
    <content type="html"><![CDATA[恶补了一堆前端知识，用iframe内嵌一个ThreeJS的Demo。<br /><div id="threeShader"style="position: relative; width: 100%; height: 0px; padding-bottom: 75%;"><iframe src="/static/HelloThreeJS/index.html" allowfullscreen="true" name="ThreeJSFrame" title="ThreeJSFrame" style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px; border: none;"></iframe></div></script>]]></content>
    
    
    <categories>
      
      <category>渲染</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ThreeJS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello ShaderToy</title>
    <link href="/2022/07/02/HelloShaderToy/"/>
    <url>/2022/07/02/HelloShaderToy/</url>
    
    <content type="html"><![CDATA[<p>叹为观止。<br /><span id="more"></span><br /><a href="https://www.shadertoy.com/view/Ms2SD1">Seascape” by AlexanderAlekseev aka TDM - 2014</a></p><!--more--><div id="threeShader"style="position: relative; width: 100%; height: 0px; padding-bottom: 56.25%;"><iframe src="/static/HelloShaderToy/index.html" allowfullscreen="true" name="ThreeJSFrame" title="ThreeJSFrame" style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px; border: none;"></iframe></div>]]></content>
    
    
    <categories>
      
      <category>渲染</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shader</tag>
      
      <tag>ShaderToy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>平面反射效果 VR (URP)</title>
    <link href="/2022/07/01/Plane-reflection-in-VR-URP/"/>
    <url>/2022/07/01/Plane-reflection-in-VR-URP/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>前几日去HDRP下试验了各种效果在VR下的可用性，结果是一塌糊涂。像屏幕空间反射、或者Planarprobe这种效果官方压根就<ahref="https://issuetracker.unity3d.com/issues/xr-hdrp-planar-reflection-probes-reflection-is-misaligned-for-both-eyes-when-vr-is-enabled">没打算支持VR</a>，只能自力更生了。<br /><span id="more"></span><br />本着柿子捡软的捏的原则，先从复刻平面探针入手吧。<br />如果不考虑VR这个实现其实不难，但Unity的单通道渲染实在是太不成熟了，坑一个接一个，这次记录一下踩坑教训。<br /><ahref="https://github.com/MaZhengKe/Plane-reflection-urp-vr">仓库Demo地址</a></p><p><img src="water.jpg" alt="水面效果" /><br /><img src="mirror05.jpg" alt="镜面效果" /></p><h1 id="分析">分析</h1><p>去HDRP的管线下看了半天，平面反射探针的实现和HDRP耦合的太高了，很难分离开直接移植到URP下，但大体思路就是用一个独立的相机去渲染到一张贴图上。然后基于这张贴图去玩各种花活。<br />出于性能考虑，就不单独去生成一个相机再去渲染了，还是直接在RenderFeature的层面，重写相机的位置和视锥体以及剔除，直接绘制，能节省很多开销。</p><h1 id="填坑">填坑</h1><h2 id="非vr实现">非VR实现</h2><p>思路很简单，先看非VR下的实现。<br />在ScriptableRenderPass中<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">CoreUtils.SetRenderTarget(cmd, m_MirrorTexture, ClearFlag.All, Color.clear);var mirrorPos &#x3D; MirrorPlanar.mirrorPos(MirrorPlanar.Plane,camTransform.position);var viewM &#x3D; MirrorPlanar.GetViewMat(camTransform.position, rotation);var projectionMatrix &#x3D; camera.projectionMatrix;projectionMatrix &#x3D; GL.GetGPUProjectionMatrix(projectionMatrix, cameraData.IsCameraProjectionMatrixFlipped());cmd.SetGlobalVector(worldSpaceCameraPos,new Vector4(mirrorPos.x,mirrorPos.y,mirrorPos.z,0));RenderingUtils.SetViewAndProjectionMatrices(cmd, viewM, projectionMatrix, false);</code></pre></div></figure><br />这里通过原Camera的坐标和旋转，以及要镜像的平面，生成了虚拟相机的坐标以及View矩阵和投影矩阵。然后写入shader中，覆盖了原相机的相机矩阵和投影矩阵。<br />这里不要忘记连带worldSpaceCameraPos一起写进去。</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">context.ExecuteCommandBuffer(cmd);cmd.Clear();context.DrawRenderers(cullingResults, ref drawingSettings, ref m_FilteringSettings);context.DrawSkybox(cameraData.camera);cmd.SetGlobalTexture(s_MirrorTextureID, m_MirrorTexture.nameID);var viewMatrix &#x3D; camera.worldToCameraMatrix;RenderingUtils.SetViewAndProjectionMatrices(cmd, viewMatrix, cameraData.GetGPUProjectionMatrix(),false);</code></pre></div></figure><p>然后就是绘制，这里可以在之前通过设置layerMask等来控制要绘制的物体，防止地板遮挡等问题的出现。<br />绘制结束别忘记把之前重载的属性恢复回来。<br />这样就相当于从镜子的另一面用相同的相机绘制到了一张RT上。</p><p>然后是Shader部分，这里就很简单了<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">TEXTURE2D_X(_MirrorTex);SAMPLER(sampler_MirrorTex);half4 frag(Varyings input):SV_Target&#123;    UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);    float2 screenUV &#x3D; input.positionHCS &#x2F; _ScreenParams;    screenUV.x &#x3D; 1 - screenUV.x;    return SAMPLE_TEXTURE2D_X(_MirrorTex, sampler_MirrorTex, screenUV) * 0.8;    return 1;&#125;</code></pre></div></figure><br />拿到屏幕坐标，反转一下X轴，去采样之前渲染的那张RT就好了。<br /><img src="mirror01.jpg" alt="普通镜面" /></p><h2 id="vr单通道模式下实现">VR单通道模式下实现</h2><p>然后天坑就来了<br />第一个问题就是如何获取左右眼的世界坐标。<br />本来使用的是unityXR中的函数来获取，但这个支持的并不好，比如unity自带的mockhmd就获取不到。简单列一下代码吧。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public static Vector3 GetEyePosition(Side eye)&#123;    if (XRSettings.enabled)    &#123;        Vector3 pos;        InputDevice device &#x3D; InputDevices.GetDeviceAtXRNode(XRNode.Head);        if (device.isValid)        &#123;            Debug.Log($&quot;&#123;device&#125; isValid&quot;);            if (device.TryGetFeatureValue(eye &#x3D;&#x3D; Side.Left ? CommonUsages.leftEyePosition : CommonUsages.rightEyePosition,out pos))                return pos;        &#125;        Debug.LogError(&quot;can not find eyePos&quot;);        return default(Vector3);    &#125;    else    &#123;        return Camera.main.transform.position;    &#125;&#125;</code></pre></div></figure><br />最后还是通过Camera的View矩阵来获取比较准确。可能是我孤陋寡闻了，真不知道为什么这种常用的属性Unity竟然不提供一个简便的方式来获取。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">var leftEyePos &#x3D; camera.GetStereoViewMatrix(Camera.StereoscopicEye.Left).inverse.GetColumn(3);</code></pre></div></figure><br />本以为就那么简单，可最终的结果确怎么也对不上。折腾了半天打印了VR下的投影矩阵一看，才发现VR下左右眼的视锥体竟然不是个对称的视锥体。<br />之前一直使用<code>public static Matrix4x4 Perspective(float fov, float aspect, float zNear, float zFar)</code>这个函数来生成投影矩阵，导致我忘记了视锥体还有不对称这种情况。<br />于是改用<code>camera.GetStereoProjectionMatrix(Camera.StereoscopicEye.Left);</code>来获取，但结果还是有误差。<br /><img src="mirror02.png" alt="没有对齐" /><br />这里猜一下就猜到还是因为视锥体左右不对称引起的，直觉告诉我，只要反转投影矩阵的第一行（也就是对最终X轴有影响的）的第三个参数（这个数值会和观察空间的深度相乘，最终会影响像素的左右偏移程度）就可以了，<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">leftPMat[8] *&#x3D; -1;rightPMat[8] *&#x3D; -1;</code></pre></div></figure><br />OK，搞定。<br /><img src="mirror03.png" alt="正确情况" /></p><figure><img src="mirror04.jpg" alt="地面反射" /><figcaption aria-hidden="true">地面反射</figcaption></figure><h2 id="渲染镜子背面问题">渲染镜子背面问题</h2><p>当镜子背后有物体时，也会被一同渲染到镜子上。<br />能想到的办法要不就通过layerMask来过滤，要不就完全重构上面的代码。<br />以镜子作为镜像后的相机的近平面，利用投影矩阵刚好剔除了这部分物体。</p><p>最终通过这篇文章<ahref="https://blog.csdn.net/puppet_master/article/details/80808486">UnityShader-反射效果（CubeMap，Reflection Probe，Planar Reflection，ScreenSpace Reflection）</a>才知道已经有前人总结出了<ahref="http://www.terathon.com/lengyel/Lengyel-Oblique.pdf">斜视锥体裁剪</a>。<br />所以最棘手的问题也解决了。只要在求出视角矩阵和投影矩阵后，再依据平面变换一次投影矩阵即可。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">var planeTr &#x3D; MirrorPlanar.Plane;var normal &#x3D; planeTr.forward;var d &#x3D; -Vector3.Dot(normal, planeTr.position);var plane &#x3D; new Vector4(normal.x, normal.y, normal.z, d);projectionMatrix &#x3D; CalculateObliqueMatrix(plane,viewM,projectionMatrix);......&#x2F;&#x2F;如果是VR下要分别对左右眼都变换一次leftPMat &#x3D; CalculateObliqueMatrix(plane,leftViewM,leftPMat);rightPMat &#x3D; CalculateObliqueMatrix(plane,rightViewM,rightPMat);</code></pre></div></figure><br /><code>CalculateObliqueMatrix</code>函数请去原文查阅。<br /><img src="ObliqueMatrix.jpg" alt="剪裁掉镜子的背面" /></p><h2 id="镜像坐标旋转和矩阵">镜像坐标、旋转和矩阵</h2><p>虽然直觉告诉我肯定有个简便和优雅的方法来求一个相机相对于空间任意平面的对称相机的方法，但实在是懒的想了，用了最笨的办法来求。<br />如果有哪位大神知道，还烦请留言告诉我。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public static Quaternion mirrorRot(Transform plane, Quaternion cam)&#123;    var forward &#x3D; plane.forward;    var reflect &#x3D; Vector3.Reflect(cam * Vector3.forward, forward);    var reflectup &#x3D; Vector3.Reflect(cam * Vector3.up, forward);    return Quaternion.LookRotation(reflect, reflectup);&#125;public static Vector3 mirrorPos(Transform plane, Vector3 oldPos)&#123;    var forward &#x3D; plane.forward;    var planPos &#x3D; plane.position;    var dis &#x3D; planPos - oldPos;    var cros &#x3D; Vector3.Cross(dis, forward).normalized;    var ccos &#x3D; Vector3.Cross(cros, forward);    var refDis &#x3D; Vector3.Reflect(dis, ccos);    return refDis + planPos;&#125;public static Matrix4x4 GetViewMat(Vector3 oldPos, Quaternion oldRot)&#123;    var newPos &#x3D; mirrorPos(Plane, oldPos);    var newRot &#x3D; mirrorRot(Plane, oldRot);    return Matrix4x4.TRS(newPos, newRot, new Vector3(1, 1, -1)).inverse;&#125;</code></pre></div></figure></p><h3 id="更新">2022/07/05 更新</h3><p>一个更简便的取对称点位置的函数，同样来自<ahref="https://blog.csdn.net/puppet_master/article/details/80808486">UnityShader-反射效果（CubeMap，Reflection Probe，Planar Reflection，ScreenSpace Reflection）</a><br />但这篇文章里构建的反射矩阵最终的结果并不正确，这会导致模型用反面渲染。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-CS" data-language="CS"><code class="language-CS">public static Vector3 mirrorPos(Transform plane, Vector3 oldPos)&#123;    var normal &#x3D; plane.forward;    var d &#x3D; -Vector3.Dot(normal, plane.position);    return oldPos - 2 * (Vector3.Dot(oldPos, normal) + d) * normal;&#125;</code></pre></div></figure></p><h1 id="问题">问题</h1><h2 id="视锥体裁剪">视锥体裁剪</h2><p>这里视锥体裁剪使用的还是之前的裁剪矩阵，要想正确构建一个适用于左右眼的裁剪矩阵太复杂了，干脆弄个超大的视锥体，等同于不要裁剪。<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">CullingResults cullingResults;var cullMat &#x3D; Matrix4x4.Frustum(-1, 1, -1, 1, 0.0000001f, 10000000f);camera.cullingMatrix &#x3D; cullMat * viewM;camera.TryGetCullingParameters(out var cullingParameters);cullingResults &#x3D; context.Cull(ref cullingParameters);</code></pre></div></figure></p><h2 id="阴影剔除和附加光源裁剪的问题">阴影剔除和附加光源裁剪的问题</h2><p>这里暂时没有太好的解决方案，不清楚URP绘制阴影的过程能否被干预，如果镜子中的物体没有在正常相机内有阴影的话，镜子中也不会有阴影。<br />这里去看HDRP的平面反射探针时也发现了，HDRP是真的虚拟了一个相机，重新绘制了阴影，包括后处理等一应俱全，这会增加不少性能消耗。<br />而这里这种方法，在URP官方示例场景下，开关效果GPU时间增加了1.7ms。</p><h2 id="天空盒问题">天空盒问题</h2><p>这是<ahref="https://forum.unity.com/threads/hlsl-or-shadergraph-skybox-shader-with-single-pass-instancing.1234660/">官方已知的BUG</a>，SPR管线下绘制天空盒到RT上需要手动将ZClip关闭。</p>]]></content>
    
    
    <categories>
      
      <category>渲染</category>
      
    </categories>
    
    
    <tags>
      
      <tag>URP</tag>
      
      <tag>VR</tag>
      
      <tag>反射</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LensFlare(SRP) in VR</title>
    <link href="/2022/06/27/LensFlare-SRP-in-VR/"/>
    <url>/2022/06/27/LensFlare-SRP-in-VR/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>Unity的URP和HDRP针对LensFlare也就是炫光，使用的是同一套逻辑(LensFlare(SRP))。但就是不支持VR，无论是单通道还是多通道。</p><span id="more"></span><p>Unity这样做也有一定的道理，本来这个效果就是模拟镜头的一种缺陷，人眼一般不会看到这种炫光，所以VR不支持也是理所当然的。<br />但本着没事找事的心态，权当练习，我翻看了这部分的源码，做了一点修改，使之能兼容VR。</p><p>效果如下：</p><figure><img src="Len_01.jpg" alt="镜头炫光" /><figcaption aria-hidden="true">镜头炫光</figcaption></figure><p>这里是<ahref="https://github.com/MaZhengKe/LensFlareVR">仓库地址</a><br />在我给官方提了这个BUG后，回复是就是不支持。<br />论坛上也有有说<ahref="https://forum.unity.com/threads/lensflare-srp-does-not-work-properly-in-vr-and-urp.1249408/">这个问题</a>已经存在很久了。<br /><img src="Len_Err.jpg" alt="平行光偏移" /><img src="Len_Err02.jpg"alt="点光源偏移" /></p><h1 id="分析">分析</h1><p>先从看它的shader入手吧，很简单，就一个文件LensFlareDataDriven.shader，分了4个pass，每个pass的区别仅仅在于Blend的方式，分别对应了Additive、Screen、Premultiply、Lerp四种BlendMode。<br /><img src="Len_BlendMode.png"alt="Lens Flare Data中的四种BlendMode" /></p><p>关键的逻辑在LensFlareCommon.hlsl中，输入有两张贴图，颜色一张，遮挡一张，然后是一个颜色和5个向量，分别定义了颜色，旋转、缩放、屏幕位置、偏移、宽高比、遮挡半径、遮挡采样次数、是否离屏渲染以及边缘偏移、羽化范围、多边形属性等等。</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">TEXTURE2D(_FlareTex);SAMPLER(sampler_FlareTex);#if defined(HDRP_FLARE) &amp;&amp; defined(FLARE_OCCLUSION)TEXTURE2D_X(_FlareOcclusionTex);SAMPLER(sampler_FlareOcclusionTex);#endiffloat4 _FlareColorValue;float4 _FlareData0; &#x2F;&#x2F; x: localCos0, y: localSin0, zw: PositionOffsetXYfloat4 _FlareData1; &#x2F;&#x2F; x: OcclusionRadius, y: OcclusionSampleCount, z: ScreenPosZ, w: ScreenRatiofloat4 _FlareData2; &#x2F;&#x2F; xy: ScreenPos, zw: FlareSizefloat4 _FlareData3; &#x2F;&#x2F; x: Allow Offscreen, y: Edge Offset, z: Falloff, w: invSideCountfloat4 _FlareData4; &#x2F;&#x2F; x: SDF Roundness, y: Poly Radius, z: PolyParam0, w: PolyParam1</code></pre></div></figure><p>而且都通过定义宏的方式来增强了可读性，学到了。</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">#define _LocalCos0              _FlareData0.x#define _LocalSin0              _FlareData0.y#define _PositionTranslate      _FlareData0.zw#define _OcclusionRadius        _FlareData1.x#define _OcclusionSampleCount   _FlareData1.y#define _ScreenPosZ             _FlareData1.z#ifndef _FlareScreenRatio#define _FlareScreenRatio       _FlareData1.w#endif</code></pre></div></figure><p>再往下就发现了从shadertoy拿来的工具函数<code>float4 ComputeCircle(float2 uv)</code><code>float4 ComputePolygon(float2 uv_)</code>，用来程序化直接从UV绘制椭圆和多边形的。</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float4 GetFlareShape(float2 uv)&#123;#ifdef FLARE_CIRCLE    return ComputeCircle(uv);#elif defined(FLARE_POLYGON)    return ComputePolygon(uv);#else    return SAMPLE_TEXTURE2D(_FlareTex, sampler_FlareTex, uv);#endif&#125;</code></pre></div></figure><p>这里看到绘制分成三种，圆，多边形，贴图。对应了这里的Type<br /><img src="Len_Type.png" alt="Lens Flare Data中的三种类型" /></p><p>最后来看看vert函数<br /><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float4 posPreScale &#x3D; float4(2.0f, 2.0f, 1.0f, 1.0f) * GetQuadVertexPosition(input.vertexID) - float4(1.0f, 1.0f, 0.0f, 0.0);float2 uv &#x3D; GetQuadTexCoord(input.vertexID);uv.x &#x3D; 1.0f - uv.x;output.texcoord.xy &#x3D; uv;posPreScale.xy *&#x3D; _FlareSize;float2 local &#x3D; Rotate(posPreScale.xy, _LocalCos0, _LocalSin0);local.x *&#x3D; screenRatio;output.positionCS.xy &#x3D; local + _ScreenPos + _PositionTranslate;output.positionCS.z &#x3D; 1.0f;output.positionCS.w &#x3D; 1.0f;</code></pre></div></figure></p><p>用传入的屏幕坐标来缩放、旋转、乘上宽高比，加上UV偏移和另一个传入的偏移量直接写入positionCS。这里的positionCS是裁剪空间坐标，因为w设置为1，那xy范围就是(-1,1)，(0,0)表示屏幕中心。</p><p>看到这就已经猜到它为什么不支持VR了，因为屏幕坐标是事先用C#脚本通过Camera的属性计算好的，而且估计计算时没有考虑VR下有两个摄像机，导致最终的屏幕位置是错误的。</p><h1 id="修改">修改</h1><p>那修改的思路就确定了，增加一个向量，记录炫光分别在左右眼下的屏幕位置，依据USING_STEREO_MATRICES和unity_StereoEyeIndex来判断当前到底该使用哪一个屏幕坐标。</p><h2 id="脚本修改">脚本修改</h2><p>回到代码中，从LensFlareComponent一路往回推，发现主要的逻辑代码都在LensFlareCommonSRP中，用单例来管理，而调用则是在URP的UniversalRenderer中，在后处理时，由PostProcessPass调用，通过FrameDebugger也能看到。</p><p>URP的代码没法修改，只好全部另起炉灶，自定义RenderFeature、pass、Component等，把原来的逻辑先复制一遍，开始修改。<br /><img src="Len_File.png" alt="目录结构" /><br />从PostProcessPass的DoLensFlareDatadriven中可以看到<br /><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">void DoLensFlareDatadriven(Camera camera, CommandBuffer cmd, RenderTargetIdentifier source, bool usePanini, float paniniDistance, float paniniCropToFit)&#123;    var gpuView &#x3D; camera.worldToCameraMatrix;    var gpuNonJitteredProj &#x3D; GL.GetGPUProjectionMatrix(camera.projectionMatrix, true);    &#x2F;&#x2F; Zero out the translation component.    gpuView.SetColumn(3, new Vector4(0, 0, 0, 1));    var gpuVP &#x3D; gpuNonJitteredProj * camera.worldToCameraMatrix;        LensFlareCommonSRP.DoLensFlareDataDrivenCommon(m_Materials.lensFlareDataDriven, LensFlareCommonSRP.Instance, camera, (float)m_Descriptor.width, (float)m_Descriptor.height,        usePanini, paniniDistance, paniniCropToFit,        true,        camera.transform.position,        gpuVP,        cmd, source,        (Light light, Camera cam, Vector3 wo) &#x3D;&gt; &#123; return GetLensFlareLightAttenuation(light, cam, wo); &#125;,        ShaderConstants._FlareOcclusionTex, ShaderConstants._FlareOcclusionIndex,        ShaderConstants._FlareTex, ShaderConstants._FlareColorValue,        ShaderConstants._FlareData0, ShaderConstants._FlareData1, ShaderConstants._FlareData2, ShaderConstants._FlareData3, ShaderConstants._FlareData4,        false);&#125;</code></pre></div></figure></p><p>这里是用的camera.worldToCameraMatrix来直接拿的矩阵，但在VR环境下，应该要用camera.GetStereoViewMatrix(eye);的方式分别来取左右眼的矩阵。所以这里添加上左右眼的VP矩阵，传入DoLensFlareDataDrivenCommon中。</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Matrix4x4 getMatrixFromEye(Camera camera, Camera.StereoscopicEye eye)&#123;    var gpuView &#x3D; camera.GetStereoViewMatrix(eye);    var gpuNonJitteredProj &#x3D; GL.GetGPUProjectionMatrix(camera.GetStereoNonJitteredProjectionMatrix(eye), true);    &#x2F;&#x2F; Zero out the translation component.    gpuView.SetColumn(3, new Vector4(0, 0, 0, 1));    var gpuVP &#x3D; gpuNonJitteredProj * gpuView;    return gpuVP;&#125;void DoLensFlareDatadriven(Camera camera, CommandBuffer cmd, RenderTargetIdentifier source, bool usePanini,    float paniniDistance, float paniniCropToFit)&#123;    ......    var leftGpuVP &#x3D; getMatrixFromEye(camera, Camera.StereoscopicEye.Left);    var rightGpuVP &#x3D; getMatrixFromEye(camera, Camera.StereoscopicEye.Right);        LensFlareCommonMK.DoLensFlareDataDrivenCommon(m_Material, LensFlareCommonMK.Instance, camera,    (float)m_Descriptor.width, (float)m_Descriptor.height,    usePanini, paniniDistance, paniniCropToFit,    true,    camera.transform.position,    gpuVP,    leftGpuVP,    rightGpuVP,    cmd, source,    ......&#125;</code></pre></div></figure><p>来到DoLensFlareDataDrivenCommon函数，这里必须吐槽下这个函数，近16个参数就不说了，函数体也有500多行。。。<br />在这里增加一个函数来计算炫光在左右眼中的屏幕位置</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">static public Vector2 GetScreenPos(Camera.MonoOrStereoscopicEye eye, LensFlareComponentMK comp, Camera cam, bool isCameraRelative, Matrix4x4 viewProjMatrix)&#123;    Light light &#x3D; comp.GetComponent&lt;Light&gt;();    Vector3 positionWS;    Vector3 viewportPos;    bool isDirLight &#x3D; false;    if (light !&#x3D; null &amp;&amp; light.type &#x3D;&#x3D; LightType.Directional)    &#123;        positionWS &#x3D; -light.transform.forward * cam.farClipPlane;        isDirLight &#x3D; true;    &#125;    else    &#123;        positionWS &#x3D; comp.transform.position;    &#125;    viewportPos &#x3D; WorldToViewport(eye, cam, !isDirLight, isCameraRelative, viewProjMatrix, positionWS);    Vector2 screenPos &#x3D; new Vector2(2.0f * viewportPos.x - 1.0f, 1.0f - 2.0f * viewportPos.y);    return screenPos;&#125;</code></pre></div></figure><p>在使用相机位置的时候也分别要用左右眼球的位置</p><figure><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public static Vector3 GetEyePosition(Side eye)&#123;    if (XRSettings.enabled)    &#123;        Vector3 posLeft;        InputDevice device &#x3D;            InputDevices.GetDeviceAtXRNode(eye &#x3D;&#x3D; Side.Left ? XRNode.LeftEye : XRNode.RightEye);        if (device.isValid)        &#123;            if (device.TryGetFeatureValue(                    eye &#x3D;&#x3D; Side.Left ? CommonUsages.leftEyePosition : CommonUsages.rightEyePosition,                    out posLeft))                return posLeft;        &#125;        Debug.LogError(&quot;can not find eyePos&quot;);        return default(Vector3);    &#125;    else    &#123;        return Camera.main.transform.position;    &#125;&#125;</code></pre></div></figure><p>计算出来后，添加进去</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">var leftPos &#x3D; GetScreenPos(Camera.MonoOrStereoscopicEye.Left,comp,cam,isCameraRelative,LeftViewProjMatrix);var rightPos &#x3D; GetScreenPos(Camera.MonoOrStereoscopicEye.Right,comp,cam,isCameraRelative,RightViewProjMatrix);cmd.SetGlobalVector(ShaderConstants._FlareData5,new Vector4(leftPos.x,leftPos.y,rightPos.x,rightPos.y));</code></pre></div></figure><hr /><h2 id="shader修改">Shader修改</h2><p>然后是shader的修改<br />增加一行输入，并定义好宏</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">float4 _FlareData5;   #define _LeftScreenPos          _FlareData5.xy#define _RightScreenPos         _FlareData5.zw</code></pre></div></figure><p>vert中根据再unity提供的宏来判断一下</p><figure><div class="code-wrapper"><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">#if defined(USING_STEREO_MATRICES)float2 _ScreenPos &#x3D; unity_StereoEyeIndex &#x3D;&#x3D; 1? _RightScreenPos : _LeftScreenPos;# elsefloat2 _ScreenPos &#x3D; _CameraScreenPos;# endif</code></pre></div></figure><p>就完工了。</p><p><img src="Len_01.jpg" alt="平行光" /><img src="Len_02.jpg"alt="点光源" /></p><p>这里其实还是有个小问题，这种效果其实不符合物理。<br />因为如果在左右眼分别放置一个相机，拍出来的炫光的偏移位置（<code>#define _PositionTranslate      _FlareData0.zw</code>）其实应该是各不相同的。<br />但这会造成体验VR的人视觉混乱，所以为了体验效果，这里使用的偏移还是之前相机（也就是两眼中间位置）的偏移，只是修复了炫光原点的屏幕坐标位置。</p>]]></content>
    
    
    <categories>
      
      <category>渲染</category>
      
    </categories>
    
    
    <tags>
      
      <tag>URP</tag>
      
      <tag>LensFlare</tag>
      
      <tag>VR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OutlineInURP VR</title>
    <link href="/2022/06/23/OutlineInURP-VR/"/>
    <url>/2022/06/23/OutlineInURP-VR/</url>
    
    <content type="html"><![CDATA[<h1 id="urp管线下vr适用的外轮廓描边">URP管线下VR适用的外轮廓描边</h1><p><ahref="https://github.com/MaZhengKe/OutlineRendererFeatureVR">github地址</a></p><hr /><p>因为很多模型不给平滑法线，没法用法线外扩，只能用类似后处理的方式来描边了.</p><p>好处是通用性强，任何模型都能用，弊端就是性能消耗大一点。<br /><span id="more"></span><br />VR下大概增加了0.4ms</p><p>主要参考自 https://zhuanlan.zhihu.com/p/170241589在此基础上改为URP的RenderFeature，并支持了VR中SinglePass</p><figure><img src="All.jpg" alt="全部显示" /><figcaption aria-hidden="true">全部显示</figcaption></figure><p>大体思路是先绘制遮罩，再遮罩外扩。</p><ul><li>支持多重RenderFeature的叠加</li><li>mass抗锯齿</li><li>遮挡显示与否</li><li>支持VR中SinglePass渲染模式</li><li>采用了RenderLayerMask，避免了占用LayerMask<br /><!-- more --></li></ul><figure><img src="Hide.jpg" alt="遮挡不显示" /><figcaption aria-hidden="true">遮挡不显示</figcaption></figure><figure><img src="mult.jpg" alt="多重RenderFeature叠加" /><figcaption aria-hidden="true">多重RenderFeature叠加</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>渲染</category>
      
    </categories>
    
    
    <tags>
      
      <tag>URP</tag>
      
      <tag>VR</tag>
      
      <tag>RenderFeature</tag>
      
      <tag>Outline</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
